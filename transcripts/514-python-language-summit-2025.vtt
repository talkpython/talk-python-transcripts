WEBVTT

00:00:00.020 --> 00:00:06.860
Every year, the core developers of Python convene in person to focus on high-priority topics for CPython and beyond.

00:00:07.440 --> 00:00:09.620
This year, they met at PyCon US 2025.

00:00:10.540 --> 00:00:14.180
Those meetings are a closed door to keep focused and productive.

00:00:14.460 --> 00:00:21.900
But we're lucky that Seth Michael Larson was in attendance and wrote up each topic presented and the reactions and feedback for each.

00:00:22.300 --> 00:00:24.780
We'll be exploring this year's Language Summit with Seth.

00:00:24.860 --> 00:00:30.080
It's quite insightful to where Python is going and the pressing matters the core devs are

00:00:30.220 --> 00:00:31.000
giving their attention to.

00:00:31.860 --> 00:00:37.800
This is Talk Python To Me, episode 514, recorded June 17th, 2025.

00:00:51.460 --> 00:00:53.760
to unite. We started in pyramid cruising. Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:54.060 --> 00:00:56.860
to unite. We started in pyramid cruising. Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:57.460 --> 00:01:02.700
This is your host, Michael Kennedy. Follow me on Mastodon where I'm @mkennedy and follow the

00:01:02.890 --> 00:01:09.020
podcast using @talkpython, both accounts over at fosstodon.org and keep up with the show and

00:01:09.020 --> 00:01:14.480
listen to over nine years of episodes at talkpython.fm. If you want to be part of our live episodes,

00:01:14.850 --> 00:01:19.200
you can find the live streams over on YouTube. Subscribe to our YouTube channel over at

00:01:19.220 --> 00:01:25.140
 talkpython.fm/youtube and get notified about upcoming shows. This episode is brought to you

00:01:25.340 --> 00:01:31.060
entirely by Sentry. It's a bit of an episode takeover, if you will. Sentry has two excellent

00:01:31.060 --> 00:01:37.260
and exciting services to tell you about. Sear, your agentic AI debugging assistant, which takes

00:01:37.600 --> 00:01:43.239
all the data already gathered by Sentry to help discover the problems and even propose fixes as

00:01:43.260 --> 00:01:50.520
GitHub PRs. And the other is AI agent monitoring, which adds deep observability to your AI agents

00:01:50.680 --> 00:01:56.020
in your app. If you're adding AI and LLM features to your Python apps, you'll want to know about AI

00:01:56.380 --> 00:02:00.660
agent monitoring. I'll tell you more about both of these later in the episode. And remember,

00:02:01.440 --> 00:02:07.400
however you happen to sign up for Sentry, if you do use our code, TALKPYTHON, one word, all caps,

00:02:08.020 --> 00:02:12.460
let's get to the interview. Seth, welcome back to Talk Python. I mean, awesome to have you here.

00:02:12.800 --> 00:02:13.480
Thank you for having me, Michael.

00:02:14.520 --> 00:02:16.900
Yeah, it's always fun to have you on the show.

00:02:17.290 --> 00:02:17.900
And you know what?

00:02:17.990 --> 00:02:21.660
I don't even think we're going to talk that much about security this episode, are we?

00:02:22.060 --> 00:02:22.600
Not too much.

00:02:22.920 --> 00:02:23.000
No.

00:02:23.940 --> 00:02:27.000
I mean, as I say that, I'm sure we're going to come up with something, right?

00:02:27.180 --> 00:02:32.820
But the last couple of times I've had you on, it's because you're doing something with security

00:02:33.020 --> 00:02:35.320
and Python, and it's always been very interesting.

00:02:35.600 --> 00:02:35.700
It's true.

00:02:35.700 --> 00:02:35.880
It's true.

00:02:35.970 --> 00:02:38.500
Yeah, no, I do a lot of security these days, but I do other things too.

00:02:41.280 --> 00:02:46.760
be the eyes and ears of everyone who could not attend the language summit yeah so i was the

00:02:46.760 --> 00:02:47.560
be the eyes and ears of everyone who could not attend the language summit yeah so i was the

00:02:47.700 --> 00:02:52.020
blogger again this year i got invited back they didn't uh they liked what i did last year so like

00:02:52.020 --> 00:02:56.800
ah well we'll have this guy again why not right like yeah it was great i mean i love attending

00:02:56.800 --> 00:03:01.500
the language summit blogging for it it's a it's a really unique way to contribute back to the to

00:03:01.580 --> 00:03:04.180
python community it's a such a specific role so yeah it really is i think maybe we start there

00:03:04.180 --> 00:03:07.480
python community it's a such a specific role so yeah it really is i think maybe we start there

00:03:07.480 --> 00:03:18.520
Maybe we start with what is the Language Summit and why are there not just a bunch of videos online and why weren't there sessions that necessarily open sessions at PyCon, right?

00:03:18.660 --> 00:03:20.580
It's kind of a special event.

00:03:21.000 --> 00:03:28.600
Yeah, so the Language Summit is, historically, it is this event that happens every year before, right before PyCon US.

00:03:29.210 --> 00:03:31.320
It's been hosted in other PyCons as well.

00:03:31.580 --> 00:03:37.180
But nowadays it happens at PyCon US and it occurs kind of at the same time that like tutorials are happening.

00:03:37.420 --> 00:03:42.840
So that's a day or two before the actual conference starts for most attendees where there's talks and all of that.

00:03:43.600 --> 00:03:55.240
And basically what ends up happening is a bunch of core developers and triagers and some special guests all convene into one room for a full day of short talks followed by tons of discussion.

00:03:56.480 --> 00:04:00.020
And the reason that it's like a closed session is like one, it's a logistical thing.

00:04:00.220 --> 00:04:01.800
Like the room is only so big.

00:04:02.100 --> 00:04:09.140
And I'm pretty sure the organizers know that if it was just like open session, it would be like, oh, we need to have this huge conference room of people.

00:04:09.230 --> 00:04:20.640
And it's not really conducive to discussion because it is very fast moving, asking questions, getting answers and having people be able to exchange this information really quickly.

00:04:21.380 --> 00:04:26.900
And so to offset the lack of openness, right, because not everyone can possibly attend that

00:04:26.980 --> 00:04:32.320
wants to attend, what ends up happening is a blogger, someone who covers the actual event,

00:04:32.630 --> 00:04:35.940
every single talk, every single discussion, all the questions, what gets discussed,

00:04:36.880 --> 00:04:40.220
and then like the vibes of the room and like how people are feeling about topics.

00:04:40.930 --> 00:04:45.500
That gets covered by a blogger, which this year was me, last year was also me, but then

00:04:45.670 --> 00:04:50.380
the years prior has been like Alex Waygood covered the year prior to me starting.

00:04:50.860 --> 00:04:54.080
So Alex taught me everything I need to know and what to expect and all of that.

00:04:54.540 --> 00:04:54.780
Nice.

00:04:54.940 --> 00:04:55.060
Yeah.

00:04:55.060 --> 00:04:57.820
And I had you on last year and I had Alex on the year before, I believe.

00:04:58.120 --> 00:04:59.300
So it's a bit of a tradition.

00:04:59.720 --> 00:05:00.100
There we go.

00:05:00.680 --> 00:05:00.820
Cool.

00:05:00.880 --> 00:05:06.220
And yeah, also people should know it's a working session with the goal of not just presenting

00:05:06.540 --> 00:05:12.180
ideas, but making decisions, trying to come to an agreement with the core devs and steering

00:05:12.440 --> 00:05:15.580
council and maybe other councils, as we'll see all the councils.

00:05:16.160 --> 00:05:16.340
Yeah.

00:05:16.560 --> 00:05:16.640
Yeah.

00:05:16.900 --> 00:05:16.980
Right.

00:05:17.200 --> 00:05:18.160
No, it's lots of decision makers in there.

00:05:18.160 --> 00:05:19.540
No, it's lots of decision makers in there.

00:05:19.660 --> 00:05:28.260
I feel like it tends to be a really great arena to kind of just get really quick feedback on either ideas or questions.

00:05:28.770 --> 00:05:29.820
Because like it's really funny.

00:05:30.110 --> 00:05:33.900
One of the talks happened not to get into too much detail right away.

00:05:33.970 --> 00:05:35.060
But like one of the talks happened.

00:05:35.180 --> 00:05:36.180
They're like, oh, we have this problem.

00:05:36.270 --> 00:05:39.980
We really need more arm builders for GitHub CI for this specific reason.

00:05:40.400 --> 00:05:45.640
And E Durbin, director of infrastructure at PSF, was in the room and they were just like, oh, I just bought more.

00:05:46.520 --> 00:05:47.540
And it's like, oh, great.

00:05:47.800 --> 00:05:47.920
Oh, that's awesome.

00:05:48.100 --> 00:05:48.440
Oh, that's awesome.

00:05:49.120 --> 00:05:49.800
Quick feedback.

00:05:50.880 --> 00:05:52.220
That's the way to make it happen.

00:05:52.760 --> 00:05:53.100
That's right.

00:05:53.710 --> 00:06:00.280
You know, before we get into that, just maybe it's worth a quick conversation about.

00:06:00.400 --> 00:06:01.960
You were actually in New York City.

00:06:02.390 --> 00:06:04.120
We just heard a siren go by.

00:06:04.380 --> 00:06:07.240
So we now officially know that you're in New York City, right?

00:06:07.380 --> 00:06:08.340
Yes, exactly.

00:06:08.960 --> 00:06:11.320
There's always something going on there in terms of noise or energy or whatever.

00:06:11.320 --> 00:06:12.260
There's always something going on there in terms of noise or energy or whatever.

00:06:12.260 --> 00:06:13.380
There's always something going on there in terms of noise or energy or whatever.

00:06:14.040 --> 00:06:16.380
For the UN Open Source Conference, that's super interesting.

00:06:16.640 --> 00:06:17.320
For the UN Open Source Conference, that's super interesting.

00:06:17.320 --> 00:06:17.720
For the UN Open Source Conference, that's super interesting.

00:06:17.730 --> 00:06:18.200
What is that?

00:06:18.520 --> 00:06:19.160
Yeah, so United Nations Open Source Week.

00:06:19.160 --> 00:06:21.060
Yeah, so United Nations Open Source Week.

00:06:21.270 --> 00:06:26.000
I got invited to attend through the Software Tech Agency and also Alpha Omega.

00:06:26.350 --> 00:06:38.300
They are collaborating to host a maintain-a-thon, which is essentially just get a whole bunch of open source project maintainers, project leaders, governance people, like people doing more than just security.

00:06:38.510 --> 00:06:43.700
So I was there to represent the security perspective and also Python, Python Software Foundation.

00:06:44.860 --> 00:06:57.440
And just getting us all together and trying to talk about really complicated issues for open source and how open source can be used to better the world, to be a part of, you know, a more open access world, more open data world.

00:06:58.140 --> 00:06:59.340
Those are kind of like the themes.

00:06:59.720 --> 00:07:12.260
And specifically the maintain-a-thon was more like hosting small sessions with lots of discussion, almost kind of like the Language Summit, where there's a really short presentation about a topic I presented on low energy security.

00:07:12.660 --> 00:07:18.580
So security practices and processes for projects that don't have access to tons of security expertise.

00:07:19.320 --> 00:07:21.400
And then like, what are the, how can we make the situation better for those types of projects?

00:07:21.400 --> 00:07:23.560
And then like, what are the, how can we make the situation better for those types of projects?

00:07:24.100 --> 00:07:24.660
Oh, very cool.

00:07:25.300 --> 00:07:30.460
There's, you know, there's a lot of energy for open source in the United States corporately,

00:07:31.040 --> 00:07:35.400
but internationally, there's a lot of energy for open source at a governmental level.

00:07:35.880 --> 00:07:37.620
More so, way more so than the US.

00:07:37.900 --> 00:07:44.300
I mean, there's little pockets of things like, hey, we'd like to have some open source initiatives for what we're building in the US.

00:07:44.580 --> 00:07:47.600
But there's, I can't remember what country's doing it right now.

00:07:47.650 --> 00:07:54.420
One of the countries is trying to replace basically Microsoft Office and Windows with something Linux and open source.

00:07:54.690 --> 00:07:55.840
And there's a lot of stuff like that.

00:07:55.990 --> 00:07:56.140
Yeah.

00:07:56.430 --> 00:08:01.000
I mean, it's about having sovereignty about or like over your technology stack, right?

00:08:01.180 --> 00:08:01.560
Making sure that you have complete control and that there's interoperability and that.

00:08:01.560 --> 00:08:01.960
Making sure that you have complete control and that there's interoperability and that.

00:08:01.960 --> 00:08:05.520
Making sure that you have complete control and that there's interoperability and that.

00:08:05.740 --> 00:08:16.340
Yeah. Being able to work independently as like a government agency, just as important as a company, right? You want to make sure that you're able to control all the processes and data that are inside that are important to you.

00:08:16.420 --> 00:08:16.800
Sure. And I think we're in a bit of a special situation being in the U.S.

00:08:16.920 --> 00:08:22.540
Sure. And I think we're in a bit of a special situation being in the U.S.

00:08:23.340 --> 00:08:29.160
I don't think we have as much of a feeling of, wouldn't it be nice if we weren't beholden to U.S. companies?

00:08:29.700 --> 00:08:33.840
Because we're already beholden to the U.S. We live here, we pay taxes, we're subject to the rules.

00:08:34.300 --> 00:08:39.539
But if you're outside of the U.S., most countries and organizations are still beholden to U.S. companies.

00:08:39.770 --> 00:08:43.800
And I think that that's a part of the vein of the ideas there, right?

00:08:43.800 --> 00:08:44.740
And I think that that's a part of the vein of the ideas there, right?

00:08:45.020 --> 00:09:04.820
Yeah, it definitely is a part of it. Being able to do your own thing without worrying about other countries, what they're doing or what their relationship is with you and still being able to interoperate on a global scale. Right. Because like a lot of these formats are open and they interoperate like PDF, Doc X. They're all they're all open. They can be written by any software, not just Microsoft software.

00:09:04.900 --> 00:09:05.440
So yeah, absolutely. And I guess that's true for the U.S. in terms of software, but not so much for hardware, right? We're more in the same boat as everyone else with hardware, but that is a bit too far down the weeds, maybe, so we don't need to debate that. But it's super interesting that you're at that conference and it sounds really fun.

00:09:05.620 --> 00:09:23.780
So yeah, absolutely. And I guess that's true for the U.S. in terms of software, but not so much for hardware, right? We're more in the same boat as everyone else with hardware, but that is a bit too far down the weeds, maybe, so we don't need to debate that. But it's super interesting that you're at that conference and it sounds really fun.

00:09:24.100 --> 00:09:28.660
Yeah, it's a great time. A lot of really smart people here. So I'm happy that they let me in.

00:09:30.420 --> 00:09:30.920
How'd I get here?

00:09:31.600 --> 00:09:31.960
Exactly.

00:09:32.300 --> 00:09:34.200
What office did you run for to get elected to that?

00:09:34.200 --> 00:09:34.320
What office did you run for to get elected to that?

00:09:34.380 --> 00:09:35.680
Oh, none. None of them.

00:09:36.040 --> 00:09:39.080
Cool. So let's talk Language Summit.

00:09:39.620 --> 00:09:44.400
When we started sort of backstage, we were trying to plan out some of the themes and stuff.

00:09:44.860 --> 00:09:49.000
You talked about there being a couple of major themes of the Language Summit this year.

00:09:49.200 --> 00:09:54.380
And I certainly, reading your write-up, thought like, wow, multi-threading has got some attention.

00:09:54.700 --> 00:09:57.820
Yeah, free-threading was a big part of the Language Summit.

00:09:57.880 --> 00:10:03.980
I think it was like a third, somewhere between a third and a half of the talks touched free

00:10:04.120 --> 00:10:07.280
threading or parallelism or the concurrency model of Python.

00:10:08.270 --> 00:10:09.460
It was obviously a big thing.

00:10:09.620 --> 00:10:09.800
Yeah.

00:10:09.880 --> 00:10:09.960
What are some of the other themes?

00:10:09.960 --> 00:10:11.160
What are some of the other themes?

00:10:11.560 --> 00:10:11.700
Yeah.

00:10:11.700 --> 00:10:16.500
So the other ones are things like, okay, we have all these other platforms for Python.

00:10:16.860 --> 00:10:22.000
If you read, if you've read like the last year's language summit, there's kind of this

00:10:22.090 --> 00:10:26.020
through line of like mobile and web both kind of got discussed.

00:10:26.320 --> 00:10:52.960
And so if you contrast like the status of those projects, then what the write ups were to now, the projects are way further down the line. So like Russell came up and got to say like, oh, mobile for Python, both on Android and iOS are basically here. And a huge round of applause from all the core devs because they were super successful in achieving the mission that they set out to do back a year ago at the language summit where they laid out what their plans were.

00:10:54.100 --> 00:11:05.400
So yeah, there it will be basically mobile support. I think it's for three working, I think is the hope that it's going to be actually like working and you should use it and you can build apps with it. And that's really exciting.

00:11:05.640 --> 00:11:06.940
So yeah, there it will be basically mobile support. I think it's for three working, I think is the hope that it's going to be actually like working and you should use it and you can build apps with it. And that's really exciting.

00:11:07.680 --> 00:11:08.600
It is very exciting.

00:11:09.120 --> 00:11:13.780
Yeah. And then the other platform is web, obviously. So Pyodide is, is one of the big

00:11:13.830 --> 00:11:20.220
ones there. So if you've heard of like PyScript or, Jupyter light uses Pyodide, both of

00:11:20.360 --> 00:11:26.420
those platforms, like for Python on the web, there was this talk about upstreaming, the

00:11:26.560 --> 00:11:32.900
FFI, the JavaScript FFI and some JavaScript APIs, to see Python as opposed to keeping them

00:11:33.380 --> 00:11:34.340
resident in Pyodide. And what that would essentially mean is that if you ran Python

00:11:34.640 --> 00:11:35.160
resident in Pyodide. And what that would essentially mean is that if you ran Python

00:11:35.160 --> 00:11:38.459
resident in Pyodide. And what that would essentially mean is that if you ran Python

00:11:38.480 --> 00:11:44.300
compiled for, what was it, like the WebAssembly platform, you would be able to interact with

00:11:44.440 --> 00:11:48.300
JavaScript from the standard library, like the OS module or something like that.

00:11:48.440 --> 00:11:49.860
And that is pretty exciting to hear something like that.

00:11:49.860 --> 00:11:51.860
And that is pretty exciting to hear something like that.

00:11:51.910 --> 00:11:55.900
And there was also some talk about, apparently recently, MicroPython got web support.

00:11:56.150 --> 00:12:00.660
And so trying to unify a little bit the APIs that the two are using.

00:12:01.380 --> 00:12:02.260
Yeah, that's super exciting.

00:12:02.500 --> 00:12:03.500
We'll definitely dive into it.

00:12:03.660 --> 00:12:11.600
The fact that MicroPython got web support means it's possibly a good use for broader web applications, right?

00:12:11.630 --> 00:12:17.040
Because PyDot is awesome, but it's also something like 10 megs or somewhere in megs.

00:12:17.040 --> 00:12:19.820
And it takes a bit to load up because it is basically CPython.

00:12:20.200 --> 00:12:21.600
Whereas MicroPython is 100k.

00:12:22.040 --> 00:12:27.580
And people are used to doing 100k JavaScript, but not multi-meg JavaScript for standard stuff.

00:12:27.860 --> 00:12:28.760
So yeah, really exciting.

00:12:29.080 --> 00:12:29.700
We'll dive into that.

00:12:29.890 --> 00:12:30.520
We'll dive into that.

00:12:30.660 --> 00:12:35.600
So not surprising. I thought we could just maybe work our way through the different presentations.

00:12:36.410 --> 00:12:39.080
How long is each presentation besides the lightning talks about?

00:12:39.440 --> 00:12:39.800
Yeah. So it's each session is, I think it's like 30 minutes. The talk itself is usually

00:12:39.800 --> 00:12:45.860
Yeah. So it's each session is, I think it's like 30 minutes. The talk itself is usually

00:12:46.360 --> 00:12:49.240
10 minutes. I could actually think of the schedule. I should know that's off the top of my head.

00:12:49.500 --> 00:12:53.400
The recitations are super fast. They're like 10 minutes and then the rest is discussion. So it's

00:12:53.910 --> 00:12:54.340
The recitations are super fast. They're like 10 minutes and then the rest is discussion. So it's

00:12:54.690 --> 00:12:54.820
quite a quick format. And your write-up mirrors that, right? So people read your

00:12:54.820 --> 00:12:55.040
quite a quick format. And your write-up mirrors that, right? So people read your

00:12:55.040 --> 00:12:59.619
quite a quick format. And your write-up mirrors that, right? So people read your

00:12:59.700 --> 00:13:04.120
post, I'll link to, what I'm going to do is I'm going to link to the meta post, I guess,

00:13:04.660 --> 00:13:09.760
in the sense of like a meta package in that it says, here's all the articles for, that

00:13:09.760 --> 00:13:11.260
I wrote up for the language summit.

00:13:11.490 --> 00:13:13.120
So you can jump to the ones you want to see.

00:13:13.440 --> 00:13:15.220
And it, your, your write-ups mirror that.

00:13:15.230 --> 00:13:16.900
It's like, here's what happened in the presentation.

00:13:17.150 --> 00:13:20.260
And then the discussion that happened below it from all the core devs.

00:13:20.740 --> 00:13:20.900
Yeah.

00:13:21.060 --> 00:13:21.120
Yeah.

00:13:21.220 --> 00:13:22.660
It's short presentation.

00:13:22.850 --> 00:13:27.060
And then it's just like immediately into questions, feedback, all of that.

00:13:27.180 --> 00:13:28.260
So it mirrors it.

00:13:29.639 --> 00:13:33.360
This portion of Talk Python To Me is brought to you by Sentry's Seer.

00:13:34.080 --> 00:13:36.860
I'm excited to share a new tool from Sentry, Seer.

00:13:37.380 --> 00:13:43.000
Seer is your AI-driven pair programmer that finds, diagnoses, and fixes code issues in

00:13:43.000 --> 00:13:44.700
your Python app faster than ever.

00:13:45.200 --> 00:13:48.920
If you're already using Sentry, you are already using Sentry, right?

00:13:49.460 --> 00:13:53.700
Then using Seer is as simple as enabling a feature on your already existing project.

00:13:54.480 --> 00:13:57.820
Seer taps into all the rich context Sentry has about an error.

00:13:58.280 --> 00:14:02.380
stack traces, logs, commit history, performance data, essentially everything.

00:14:02.960 --> 00:14:07.240
Then it employs its agentic AI code capabilities to figure out what is wrong.

00:14:07.720 --> 00:14:11.500
It's like having a senior developer pair programming with you on bug fixes.

00:14:12.280 --> 00:14:17.660
Seer then proposes a solution, generating a patch for your code and even opening a GitHub pull request.

00:14:18.160 --> 00:14:22.780
This leaves the developers in charge because it's up to them to actually approve the PR.

00:14:23.200 --> 00:14:27.020
But it can reduce the time from error detection to fix dramatically.

00:14:27.760 --> 00:14:33.260
Developers who've tried it found it can fix errors in one shot that would have taken them hours to debug.

00:14:33.980 --> 00:14:38.380
SEER boasts a 94.5% accuracy in identifying root causes.

00:14:38.980 --> 00:14:45.620
SEER also prioritizes actionable issues with an actionability score, so you know what to fix first.

00:14:46.260 --> 00:14:53.240
This transforms sentry errors into actionable fixes, turning a pile of error reports into an ordered to-do list.

00:14:53.900 --> 00:14:58.620
If you could use an always-on-call AI agent to help track down errors and propose fixes

00:14:58.910 --> 00:15:02.960
before you even have time to read the notification, check out Sentry's Seer.

00:15:03.620 --> 00:15:07.620
Just visit talkpython.fm/Seer, S-E-E-R.

00:15:08.270 --> 00:15:10.080
The link is in your podcast player's show notes.

00:15:10.600 --> 00:15:12.920
Be sure to use our code, TALKPYTHON.

00:15:13.280 --> 00:15:14.160
One word, all caps.

00:15:14.840 --> 00:15:16.900
Thank you to Sentry for supporting Talk Pythonemy.

00:15:18.000 --> 00:15:22.419
So the first one, let me, I didn't always write down the names here, is the first one

00:15:22.440 --> 00:15:26.540
is how can we make breaking changes less painful by Itmar Oren?

00:15:27.040 --> 00:15:33.260
And so this one, Itmar deploys a bunch of Python code for production at meta

00:15:33.780 --> 00:15:39.740
and said, going from version 3.11 to 3.12 or 3.12 to 3.13

00:15:41.040 --> 00:15:43.480
has breaking changes that can be challenging.

00:15:43.960 --> 00:15:47.620
I don't encounter too many breaking changes in upgrading Python versions,

00:15:48.120 --> 00:15:53.120
but I also don't have literally millions of lines of code doing intricate things either so

00:15:53.500 --> 00:15:56.840
right this is a pretty pretty edge case but also an important one right yeah this so this talk I

00:15:56.840 --> 00:15:59.460
right this is a pretty pretty edge case but also an important one right yeah this so this talk I

00:15:59.600 --> 00:16:04.360
think one of the big things about this talk too is it wasn't just about like oh jumping from one

00:16:04.580 --> 00:16:10.120
version to one version a lot of companies employ like a skip version upgrading style where they'll

00:16:10.200 --> 00:16:14.819
experience breaking changes in a slightly different way than a lot of other users where they're jumping

00:16:14.840 --> 00:16:18.140
from like 3.11 to 3.13, as opposed to like 3.11 to 3.12 to 3.13, because upgrading is obviously

00:16:18.140 --> 00:16:19.000
from like 3.11 to 3.13, as opposed to like 3.11 to 3.12 to 3.13, because upgrading is obviously

00:16:19.000 --> 00:16:22.320
from like 3.11 to 3.13, as opposed to like 3.11 to 3.12 to 3.13, because upgrading is obviously

00:16:22.600 --> 00:16:26.840
this like big task. And so they don't want to do it every year. Maybe they do want to do it every

00:16:26.910 --> 00:16:31.280
two years and that's fine for them unless there's some feature that they really need or something

00:16:31.400 --> 00:16:36.460
like that. But yeah, so like anytime that you're upgrading more than one tython version, like it

00:16:36.540 --> 00:16:40.480
just, the breaking changes are obviously twice as, twice as many on average. Yeah. Sometimes they

00:16:41.040 --> 00:16:41.479
just, the breaking changes are obviously twice as, twice as many on average. Yeah. Sometimes they

00:16:41.500 --> 00:16:43.060
even go from 2.7 to 3.11. Yes and on rare occasions they go from 2.7 to 3.11 yeah thankfully that

00:16:43.060 --> 00:16:50.420
even go from 2.7 to 3.11. Yes and on rare occasions they go from 2.7 to 3.11 yeah thankfully that

00:16:50.640 --> 00:16:54.780
happens less and less yeah that's a story from uh the last decade thankfully yeah so this

00:16:54.780 --> 00:16:57.680
happens less and less yeah that's a story from uh the last decade thankfully yeah so this

00:16:57.680 --> 00:16:58.740
was like talking about like okay how we we're not trying to say breaking changes shouldn't happen

00:16:58.740 --> 00:17:03.120
was like talking about like okay how we we're not trying to say breaking changes shouldn't happen

00:17:03.400 --> 00:17:07.460
because we know that they're important and they're a good way to unblock things and remove pieces of

00:17:07.459 --> 00:17:14.520
software that we don't want users using, but trying to make it so that we can almost like quantify

00:17:15.380 --> 00:17:21.660
how bad a breaking change will be for users. And then based on that quantization, figure out what

00:17:21.689 --> 00:17:26.120
we need to do, maybe extra if it's like a particularly bad breaking change, or if it's

00:17:26.120 --> 00:17:30.340
just like, Oh, well, this has been deprecated for five years, and then removing it, or like,

00:17:30.460 --> 00:17:35.079
there's an easy drop in replacement, that's one to one, those sorts of breaking changes are really

00:17:35.100 --> 00:17:40.680
easy versus things like, oh, this behavior changed and you won't know until runtime and

00:17:40.900 --> 00:17:42.460
things like that are way more difficult.

00:17:42.580 --> 00:17:47.400
You have to have like a test harness that's actually testing all of the possibilities in

00:17:47.400 --> 00:17:52.940
the code to know whether you're safe or not versus like a syntactical control F find the

00:17:53.380 --> 00:17:54.760
bad function and then replace it.

00:17:54.860 --> 00:17:54.960
Yeah, it could be super subtle, right?

00:17:55.320 --> 00:17:57.140
Yeah, it could be super subtle, right?

00:17:57.140 --> 00:18:05.060
It could be the runtime things, but it could also be the memory structure of something we

00:18:05.080 --> 00:18:11.560
to a redis cache via pickling has changed and that's the that the cache version no longer works

00:18:11.760 --> 00:18:17.140
and we have to somehow figure out how to completely delete the cache and start over and some web apps

00:18:17.580 --> 00:18:18.120
that's a problem right when they're under tons of traffic that sort of cold start experience can be

00:18:18.120 --> 00:18:18.580
that's a problem right when they're under tons of traffic that sort of cold start experience can be

00:18:18.580 --> 00:18:19.000
that's a problem right when they're under tons of traffic that sort of cold start experience can be

00:18:19.000 --> 00:18:22.680
that's a problem right when they're under tons of traffic that sort of cold start experience can be

00:18:22.680 --> 00:18:23.560
a problem yeah and there's there's even things that like aren't even part of this gets mentioned

00:18:23.560 --> 00:18:28.120
a problem yeah and there's there's even things that like aren't even part of this gets mentioned

00:18:28.180 --> 00:18:33.620
in a future talk about parallelism where it's not even a function of the language but it just happens

00:18:33.640 --> 00:18:38.020
to be a property of how a particular set of code executes in one version versus another.

00:18:38.410 --> 00:18:40.240
So like with the, from the difference between 3.9 and 3.10, where something is thread safe,

00:18:40.240 --> 00:18:41.140
So like with the, from the difference between 3.9 and 3.10, where something is thread safe,

00:18:41.140 --> 00:18:44.420
So like with the, from the difference between 3.9 and 3.10, where something is thread safe,

00:18:44.840 --> 00:18:47.800
that it doesn't look thread safe at all. Like if you look at the code, you're like, oh, that's not

00:18:47.870 --> 00:18:52.300
thread safe. But the GIL based, like the implementation of the GIL in 3.9 keeps it thread

00:18:52.520 --> 00:18:56.980
safe. But in 3.10 and beyond, it's no longer thread safe. But the thing is, is you were relying

00:18:57.050 --> 00:18:59.020
on behavior that's not defined in Python. It wasn't guaranteed. Yeah, there's no guarantee that.

00:18:59.020 --> 00:19:02.200
on behavior that's not defined in Python. It wasn't guaranteed. Yeah, there's no guarantee that.

00:19:03.500 --> 00:19:04.220
And so it's like, is that a breaking change?

00:19:04.220 --> 00:19:04.940
And so it's like, is that a breaking change?

00:19:05.530 --> 00:19:07.500
No, but also like it'll probably break somebody.

00:19:07.670 --> 00:19:10.540
And also how do you detect that at a syntax level?

00:19:10.610 --> 00:19:12.000
You can't, the syntax is the same.

00:19:12.380 --> 00:19:13.720
Should it be written down as a breaking change?

00:19:13.950 --> 00:19:14.280
I don't know.

00:19:14.460 --> 00:19:17.980
Maybe does it, does your code feel broken if it gives you different answers

00:19:18.260 --> 00:19:19.720
and those answers start becoming wrong?

00:19:20.000 --> 00:19:20.520
Maybe.

00:19:20.980 --> 00:19:21.740
Yeah, it's tough.

00:19:21.960 --> 00:19:22.060
It's a really tough thing.

00:19:22.060 --> 00:19:22.780
It's a really tough thing.

00:19:23.280 --> 00:19:27.500
I think core developers were like pretty happy with the idea of like

00:19:28.000 --> 00:19:30.160
treating different breaking changes differently, trying to develop some

00:19:30.210 --> 00:19:32.060
sort of taxonomy of breaking changes.

00:19:32.260 --> 00:19:42.040
And there were some interesting ideas with like running these like code update scripts, providing code update scripts that if you have code and there's breaking changes that are on the syntax level, being able to upgrade them.

00:19:42.960 --> 00:19:47.140
Apparently, Ruff had some ability to do this for two major versions of NumPy.

00:19:47.860 --> 00:19:50.160
And so like that got brought up as an example of like, oh, this worked really well for NumPy.

00:19:50.240 --> 00:19:51.000
And so like that got brought up as an example of like, oh, this worked really well for NumPy.

00:19:51.000 --> 00:19:51.900
And so like that got brought up as an example of like, oh, this worked really well for NumPy.

00:19:51.950 --> 00:19:53.040
So maybe Python?

00:19:53.540 --> 00:19:54.060
Yeah, absolutely.

00:19:54.400 --> 00:19:54.860
Well, I was.

00:19:55.780 --> 00:19:56.220
Yeah, absolutely.

00:19:56.500 --> 00:19:59.840
I think Ruff is certainly in a good position to do that.

00:20:00.140 --> 00:20:00.240
Yeah.

00:20:00.900 --> 00:20:06.580
You could say, this pattern isn't wrong, but maybe it should come up with a warning, just so you know.

00:20:06.960 --> 00:20:09.100
We can run this check if you really want to see, right?

00:20:09.340 --> 00:20:11.880
Yeah, so one of the things Edmar pointed out was,

00:20:12.260 --> 00:20:16.280
it's difficult to find the documentation of deprecated and removed modules,

00:20:16.680 --> 00:20:20.520
because after a module is removed, the documentation is also removed.

00:20:20.720 --> 00:20:22.940
It's like, it's a bit of a catch-22.

00:20:23.480 --> 00:20:28.540
Yeah, that one was really interesting, because, yeah, like, especially if you're skipping versions, too.

00:20:28.680 --> 00:20:35.820
Like you go to the docs and the module is just gone and you're kind of left to figure

00:20:35.960 --> 00:20:37.940
out what was the last version that had that module.

00:20:38.320 --> 00:20:39.760
When did the deprecation warning start?

00:20:39.960 --> 00:20:40.460
Where's the warning?

00:20:40.660 --> 00:20:42.600
Like where is the actual documentation that says what to do?

00:20:42.600 --> 00:20:43.360
Like where is the actual documentation that says what to do?

00:20:44.300 --> 00:20:48.080
And so, yeah, apparently the docs editorial team are working on that.

00:20:48.300 --> 00:20:50.680
They're trying to figure out a solution for better documentation for removed modules specifically

00:20:50.680 --> 00:20:53.240
They're trying to figure out a solution for better documentation for removed modules specifically

00:20:53.690 --> 00:20:54.160
or removed.

00:20:54.280 --> 00:20:54.400
Yeah.

00:20:55.020 --> 00:20:55.100
Yeah.

00:20:55.460 --> 00:20:56.940
Carol Willing said they were working on that.

00:20:57.130 --> 00:20:57.560
Very interesting.

00:20:58.640 --> 00:21:01.920
You can go to the documentation, like docs.python.org, and pick through it.

00:21:02.020 --> 00:21:02.820
You can go to the documentation, like docs.python.org, and pick through it.

00:21:02.820 --> 00:21:03.420
You can go to the documentation, like docs.python.org, and pick through it.

00:21:03.480 --> 00:21:05.420
But by default, it lands on the latest, right?

00:21:05.800 --> 00:21:05.860
Yep.

00:21:06.140 --> 00:21:07.120
By default, it lands on the latest.

00:21:07.220 --> 00:21:13.440
And if there are any links to modules or to deprecation links that aren't pinning to a specific version,

00:21:14.240 --> 00:21:16.720
it'll go to the latest and be like, oh, we don't have those docs anymore.

00:21:17.020 --> 00:21:17.060
Yeah.

00:21:17.280 --> 00:21:17.440
It's just 404.

00:21:17.440 --> 00:21:17.920
It's just 404.

00:21:18.120 --> 00:21:18.960
You're like, huh, weird.

00:21:19.320 --> 00:21:19.480
Yeah.

00:21:19.680 --> 00:21:20.040
Weird, weird.

00:21:20.400 --> 00:21:20.560
Okay.

00:21:21.020 --> 00:21:22.120
Well, very, very interesting.

00:21:22.480 --> 00:21:26.100
The next one, we have an uncontentious talk about contention.

00:21:26.340 --> 00:21:33.480
And now we start into the heart of the topics, which is threading, async, IO, parallelism,

00:21:33.780 --> 00:21:35.460
concurrency, all these things, right?

00:21:35.640 --> 00:21:40.260
And this is the one you were referencing when you ask, is this code thread safe?

00:21:40.260 --> 00:21:41.800
So just give people a sense.

00:21:41.880 --> 00:21:45.500
There's an incredibly simple parallel example of create a counter class.

00:21:45.690 --> 00:21:46.580
The counter has a value.

00:21:46.910 --> 00:21:52.260
You can run some code that goes for 100,000 times, increment the value, start 10 threads

00:21:52.390 --> 00:21:54.180
at all, jam on that.

00:21:54.540 --> 00:21:56.080
And then this is by Mark Shannon.

00:21:56.100 --> 00:21:59.700
He says, we would like this to print exactly 1 million.

00:22:00.140 --> 00:22:01.780
I'm not sure that that's necessarily true.

00:22:02.080 --> 00:22:04.520
You would, as a creator of this program,

00:22:04.660 --> 00:22:06.180
you wanted to exactly print a million,

00:22:06.280 --> 00:22:08.360
but there might be advantages

00:22:09.480 --> 00:22:12.740
to allowing code to run more parallel

00:22:12.980 --> 00:22:13.900
rather than less parallel.

00:22:14.260 --> 00:22:16.800
And say it's on the author of that code

00:22:17.060 --> 00:22:17.920
to make it thread safe.

00:22:18.260 --> 00:22:18.420
Yeah.

00:22:19.020 --> 00:22:19.500
If it's five times faster

00:22:19.500 --> 00:22:20.840
If it's five times faster

00:22:21.380 --> 00:22:23.860
because Python, the runtime doesn't make it thread safe.

00:22:24.240 --> 00:22:27.240
maybe you choose the time and the way that you run that code.

00:22:27.360 --> 00:22:27.980
That's all I'm getting at.

00:22:28.020 --> 00:22:32.020
Like we would like it to print exactly a million times as a correctness,

00:22:32.720 --> 00:22:34.260
but maybe it's not Python's job.

00:22:34.640 --> 00:22:40.320
No, I think maybe that comment is like not necessarily like we core developers

00:22:40.620 --> 00:22:42.640
should want this program to print exactly one million.

00:22:42.740 --> 00:22:45.700
I think it's more of like, oh, if you were someone who's writing this code,

00:22:46.020 --> 00:22:48.100
you would maybe expect it to print a million because they're like, oh,

00:22:48.200 --> 00:22:48.320
you would maybe expect it to print a million because they're like, oh,

00:22:48.760 --> 00:22:50.860
in three nine and before it prints a million.

00:22:51.000 --> 00:22:51.600
So like, that's fine.

00:22:52.600 --> 00:22:52.960
But then...

00:22:52.960 --> 00:22:53.300
But then...

00:22:53.300 --> 00:22:54.580
Yeah, so you know what changed in the GIL?

00:22:54.580 --> 00:22:55.100
Yeah, so you know what changed in the GIL?

00:22:55.320 --> 00:22:58.180
I actually don't know specifically what changed in the GIL.

00:22:59.220 --> 00:23:01.940
It was something to do with context switching in the GIL.

00:23:02.420 --> 00:23:04.240
Made this no longer change.

00:23:04.320 --> 00:23:04.980
My guess is that it's performance, like you said.

00:23:04.980 --> 00:23:05.420
My guess is that it's performance, like you said.

00:23:05.420 --> 00:23:06.620
My guess is that it's performance, like you said.

00:23:07.060 --> 00:23:07.360
Yeah, exactly.

00:23:07.960 --> 00:23:08.060
Exactly.

00:23:08.280 --> 00:23:10.860
They probably said we can make the GIL more fine-grained

00:23:10.880 --> 00:23:15.660
and get more perceived cooperative or primitive multithreading as it goes.

00:23:15.660 --> 00:23:16.360
and get more perceived cooperative or primitive multithreading as it goes.

00:23:16.360 --> 00:23:16.560
and get more perceived cooperative or primitive multithreading as it goes.

00:23:16.740 --> 00:23:17.400
Something like that, right?

00:23:17.640 --> 00:23:17.900
Exactly.

00:23:18.220 --> 00:23:19.820
Yeah, and that's kind of what I was hinting at there.

00:23:20.880 --> 00:23:24.160
Okay, so that's the story.

00:23:25.020 --> 00:23:26.680
And basically, Mark said,

00:23:26.910 --> 00:23:28.820
thread safety is a property of the program,

00:23:29.380 --> 00:23:31.460
the Python code you write, or someone's written,

00:23:31.800 --> 00:23:33.860
in the implementation of CPython

00:23:34.170 --> 00:23:36.440
and how it behaves, in this case, the GIL, right?

00:23:36.720 --> 00:23:39.200
Yeah, so Mark was, I think the big thing for Mark's talk

00:23:39.200 --> 00:23:39.800
Yeah, so Mark was, I think the big thing for Mark's talk

00:23:39.920 --> 00:23:41.800
was this synchronization quadrant,

00:23:42.140 --> 00:23:45.900
where he is basically trying to make some bets

00:23:46.160 --> 00:23:47.780
about what's going to happen next

00:23:47.960 --> 00:23:49.659
to try to solve some of the problems

00:23:49.680 --> 00:23:52.880
that we're going to start seeing or parallel Python, right?

00:23:53.070 --> 00:23:56.940
And that's either anytime that you have both mutability

00:23:57.500 --> 00:24:01.660
and shared references, you have problems with synchronization.

00:24:02.140 --> 00:24:06.740
And if you introduce more immutability or less sharing,

00:24:07.280 --> 00:24:09.180
then you're starting to solve these problems.

00:24:10.480 --> 00:24:12.140
But the unfortunate thing is that there's a lot of Python

00:24:12.190 --> 00:24:15.300
that happens in the shared and mutable section.

00:24:15.880 --> 00:24:20.440
And we don't want to have to like ask everyone to rewrite all their Python programs.

00:24:21.140 --> 00:24:24.180
So it's definitely like a tough like quantization problem.

00:24:24.380 --> 00:24:28.080
Like how how big of an issue would making changes like this be?

00:24:28.400 --> 00:24:35.340
But then also like we don't even really today give people a ton of the tools that they would need to be able to work with like immutable data structures.

00:24:36.360 --> 00:24:39.100
Because like we have frozen set and we have tuples frozen list, frozen dictionary, any of that.

00:24:39.100 --> 00:24:41.020
Because like we have frozen set and we have tuples frozen list, frozen dictionary, any of that.

00:24:41.520 --> 00:24:43.200
Because like we have frozen set and we have tuples frozen list, frozen dictionary, any of that.

00:24:44.280 --> 00:24:46.680
And so, yeah, Mark just basically gave a whole bunch of things

00:24:46.740 --> 00:24:48.820
where it's like, here's all of these ideas that I have

00:24:48.960 --> 00:24:52.960
for making this more easy, having more immutability.

00:24:54.020 --> 00:24:56.580
And we should probably start thinking about that now

00:24:56.980 --> 00:24:58.880
because we're starting to get into free threading time.

00:24:59.440 --> 00:25:03.820
Yeah, certainly a threading collections sort of deal would be great.

00:25:04.160 --> 00:25:05.440
Yeah, I think the final thing there was like,

00:25:05.440 --> 00:25:07.080
Yeah, I think the final thing there was like,

00:25:07.320 --> 00:25:09.660
oh, we should definitely be doing this on PyPI.

00:25:09.900 --> 00:25:12.479
And I think the free threading team is planning on creating

00:25:12.500 --> 00:25:17.280
some immutable data structures and putting them on PyPI at first before migrating them.

00:25:17.280 --> 00:25:18.620
Oh yeah, that's an interesting idea.

00:25:18.730 --> 00:25:23.700
Like take them for a test run before people, before they get baked into a pattern, right?

00:25:23.960 --> 00:25:24.160
Exactly.

00:25:24.740 --> 00:25:28.760
You know, one of the things that I think is a danger of those types of data structures

00:25:29.070 --> 00:25:31.820
and they, don't get me wrong, they're useful and they're good.

00:25:32.100 --> 00:25:37.460
But one of the dangers is they can give people a false sense of security, right?

00:25:37.600 --> 00:25:44.340
If you have four or five lines of code that is changing state, you know, check to see something that is in the list.

00:25:44.730 --> 00:25:47.620
And then in the next line, remove something from the list.

00:25:48.380 --> 00:25:52.300
Even if that list itself is thread safe, if it's immutable, that's one thing.

00:25:52.440 --> 00:26:01.380
But if it's a mutable list that you're trying to make a thread safe version of, it's still possible that the check was thread safe and the remove was thread safe.

00:26:01.600 --> 00:26:05.300
But something happened between those two where the thing's no longer in the list, right?

00:26:05.660 --> 00:26:09.560
It gives people this sense of, well, I've got a thread safe collection, so I'm good to go.

00:26:09.700 --> 00:26:11.980
It's like on a line by line basis, that's true.

00:26:12.030 --> 00:26:14.000
But as a block of code, it's still not true.

00:26:14.090 --> 00:26:16.080
And you still have to think more about these things.

00:26:16.540 --> 00:26:17.580
That doesn't mean you shouldn't have them.

00:26:17.900 --> 00:26:20.540
But it is like an awareness sort of thing.

00:26:20.760 --> 00:26:22.380
Because I'm doing thread safe.

00:26:22.470 --> 00:26:26.320
Look, from system.threading.collections, import, whatever.

00:26:26.620 --> 00:26:27.100
We're good to go.

00:26:27.770 --> 00:26:28.140
Like, better.

00:26:29.320 --> 00:26:29.860
Yeah, yeah.

00:26:29.930 --> 00:26:31.420
You actually have to use the data structures.

00:26:31.570 --> 00:26:31.960
You can't.

00:26:32.110 --> 00:26:33.420
You have to use the immutable ones.

00:26:33.560 --> 00:26:35.320
Don't use the mutable ones and expect.

00:26:35.680 --> 00:26:35.880
Yeah.

00:26:36.060 --> 00:26:36.640
So it's, but it is certainly in the right way.

00:26:36.960 --> 00:26:38.580
So it's, but it is certainly in the right way.

00:26:38.860 --> 00:26:43.940
There was some, there's some pretty extreme in terms of how much they would change programming

00:26:44.640 --> 00:26:46.760
paradigms and ideas, suggestions here.

00:26:46.760 --> 00:26:50.160
And I don't remember if they, how these are starting to blend together these different

00:26:50.420 --> 00:26:56.920
topics, but yeah, like one of, one of the challenges is that functions and types are

00:26:57.080 --> 00:26:58.540
mutable, right?

00:26:58.740 --> 00:27:02.300
And that makes it hard, even at a CPython implementation,

00:27:02.760 --> 00:27:05.600
runtime level of dealing with some of these things.

00:27:06.080 --> 00:27:11.040
But changing them breaks the style of Python somewhat.

00:27:11.740 --> 00:27:12.180
That's a trade-off, right?

00:27:12.180 --> 00:27:12.700
That's a trade-off, right?

00:27:12.900 --> 00:27:14.180
It's a huge trade-off, yeah.

00:27:14.400 --> 00:27:16.260
And the fact that everything is mutable

00:27:16.700 --> 00:27:18.340
and a lot of things are shared,

00:27:18.520 --> 00:27:19.280
like the standard library,

00:27:19.280 --> 00:27:21.860
the whole standard library is shared across everything.

00:27:22.540 --> 00:27:25.120
It's really difficult to say that, oh yeah,

00:27:25.580 --> 00:27:28.500
if you're in that top right quadrant of shared and mutable,

00:27:28.860 --> 00:27:34.820
which way does like the standard library move like you can't uh uh you can't make everything

00:27:35.480 --> 00:27:40.800
immutable and you can't make everything not shared so it's what do you do yeah for sure and it's also

00:27:40.800 --> 00:27:41.400
immutable and you can't make everything not shared so it's what do you do yeah for sure and it's also

00:27:41.420 --> 00:27:46.540
a performance issue that you could because you know like right here mark points out that

00:27:47.360 --> 00:27:52.580
where mutability is lots of day uh maybe it is there but not for a good reason like functions

00:27:52.780 --> 00:27:56.820
and class method resolution order, all that stuff.

00:27:56.980 --> 00:27:58.400
It's mutable, but should it be?

00:27:58.640 --> 00:28:00.800
The thing is, if it's going to remain mutable,

00:28:01.180 --> 00:28:04.020
you probably have to do locks and stuff down in CPython,

00:28:04.420 --> 00:28:05.260
which will slow it down.

00:28:05.540 --> 00:28:07.260
If it were immutable, you don't have to lock it.

00:28:07.360 --> 00:28:09.640
You can read from multiple threads all day long

00:28:09.740 --> 00:28:10.700
and it's not going to hurt anything.

00:28:11.160 --> 00:28:13.540
So it's actually a performance consideration,

00:28:13.840 --> 00:28:15.440
not just a flexibility, right?

00:28:15.460 --> 00:28:17.740
If you say, we really value this multi-threading

00:28:18.160 --> 00:28:20.700
and we wanted to operate as quick as regular Python,

00:28:21.000 --> 00:28:21.780
but scale really well,

00:28:22.040 --> 00:28:26.900
these are trade-offs you got to consider, but then we all have like scars from two to three.

00:28:27.740 --> 00:28:29.360
And this could be a little like that. Yeah. Yeah. I think it's going to, it's going to

00:28:29.700 --> 00:28:31.620
And this could be a little like that. Yeah. Yeah. I think it's going to, it's going to

00:28:32.680 --> 00:28:37.520
matter. And I think that like companies are going to have to maybe start even like profiling their

00:28:37.540 --> 00:28:42.500
own code and trying to see where they're hitting those, like those like stop or stop the world

00:28:42.640 --> 00:28:47.280
locks or any sort of like performance issue, like, and trying to like track down where in their code

00:28:47.300 --> 00:28:52.800
we're hitting those like really expensive operations. And if they're trying to write

00:28:52.800 --> 00:28:59.400
this like extremely high parallel code, having having a way to profile it would be sounds really

00:28:59.500 --> 00:29:04.300
like a good idea, because I think that there's like going to be once this starts happening,

00:29:04.520 --> 00:29:08.660
people are going to have to start thinking about like CPython the runtime. What are the expensive

00:29:09.060 --> 00:29:14.320
operations that are happening in my own code that maybe could be done differently to take

00:29:14.340 --> 00:29:15.640
advantage of free threading completely. Yeah. Well, and going back to the opening part with like

00:29:16.000 --> 00:29:19.040
advantage of free threading completely. Yeah. Well, and going back to the opening part with like

00:29:19.220 --> 00:29:24.200
the red safe collections and so on, it's really difficult for us as Python devs to create those

00:29:24.640 --> 00:29:29.400
because we could write that in Python, but that makes it fairly slow. You need that down at the

00:29:29.660 --> 00:29:35.480
machine level, right? Like probably CPython. We'll see if it's CPython or RPython or whatever,

00:29:35.620 --> 00:29:36.420
as we go through this series of talks. But at the time of speaking, recording, it's CPython,

00:29:36.420 --> 00:29:37.240
as we go through this series of talks. But at the time of speaking, recording, it's CPython,

00:29:37.240 --> 00:29:41.780
as we go through this series of talks. But at the time of speaking, recording, it's CPython,

00:29:41.940 --> 00:29:47.600
right? It would be way faster if there was a in the standard library C implementation of a thread

00:29:47.700 --> 00:29:53.940
safe thing that's not being coordinated by a bunch of calls from the Python level. Okay. I guess

00:29:54.360 --> 00:29:59.740
closing this one out, Mark suggested adding a freezing method to data structures like byte arrays.

00:29:59.900 --> 00:30:03.560
That's kind of what we were talking about. And Barry Warsaw said that he'd brought up a proposal,

00:30:04.140 --> 00:30:11.160
a PEP that was a freeze protocol that was rejected 20 years ago.

00:30:12.160 --> 00:30:13.060
Those were different times.

00:30:13.660 --> 00:30:14.700
Those were different times, right?

00:30:14.800 --> 00:30:16.000
How many cores do we have?

00:30:16.360 --> 00:30:17.280
Or was it like a dual?

00:30:18.000 --> 00:30:18.500
Single digit still.

00:30:18.500 --> 00:30:18.840
Single digit still.

00:30:19.060 --> 00:30:23.920
Yeah, certainly a single dual, maybe a quad core if you were awesome back then.

00:30:24.220 --> 00:30:25.020
That's not the case anymore.

00:30:25.200 --> 00:30:28.560
So the benefit of having something like this is certainly higher.

00:30:28.760 --> 00:30:29.920
So I was like, why was that rejected again?

00:30:29.920 --> 00:30:30.760
So I was like, why was that rejected again?

00:30:31.060 --> 00:30:31.680
We don't know.

00:30:32.140 --> 00:30:32.260
Yeah.

00:30:32.640 --> 00:30:38.760
Freezing comes up yet again in another one of the talks about a fearless concurrency as well.

00:30:39.900 --> 00:30:43.100
So I think that something like that is probably going to get resurrected,

00:30:43.300 --> 00:30:45.280
at least tried to be done again.

00:30:47.200 --> 00:30:51.240
This portion of Talk Python To Me is brought to you by Sentry's AI agent monitoring.

00:30:52.040 --> 00:30:55.220
Are you building AI capabilities into your Python applications?

00:30:55.960 --> 00:30:59.280
Whether you're using OpenAI, local LLMs, or something else,

00:30:59.540 --> 00:31:05.140
visibility into your AI agent's behavior, performance, and cost is critical. You will

00:31:05.230 --> 00:31:11.780
definitely want to give Sentry's brand new AI agent monitoring a look. AI agent monitoring gives you

00:31:12.280 --> 00:31:18.300
transparent observability into every step of your AI features so you can debug, optimize, and control

00:31:18.300 --> 00:31:23.920
the cost with confidence. You'll get full observability into every step of your AI agent.

00:31:24.140 --> 00:31:28.940
That is model calls, prompts, external tool usage, and custom logic steps.

00:31:29.740 --> 00:31:36.260
AI agent monitoring captures every step of an AI agent's workflow from the user's input to the final response.

00:31:36.940 --> 00:31:43.500
And your app will have a dedicated AI agent's dashboard showing traces and timelines for each agent run.

00:31:44.100 --> 00:31:52.580
You'll get alerts on model errors, latency spikes, token usage surges, and API failures protecting both performance and cost.

00:31:53.000 --> 00:31:55.520
It's plug-and-play Python SDK integration.

00:31:56.180 --> 00:31:59.720
Open AI for now for Django, Flask, and FastAPI apps

00:32:00.000 --> 00:32:01.820
with more AI platforms coming soon.

00:32:02.420 --> 00:32:07.040
In summary, AI agent monitoring turns the often black-box behavior of AI

00:32:07.540 --> 00:32:10.980
in your app into transparent, debuggable processes.

00:32:11.740 --> 00:32:14.120
If you're adding AI capabilities to your Python app,

00:32:14.420 --> 00:32:16.700
give Sentry's AI agent monitoring the look.

00:32:17.180 --> 00:32:21.680
Just visit talkpython.fm/sentryagents to get started

00:32:21.700 --> 00:32:23.140
and be sure to use our code,

00:32:24.200 --> 00:32:25.700
TALKPYTHON, one word, all caps.

00:32:26.120 --> 00:32:28.100
The link is in your podcast player's show notes.

00:32:28.540 --> 00:32:29.780
Thank you to Sentry for supporting Talk Python and me.

00:32:29.780 --> 00:32:31.120
Thank you to Sentry for supporting Talk Python and me.

00:32:32.020 --> 00:32:33.360
I don't know if you wanted to jump to that one

00:32:33.580 --> 00:32:34.640
because I think that one and the uncontentious talk

00:32:34.640 --> 00:32:34.980
because I think that one and the uncontentious talk

00:32:34.980 --> 00:32:35.900
because I think that one and the uncontentious talk

00:32:36.010 --> 00:32:37.620
is quite, they're pretty related.

00:32:37.660 --> 00:32:37.840
We were talking fearless concurrency?

00:32:37.840 --> 00:32:38.960
We were talking fearless concurrency?

00:32:39.240 --> 00:32:39.500
Yes.

00:32:39.880 --> 00:32:41.200
Yeah, let's talk that one.

00:32:41.210 --> 00:32:42.860
So that's by Matthew Parkinson,

00:32:43.140 --> 00:32:46.940
Tobias Rigstad and Rudolf Stoltz.

00:32:47.220 --> 00:32:49.100
Hopefully I did a justice to your name, folks.

00:32:50.560 --> 00:32:51.600
Yeah, so fearless concurrency.

00:32:51.680 --> 00:32:54.400
This was one of the more detailed ones.

00:32:54.500 --> 00:32:57.880
And so this one, I don't know how I feel about this one, Seth.

00:32:59.980 --> 00:33:02.880
This is one of those things where it's like,

00:33:03.000 --> 00:33:06.980
if we take this really wild idea that really changes the way people have

00:33:07.180 --> 00:33:09.300
traditionally done programming for concurrency,

00:33:09.640 --> 00:33:10.660
then we could get great benefits.

00:33:11.440 --> 00:33:15.200
But it also is like, I don't know what your assessment is.

00:33:15.440 --> 00:33:32.260
My sense is that most Python people don't think a lot about threading, haven't done much threading, and their skills of threading, problem solving, using fairly straightforward things like locks is still pretty much like, I think they have those in the language.

00:33:32.640 --> 00:33:33.040
You know what I mean?

00:33:33.140 --> 00:33:34.740
Like, not really like, yeah, oh yeah, yeah.

00:33:35.360 --> 00:33:39.740
I use event signals and all sorts of like producer consumers, like not very much of that.

00:33:39.900 --> 00:33:40.360
You know what I mean?

00:33:41.260 --> 00:33:46.140
And so anyway, tell us what this is about because it's an interesting concept.

00:33:46.800 --> 00:33:46.880
Yeah.

00:33:47.050 --> 00:33:47.200
So.

00:33:47.580 --> 00:33:47.980
Debate it.

00:33:48.300 --> 00:33:48.560
Yeah.

00:33:48.660 --> 00:33:54.280
This concept is all about, so like the central concept is regions and regions are essentially

00:33:55.000 --> 00:34:01.320
in Rust, they have this model where a mutable reference is only allowed to be like a mutable

00:34:01.430 --> 00:34:03.240
object is only allowed to be referenced once, right?

00:34:03.390 --> 00:34:04.840
Like that's the ownership model in Rust, but that's like not compatible with how Python

00:34:04.840 --> 00:34:05.340
Like that's the ownership model in Rust, but that's like not compatible with how Python

00:34:05.770 --> 00:34:08.039
Like that's the ownership model in Rust, but that's like not compatible with how Python

00:34:08.340 --> 00:34:14.360
programs are in general. Yeah, because we love our mutability. And so this is essentially like,

00:34:14.679 --> 00:34:20.500
okay, well, what if we could have kind of like a looser version of that, where you have objects

00:34:20.590 --> 00:34:26.460
that are doing mutability and all of that within a region, but then anything outside the region

00:34:27.000 --> 00:34:32.419
can't mess with it. And then if you have that situation, which is more common and more like

00:34:32.520 --> 00:34:37.679
understandable for like a Python programmer, then you can get a bunch of performance benefits,

00:34:37.820 --> 00:34:40.700
because you know that nothing outside of the region

00:34:40.760 --> 00:34:44.179
is going to be doing any sort of like that special mutability.

00:34:44.500 --> 00:34:46.260
Just out of nowhere, we're going to change something

00:34:46.480 --> 00:34:47.919
about your function signature or something.

00:34:49.080 --> 00:34:50.899
And so then when you have this situation,

00:34:51.080 --> 00:34:53.360
you can even do, yeah, like so this diagram is showing

00:34:53.679 --> 00:34:58.680
all these references into that region from a specific thread.

00:34:59.000 --> 00:35:01.660
We know because of how the region is created

00:35:02.080 --> 00:35:04.440
that the other thread can't modify anything inside.

00:35:04.820 --> 00:35:06.579
And so you get a bunch of performance benefits

00:35:06.600 --> 00:35:09.380
for all of the operations that are happening inside that region.

00:35:09.700 --> 00:35:12.780
So I think that's kind of like the, that's like the elevated top.

00:35:13.220 --> 00:35:15.740
Regions are like Rust, but better for Python programmers.

00:35:15.740 --> 00:35:16.280
Regions are like Rust, but better for Python programmers.

00:35:16.720 --> 00:35:17.360
Yeah, yeah, sure.

00:35:17.700 --> 00:35:19.960
And if you want some other thread to have access to it,

00:35:20.260 --> 00:35:23.560
you've got to make all the things in that region and let go of it

00:35:23.760 --> 00:35:28.080
so that it can be transferred ownership over to the other thread and so on.

00:35:28.420 --> 00:35:30.780
Yeah, it's an interesting idea.

00:35:32.160 --> 00:35:34.220
Like I said, I feel like it's powerful,

00:35:34.440 --> 00:35:36.700
but I feel like it might be a bridge too far, you know?

00:35:36.760 --> 00:35:37.160
I don't know.

00:35:37.960 --> 00:35:41.320
Yeah, I think that, again, immutability came up here.

00:35:41.620 --> 00:35:45.040
They even had some talking about, like, being able to freeze regions.

00:35:45.560 --> 00:35:47.720
And so, like, you create a region of objects

00:35:47.880 --> 00:35:50.180
and then freeze the entire region of objects,

00:35:50.500 --> 00:35:53.040
and then none of those references can get modified.

00:35:53.280 --> 00:35:56.340
And so the whole freeze protocol discussion kicked off again.

00:35:57.260 --> 00:36:00.460
Yeah, so maybe something to look forward to for each protocol in Python.

00:36:01.680 --> 00:36:03.260
Yeah, the region-based ownership,

00:36:03.760 --> 00:36:31.900
It was definitely an interesting. I feel like, yeah, like, like you said, there's, there's a bunch of people that were asking questions about like, how much is the benefit? Yeah, it's, it's this different, like to, to take advantage of it, you would have to change your code slightly. So it's not just this like free thing that happens. It's more of like, okay, if you're like a library or project that really wants to take advantage of tons of parallelism, you would use these features. It wouldn't be just like, oh, every Python programmer, once they upgrade, they just get a bunch of free performance.

00:36:32.580 --> 00:36:38.220
No, no, of course not. Of course not. Yeah. I feel like there was some interesting questions,

00:36:38.760 --> 00:36:42.680
like interesting discussion, but for some reason I kind of, I left it out on my notes here, but

00:36:42.980 --> 00:36:43.400
let me see. There was, so one of the things is there's basically four PEPs proposed or at least

00:36:43.760 --> 00:36:47.920
let me see. There was, so one of the things is there's basically four PEPs proposed or at least

00:36:48.140 --> 00:36:53.700
imagined. I don't know if they're actually proposed yet that would make this, this happen, but maybe

00:36:53.780 --> 00:36:57.580
it's coming from a different section, but a different freezing conversation somewhere else.

00:36:57.720 --> 00:37:01.560
but there was the conversation like, okay, well, I've got a list.

00:37:01.980 --> 00:37:03.160
The list has a bunch of pointers.

00:37:03.880 --> 00:37:08.380
Some other thread got a hold of one of the items that's somewhere in the list,

00:37:08.820 --> 00:37:09.940
but I freeze the list.

00:37:10.280 --> 00:37:12.540
And so the list is frozen,

00:37:12.720 --> 00:37:19.980
but then you still have this object graph that has leaked some of the mutable data.

00:37:20.360 --> 00:37:22.960
So you could use that one pointer to one part in the array

00:37:23.140 --> 00:37:24.840
and you could be making changes to it.

00:37:24.860 --> 00:37:35.660
So there's like this discussion of object graphs as their whole becoming invalid or like they're becoming problems with like trying to share those that were not obvious, right?

00:37:35.840 --> 00:37:43.480
Like really subtle programming challenges, not a race condition, but kind of a syntactical structure behavior problem that you run into.

00:37:43.560 --> 00:37:46.840
And you can say, well, this section is frozen, but someone got a piece of it.

00:37:46.900 --> 00:37:47.960
So now what do you say about it?

00:37:47.960 --> 00:37:48.460
You know what I mean?

00:37:48.560 --> 00:38:01.820
Yeah, I think the idea with like freezing and regions and all that is it would definitely be tracking the number of references that are held by objects that are outside of the region.

00:38:02.200 --> 00:38:10.240
And so like if you would then try to like freeze an object or freeze that region, it would know that it's being referenced by something outside of a region.

00:38:10.280 --> 00:38:13.500
And it would raise an exception instead of like allowing that to happen.

00:38:13.640 --> 00:38:15.360
Because like right now it would just allow it to happen.

00:38:16.440 --> 00:38:20.920
Whereas like getting an exception that, hey, a race condition is possible in this situation.

00:38:21.420 --> 00:38:24.400
We're not going to let you freeze this object or freeze this region like that.

00:38:24.400 --> 00:38:29.060
I think that's like a better user experience because if you're using regions, you probably

00:38:29.400 --> 00:38:29.660
want these properties.

00:38:29.660 --> 00:38:30.680
want these properties.

00:38:32.170 --> 00:38:38.740
And that is a big benefit of that proposed idea that what would have been a runtime, either

00:38:39.400 --> 00:38:44.540
race condition or deadlock becomes an exception that tells you this would have been a problem,

00:38:44.670 --> 00:38:45.780
which that's massive.

00:38:46.140 --> 00:38:51.100
yeah so okay interesting my first impression is that it's too much it's too much for the python

00:38:51.320 --> 00:38:51.880
people yeah i'm sort of counting myself i'm not like just throwing shade like i'm sort of counting

00:38:51.880 --> 00:38:52.640
people yeah i'm sort of counting myself i'm not like just throwing shade like i'm sort of counting

00:38:52.640 --> 00:38:53.200
people yeah i'm sort of counting myself i'm not like just throwing shade like i'm sort of counting

00:38:53.200 --> 00:38:55.320
people yeah i'm sort of counting myself i'm not like just throwing shade like i'm sort of counting

00:38:55.460 --> 00:39:00.100
myself in the same group to some degree even though i've done a lot of like block event-based

00:39:00.540 --> 00:39:02.280
style threading still you know no it's it is interesting i think that it is a really good

00:39:02.280 --> 00:39:05.000
style threading still you know no it's it is interesting i think that it is a really good

00:39:05.220 --> 00:39:09.660
idea for them to break the project down into multiple peps instead of trying to like you know

00:39:09.840 --> 00:39:14.420
land this huge jet plane at the very end of the project instead just like try to incrementally

00:39:14.660 --> 00:39:19.920
because I think that it'll be interesting going into the future, seeing how many of these peps

00:39:20.360 --> 00:39:24.060
land, right? Like, will it be all of them? Or will it be one of them? You know, like,

00:39:24.260 --> 00:39:28.540
I think there are some interesting things in this project, even if we don't get the entire

00:39:29.060 --> 00:39:30.360
region based ownership model. Yeah, yeah. Yeah. Okay. Interesting. Jumping back one in time,

00:39:30.840 --> 00:39:35.060
region based ownership model. Yeah, yeah. Yeah. Okay. Interesting. Jumping back one in time,

00:39:35.520 --> 00:39:38.920
we've got number three of nine. So I'm feeling like we're gonna have to go faster.

00:39:39.500 --> 00:39:40.980
Yes, yes, we might have to. This one is really interesting. This was a long

00:39:41.940 --> 00:39:44.400
Yes, yes, we might have to. This one is really interesting. This was a long

00:39:44.400 --> 00:39:45.660
at least a long write-up.

00:39:45.930 --> 00:39:48.140
This is the state of free-threaded Python.

00:39:48.530 --> 00:39:50.020
And the question is,

00:39:50.410 --> 00:39:54.320
does it make sense to move to the next phase of PEP 703,

00:39:54.580 --> 00:39:56.440
which is, I believe that's the one that defined

00:39:56.630 --> 00:39:58.680
free-threaded Python by Sam.

00:39:59.020 --> 00:40:00.420
So this was done by,

00:40:00.520 --> 00:40:02.060
this presentation was done by Matt Page,

00:40:02.500 --> 00:40:05.280
saying free-threaded Python has come quite far.

00:40:06.040 --> 00:40:08.820
And I believe since actually this was done,

00:40:09.300 --> 00:40:11.440
this PEP has actually moved forward to say,

00:40:11.600 --> 00:40:13.220
yes, we are moving on, right?

00:40:13.260 --> 00:40:15.020
So this is a bit of the lag that you were talking.

00:40:15.020 --> 00:40:15.240
So this is a bit of the lag that you were talking.

00:40:15.400 --> 00:40:15.660
Yes.

00:40:16.060 --> 00:40:16.620
So I just,

00:40:16.840 --> 00:40:18.620
I shared a link with you also the,

00:40:19.160 --> 00:40:20.980
this just came through from the steering council.

00:40:22.060 --> 00:40:22.540
How long ago?

00:40:23.140 --> 00:40:24.740
A day ago from this recording.

00:40:25.160 --> 00:40:25.540
Oh yes.

00:40:25.900 --> 00:40:27.300
We bring you the fresh news folks.

00:40:27.680 --> 00:40:27.880
Yes.

00:40:29.120 --> 00:40:34.640
Where PEP 779 basically removed the experimental tag from the free threaded build.

00:40:34.940 --> 00:40:35.480
And yeah,

00:40:35.700 --> 00:40:39.780
I think that this presentation probably had a good chunk to do with that,

00:40:40.000 --> 00:40:41.280
where they showed off.

00:40:41.500 --> 00:40:42.300
Here's the state of everything.

00:40:42.640 --> 00:40:53.580
Here's our proof that the community is adopting it at the expected rate at this point in the project, especially like the scientific computing community where like the benefits of free threading are huge.

00:40:54.280 --> 00:40:55.680
We're seeing all this uptake.

00:40:55.910 --> 00:41:00.440
We're seeing within the bounds of the performance allowance for single threaded performance.

00:41:01.480 --> 00:41:06.660
Can we remove the experimental so that we can see this like next wave of adoption?

00:41:06.890 --> 00:41:08.820
That was basically the whole point of Matt's.

00:41:08.820 --> 00:41:10.000
And it seems like the answer is yes.

00:41:10.900 --> 00:41:11.380
It does seem like it's yes.

00:41:11.380 --> 00:41:11.940
It does seem like it's yes.

00:41:11.950 --> 00:41:12.080
Yeah.

00:41:12.420 --> 00:41:12.840
That's very cool.

00:41:13.580 --> 00:41:13.680
Yeah.

00:41:14.220 --> 00:41:15.620
It means yes for 3.14.

00:41:16.479 --> 00:41:18.000
So what was it, June?

00:41:18.340 --> 00:41:20.100
That means yes in like four or five months.

00:41:20.480 --> 00:41:20.560
Yep.

00:41:20.940 --> 00:41:22.920
Stay tuned in October where you get your stable.

00:41:23.030 --> 00:41:24.000
But please test your betas.

00:41:24.560 --> 00:41:26.480
Which, yeah, we're already in the beta, aren't we?

00:41:26.520 --> 00:41:27.660
Yeah, we're already in the beta phase.

00:41:28.000 --> 00:41:29.540
So test your betas, folks.

00:41:29.940 --> 00:41:33.260
So I guess it's worth pointing out just a little bit for folks who haven't been tracking this

00:41:33.450 --> 00:41:35.000
super closely, like you and I.

00:41:35.380 --> 00:41:42.120
This free-threaded Python's PEP 703 deal, I haven't seen anything like it, but I haven't.

00:41:42.260 --> 00:41:44.340
there might've been other stuff like this and I just didn't notice,

00:41:44.740 --> 00:41:46.040
but I'm all about the threading.

00:41:46.040 --> 00:41:49.480
So I've been paying more careful attention in that it was accepted,

00:41:49.980 --> 00:41:52.040
but conditionally marked as experimental.

00:41:52.280 --> 00:41:55.280
And with the caveat that we may take it away from Python later,

00:41:55.280 --> 00:41:56.220
if we don't like it anymore,

00:41:56.920 --> 00:41:59.100
which is an odd acceptance.

00:41:59.360 --> 00:41:59.760
I thought.

00:42:00.040 --> 00:42:00.200
Yeah.

00:42:00.360 --> 00:42:00.540
That,

00:42:00.680 --> 00:42:01.680
that mechanism of,

00:42:01.680 --> 00:42:03.540
I think it was just this,

00:42:04.000 --> 00:42:08.540
this knowledge that this project would last multiple steering councils and

00:42:08.680 --> 00:42:09.520
multiple years.

00:42:09.900 --> 00:42:15.900
And we were kind of going into the brave unknown a little bit and acknowledging that, that,

00:42:16.080 --> 00:42:18.380
hey, if it doesn't work out, we're going to have to pull it all out.

00:42:18.500 --> 00:42:20.900
And that is unfortunate, but it's just reality.

00:42:21.000 --> 00:42:21.320
We don't know what we're going to experience, what we're going to find.

00:42:21.320 --> 00:42:21.920
We don't know what we're going to experience, what we're going to find.

00:42:21.920 --> 00:42:22.260
We don't know what we're going to experience, what we're going to find.

00:42:22.500 --> 00:42:23.100
We don't know what we're going to experience, what we're going to find.

00:42:23.940 --> 00:42:25.260
It's such a big change.

00:42:25.720 --> 00:42:32.040
And so one of those criteria was it can't slow non-threaded Python down too much, right?

00:42:32.300 --> 00:42:37.020
And it looks like that's within 10%, unless you're on a Mac, then it doesn't seem to matter

00:42:37.060 --> 00:42:37.600
for some reason.

00:42:38.680 --> 00:42:39.180
Apple Silicon.

00:42:39.240 --> 00:42:40.900
Yeah, Apple Silicon is magic.

00:42:41.730 --> 00:42:42.980
But also with memory, right?

00:42:43.520 --> 00:42:45.460
I think it adds a little bit of a memory overhead

00:42:45.740 --> 00:42:50.060
for extra data structures to track safe reference counting and stuff.

00:42:50.260 --> 00:42:55.020
Yeah, and actually the new acceptance criteria for the next stage

00:42:55.420 --> 00:42:57.900
actually explicitly mentions the memory allowance.

00:42:58.640 --> 00:42:59.520
This is like in Donghee's new post about it

00:42:59.520 --> 00:43:02.580
This is like in Donghee's new post about it

00:43:02.740 --> 00:43:04.840
is that there's actually like an explicit number now.

00:43:04.910 --> 00:43:05.800
I don't think there was before.

00:43:05.860 --> 00:43:07.960
I think it was just tracking the CPU performance.

00:43:08.300 --> 00:43:08.840
Yeah, interesting.

00:43:09.380 --> 00:43:13.840
And I guess it's worth pointing out, there's a couple of resources that you highlighted here.

00:43:14.880 --> 00:43:25.640
There's a resource page by QuantSight, which is a big data science crew, that talks about what are the different projects that are relevant, I imagine, to the data science folks.

00:43:26.100 --> 00:43:30.980
And what is their status with supporting being tested, being released for free threading, right?

00:43:31.060 --> 00:43:31.140
And what is their status with supporting being tested, being released for free threading, right?

00:43:31.400 --> 00:43:31.560
Yeah.

00:43:31.820 --> 00:43:33.240
No, these sorts of statuses.

00:43:33.280 --> 00:43:38.860
And there's also one from Hugo, which tracks which wheels have the free threading available

00:43:39.940 --> 00:43:41.200
for just like an easy pip install.

00:43:41.480 --> 00:43:45.940
And in theory, that kind of means that these projects have tested it with free threading.

00:43:46.220 --> 00:43:47.980
Yeah, it looks like we're at 20%, I guess.

00:43:48.340 --> 00:43:48.440
Yeah, we're doing pretty good for this stage of like, it's experimental and it might get

00:43:48.560 --> 00:43:52.560
Yeah, we're doing pretty good for this stage of like, it's experimental and it might get

00:43:52.760 --> 00:43:53.020
ripped away.

00:43:53.400 --> 00:43:54.680
Like that was what it was before.

00:43:55.680 --> 00:43:55.940
Exactly.

00:43:56.860 --> 00:43:58.200
People are trying it out.

00:43:58.580 --> 00:44:01.800
I mean, like, this is how you get proof of people willing to try it.

00:44:02.020 --> 00:44:19.540
I know that inside of the actual Language Summit discussion, they also talked about, like, wanting to dig in deeper into this data, where it's like, okay, the projects support it, but how many users are installing those wheels to kind of show, like, how much is the community testing out free threading?

00:44:19.700 --> 00:44:24.820
Because just because a project supports it doesn't mean that, like, the community is trying it out at the same level.

00:44:25.120 --> 00:44:25.200
Right.

00:44:25.380 --> 00:44:26.880
So maybe that'll be relevant for the future.

00:44:27.120 --> 00:44:27.260
I suppose at least for the ones that offer true rethreaded wheels, you could use PyPI data.

00:44:27.260 --> 00:44:32.720
I suppose at least for the ones that offer true rethreaded wheels, you could use PyPI data.

00:44:33.180 --> 00:44:33.240
Yep.

00:44:33.460 --> 00:44:34.160
The Lime Hall, Google Cloud, BigQuery, or yeah, BigQuery.

00:44:34.700 --> 00:44:36.540
The Lime Hall, Google Cloud, BigQuery, or yeah, BigQuery.

00:44:36.780 --> 00:44:36.840
The BigQuery thing.

00:44:36.840 --> 00:44:37.440
The BigQuery thing.

00:44:38.180 --> 00:44:41.000
There are other ones that are, well, it's just pure Python, so it probably works.

00:44:42.040 --> 00:44:43.520
That's harder to quantify.

00:44:44.120 --> 00:44:48.160
So yeah, basically that change came along here.

00:44:48.380 --> 00:44:53.240
It says we support moving to what they call phase two, something like that.

00:44:53.500 --> 00:44:55.500
So there's multiple phases still, but yeah, excellent.

00:44:55.500 --> 00:44:56.340
So there's multiple phases still, but yeah, excellent.

00:44:56.640 --> 00:45:02.340
talked about this fearless one. We're no longer afraid of it. People are tired of hearing about

00:45:02.640 --> 00:45:07.860
threading for a minute. How about governance? Yeah. So Eric Snow did a presentation entitled

00:45:08.080 --> 00:45:13.240
The Challenges of the Steering Council. That's pretty interesting here. Tell us about this one.

00:45:13.420 --> 00:45:20.900
Yeah. So this one was kind of talking about as a core developer, how is the experience of having

00:45:20.900 --> 00:45:26.360
a steering council governing the development of Python? How is that working out right now? What

00:45:26.380 --> 00:45:33.540
What's the good? What's the bad? And I think the highlights are having a rotating, a completely

00:45:33.920 --> 00:45:39.780
rotating governance set of people on a council. Even if that means that most people are still on

00:45:39.780 --> 00:45:44.740
the council year over year, you still have that whole complete stoppage of time because people

00:45:44.750 --> 00:45:48.180
are starting to kind of like wind down because they know an election is coming. And then,

00:45:49.320 --> 00:45:55.660
so like PEP development gets impacted by that, right? If you're not timing your PEP authorship

00:45:55.680 --> 00:46:01.680
right, then sometimes you just get these huge delays. Also talking about how much the need for

00:46:02.060 --> 00:46:08.980
consensus impacts people's ability to participate in the discussions. So before, you could just

00:46:09.200 --> 00:46:13.040
participate openly. You don't have to worry about like, oh, am I speaking as the steering council,

00:46:13.120 --> 00:46:19.420
or am I speaking as individual or core developer? But now there's such a need for consensus that it

00:46:19.600 --> 00:46:24.060
kind of puts steering council members in a weird spot where they can't participate in the discussion

00:46:24.080 --> 00:46:28.100
unless they've already talked with other people in the steering council or do that as easily.

00:46:29.080 --> 00:46:29.940
And I think there was one more.

00:46:29.940 --> 00:46:30.700
And I think there was one more.

00:46:31.460 --> 00:46:31.580
Yeah.

00:46:31.590 --> 00:46:37.440
One of the thoughts, one of the threads was I had a conversation with somebody who is a core developer,

00:46:37.650 --> 00:46:39.420
but also happens to be on the steering council.

00:46:39.750 --> 00:46:42.840
I felt like we were in agreement on this idea.

00:46:43.070 --> 00:46:46.300
But then when I spoke to them as steering council member,

00:46:46.730 --> 00:46:50.240
then the story changed a little bit because it was a committee response.

00:46:51.220 --> 00:46:56.700
And you're like, I think Eric Snow himself expressed frustration that like, I've, yeah,

00:46:56.760 --> 00:46:57.800
And you're like, I think Eric Snow himself expressed frustration that like, I've, yeah,

00:46:58.120 --> 00:46:59.540
I've worked on this project.

00:46:59.690 --> 00:47:00.700
I thought we had agreement.

00:47:00.870 --> 00:47:02.980
And then turns out for some reason it wasn't right.

00:47:03.360 --> 00:47:09.920
Yeah, I think, yeah, they, it's really hard to know if you have consensus when the like

00:47:09.980 --> 00:47:15.100
response, right, is delayed because you can't tell then if it's consensus because like the

00:47:15.240 --> 00:47:18.800
discussion is, you know, slowed down and no one's bringing up any new points.

00:47:18.920 --> 00:47:22.020
or if it's because like people have thoughts,

00:47:22.140 --> 00:47:23.180
but then they have to talk

00:47:23.200 --> 00:47:25.020
to their steering council fellow members.

00:47:25.340 --> 00:47:27.620
And then, you know, it's difficult to judge

00:47:27.880 --> 00:47:29.780
and you don't really want to tip the hat

00:47:29.900 --> 00:47:31.700
one way or the other during the discussion

00:47:31.880 --> 00:47:34.160
because you don't want to get people with false hope.

00:47:34.220 --> 00:47:36.060
You don't want to like tell people

00:47:36.220 --> 00:47:36.940
not to work on something

00:47:37.080 --> 00:47:38.180
when it's actually going to go through.

00:47:38.620 --> 00:47:39.800
So it's challenging.

00:47:40.160 --> 00:47:41.800
Yeah, two other issues.

00:47:42.440 --> 00:47:44.520
I guess it's also worth pointing out before I say this

00:47:44.860 --> 00:47:46.900
that Eric said, look, things are working pretty well.

00:47:47.120 --> 00:47:48.120
Python hasn't stagnated.

00:47:48.340 --> 00:47:53.820
peps are getting approved things are happening right so that's good but one challenge is just

00:47:53.980 --> 00:48:01.820
it's slower to get responses about peps and so on because it's volunteer committee work rather than

00:48:02.180 --> 00:48:04.780
one person who can just be the decider you know yeah it's it is really tough and especially and

00:48:04.780 --> 00:48:05.720
one person who can just be the decider you know yeah it's it is really tough and especially and

00:48:05.720 --> 00:48:07.260
one person who can just be the decider you know yeah it's it is really tough and especially and

00:48:07.260 --> 00:48:08.860
one person who can just be the decider you know yeah it's it is really tough and especially and

00:48:08.920 --> 00:48:13.840
this kind of comes through with like here's all these things that are happening to python all at

00:48:13.780 --> 00:48:19.120
once and uh yeah good luck steering council with like trying to make all of those things work

00:48:19.220 --> 00:48:23.180
together because the thing is the steering council wants all of these good projects that

00:48:23.180 --> 00:48:28.520
are having to python to all land and to all have a good time but they all interdepend on each other

00:48:28.960 --> 00:48:33.540
i know that there was like a like people were talking about delegation as like a potential

00:48:33.840 --> 00:48:38.160
solution for this and i think the steering council like loves delegation they want to delegate more

00:48:38.420 --> 00:48:43.740
but they sometimes have an issue with delegation when it comes to these topics that like overlap

00:48:43.760 --> 00:48:48.400
with other big projects that are happening concurrently in Python, where you can't delegate

00:48:48.800 --> 00:48:53.360
someone for free threading because free threading touches everything. And so if you delegate

00:48:53.600 --> 00:48:58.520
something for free threading, then that person is not looking at all the other projects that are

00:48:58.660 --> 00:49:00.100
happening in Python. And that's a problem. Yeah. Yeah. I think another two other things I want to

00:49:00.620 --> 00:49:03.440
happening in Python. And that's a problem. Yeah. Yeah. I think another two other things I want to

00:49:03.440 --> 00:49:08.340
touch on real quick. There's a lot of interesting stuff in this one. One is visibility into what's

00:49:08.480 --> 00:49:13.180
happening in the steering council discussions, right? And that talks, it's a little bit addressing

00:49:13.200 --> 00:49:18.740
the surprise, but also just knowing. Kind of like you did for the language summit, you brought a lot

00:49:18.780 --> 00:49:23.040
visibility and awareness of what's happening there. A lot of this wouldn't be known, especially what

00:49:23.110 --> 00:49:28.060
happened in the discussion, if it weren't for something like that. So Guido pointed out that

00:49:28.460 --> 00:49:33.780
California, where he lives, has the Brown Act, which requires all meetings, like governmental

00:49:33.900 --> 00:49:38.240
meetings, to be open to the public for local governmental groups in charge of infrastructure

00:49:38.260 --> 00:49:43.060
without private deliberations barring personnel issues or something like that right so basically

00:49:43.640 --> 00:49:49.200
there's um regulations or rules for saying like here's how the stuff is open you know maybe all

00:49:49.200 --> 00:49:54.180
the conversations are lives all the meetings are live streamed or who knows you know something like

00:49:54.260 --> 00:49:54.700
that yeah no the there was a lot of different options thrown out there for like how to make

00:49:54.700 --> 00:49:59.180
that yeah no the there was a lot of different options thrown out there for like how to make

00:49:59.320 --> 00:50:04.460
these meetings or the deliberations or decision making of the steering council more open one of

00:50:04.380 --> 00:50:09.360
we don't put out there that like oh maybe they should just be open like everyone can see it like

00:50:09.360 --> 00:50:13.720
a live stream or like the meeting minutes are just you know transcribed instantly and then published

00:50:14.020 --> 00:50:19.240
the next day or whatever like something like that or because right now they publish meeting minutes

00:50:19.420 --> 00:50:24.080
and they're they're getting more regularly doing that like actually getting the meeting minutes out

00:50:24.220 --> 00:50:29.140
on time i know there was like some uh there was definitely some issue with that in the past where

00:50:29.540 --> 00:50:34.340
like the meeting minutes were really delayed and so it's really hard to to keep up to date with

00:50:34.360 --> 00:50:35.060
what actually got discussed.

00:50:35.380 --> 00:50:38.260
You want the 2025 version, not the live stream,

00:50:38.540 --> 00:50:40.920
but you put your AI assistant in all the meetings.

00:50:40.920 --> 00:50:41.460
Sure, yeah.

00:50:41.600 --> 00:50:44.380
And let it creep meeting notes.

00:50:44.560 --> 00:50:46.400
Honestly, it probably wouldn't be that bad.

00:50:46.960 --> 00:50:48.300
There might be a few things like,

00:50:49.100 --> 00:50:50.500
oh, you got that wrong, sorry.

00:50:51.000 --> 00:50:52.660
But in general, I think it'd be pretty good.

00:50:52.720 --> 00:50:54.000
And then the last thing here is

00:50:54.080 --> 00:50:55.560
there was some conversation of like,

00:50:56.040 --> 00:50:57.740
well, deciding by committee's tough

00:50:57.760 --> 00:51:00.040
and how much of the community should we listen to?

00:51:00.260 --> 00:51:03.120
And somewhere it was proposed that maybe,

00:51:03.520 --> 00:51:06.040
Maybe things like discuss.python.org.

00:51:06.360 --> 00:51:09.960
We've had polls and people said what they wanted and didn't want, right?

00:51:10.180 --> 00:51:12.780
And Barry wisely points out, like, polls are useful,

00:51:13.380 --> 00:51:15.540
but there's a whole bunch of people, millions of users,

00:51:16.200 --> 00:51:18.380
that are not participating in discourse.

00:51:19.260 --> 00:51:24.520
And I just want to take a moment to, like, restate.

00:51:24.580 --> 00:51:28.640
I think that Scott Hanselman has such an amazing topic or idea here

00:51:28.700 --> 00:51:32.900
where he talks about the dark matter developers, the unseen 99%.

00:51:32.920 --> 00:51:33.540
and I'll link to this.

00:51:33.780 --> 00:51:36.020
So obviously we know what dark matter is in astronomy,

00:51:36.220 --> 00:51:38.480
but like these are people who just go to their jobs.

00:51:38.920 --> 00:51:41.180
They don't spend their evenings on discussion boards.

00:51:41.780 --> 00:51:42.780
They don't go to conferences

00:51:43.000 --> 00:51:45.460
and participate in panel discussions.

00:51:46.140 --> 00:51:46.980
They're not on social media.

00:51:47.140 --> 00:51:49.580
They just use Python or whatever language

00:51:50.020 --> 00:51:52.160
and they do their thing and it matters deeply to them,

00:51:52.420 --> 00:51:55.240
but you won't ever notice them in these polls

00:51:55.540 --> 00:51:57.060
or PSF surveys or whatever

00:51:57.120 --> 00:51:58.720
because they just don't do those things.

00:51:58.880 --> 00:52:00.220
There's probably a good chunk of them.

00:52:00.420 --> 00:52:00.600
Yeah.

00:52:00.880 --> 00:52:05.020
And the steering council has the difficult job of representing these folks too, because

00:52:05.080 --> 00:52:07.240
they try to do what's best for Python.

00:52:07.420 --> 00:52:10.140
And that's for everybody, not just people that vote and polls on Discord.

00:52:10.200 --> 00:52:10.580
Right, right.

00:52:10.680 --> 00:52:11.340
That's what Barry was saying.

00:52:11.540 --> 00:52:12.420
It's like, it's tricky though.

00:52:12.420 --> 00:52:13.420
It's like, how do you measure that?

00:52:13.540 --> 00:52:14.080
You know what I mean?

00:52:14.460 --> 00:52:16.200
Yeah, it is super, super tricky.

00:52:16.800 --> 00:52:17.040
All right.

00:52:17.040 --> 00:52:17.560
All right.

00:52:17.560 --> 00:52:17.780
All right.

00:52:18.720 --> 00:52:19.120
Packaging.

00:52:19.780 --> 00:52:19.880
Yeah.

00:52:19.940 --> 00:52:23.380
So this one was really quite a quick talk or it was mostly just talking about, hey,

00:52:23.820 --> 00:52:24.840
this PEP is happening.

00:52:25.240 --> 00:52:26.320
The packaging governance process.

00:52:26.420 --> 00:52:29.660
I know that this got discussed a lot more in the packaging summit.

00:52:30.400 --> 00:52:33.220
Here, I think it was mostly just like, hey, this is happening.

00:52:33.480 --> 00:52:34.860
Here's what the steering council needs to know.

00:52:35.020 --> 00:52:36.320
Here's what core developers need to know.

00:52:37.240 --> 00:52:42.080
This whole thing came out of the wheel next directive, which is like wheel next.dev.

00:52:42.300 --> 00:52:43.080
They've got their own website.

00:52:44.620 --> 00:52:49.920
And it's basically trying to adopt the steering council model, but for packaging, because right

00:52:50.040 --> 00:52:53.620
now packaging peps tend to be delegated to like one or two people.

00:52:54.140 --> 00:53:03.660
And obviously, if things 10x or 100x in complexity and concurrent projects, it is just not possible for one person to just be doing that work.

00:53:03.680 --> 00:53:07.580
And so trying to adopt a council model, similar to the steering council.

00:53:07.700 --> 00:53:14.980
And I think the biggest open questions right now are things like, how is that initial council and how is the voting body going to be formed?

00:53:15.260 --> 00:53:17.820
Because the voting body for the steering council is core developers.

00:53:18.360 --> 00:53:20.140
But what is the voting body for Python packaging?

00:53:20.140 --> 00:53:20.840
But what is the voting body for Python packaging?

00:53:22.160 --> 00:53:22.560
Right, exactly.

00:53:23.180 --> 00:53:27.980
And again, it runs into some of the issues of sort of delegating, but packaging touches

00:53:28.240 --> 00:53:29.520
everything and so on.

00:53:29.600 --> 00:53:29.720
Yeah.

00:53:30.080 --> 00:53:30.180
Tricky.

00:53:30.500 --> 00:53:30.640
Okay.

00:53:31.140 --> 00:53:31.380
Excellent.

00:53:31.900 --> 00:53:34.220
And you referenced this one, Python Unmobile by Russell, Keith McGee and Malcolm Smith.

00:53:34.220 --> 00:53:35.360
And you referenced this one, Python Unmobile by Russell, Keith McGee and Malcolm Smith.

00:53:35.640 --> 00:53:36.760
And you referenced this one, Python Unmobile by Russell, Keith McGee and Malcolm Smith.

00:53:36.900 --> 00:53:41.100
I just had Russell on the show not too long ago to talk about some of this work as well.

00:53:41.340 --> 00:53:46.600
But he says, after many years, this year, I can say that Python Unmobile is there, met

00:53:46.680 --> 00:53:48.420
with a large round of applause from the room.

00:53:48.700 --> 00:53:48.900
Yep.

00:53:49.180 --> 00:53:49.240
Yeah.

00:53:49.380 --> 00:53:56.200
It was it was an awesome moment, especially because I covered kind of like one of the last status reports before the big hurrah.

00:53:56.230 --> 00:53:59.180
We did it with Russell and Malcolm.

00:53:59.750 --> 00:54:04.060
Yeah, basically both of the peps for Android support and iOS support are finished.

00:54:04.540 --> 00:54:11.320
And they are tracking really, really close to basically adding tier two support for iOS and Android to Python.

00:54:11.660 --> 00:54:18.820
And tier two support basically means that if any feature change or bug fix or anything ends up breaking support for that platform,

00:54:19.080 --> 00:54:20.540
then a release can't proceed.

00:54:21.050 --> 00:54:23.680
So the platform basically needs to be supported

00:54:23.770 --> 00:54:24.600
for a release to happen.

00:54:24.900 --> 00:54:25.720
And that's a huge deal

00:54:25.850 --> 00:54:27.540
because it means that people can be confident

00:54:27.740 --> 00:54:29.720
that support isn't going to just be taken away

00:54:30.040 --> 00:54:33.140
or not surprised it doesn't work, which is great.

00:54:33.140 --> 00:54:33.460
or not surprised it doesn't work, which is great.

00:54:33.710 --> 00:54:35.900
So basically it just means there's a whole new,

00:54:36.340 --> 00:54:37.860
hopefully a whole new set of users

00:54:38.080 --> 00:54:40.220
that can use Python to build on these mobile platforms.

00:54:40.320 --> 00:54:41.000
Yeah, that'd be great.

00:54:41.170 --> 00:54:43.800
So specifically PEP 730 and 738,

00:54:44.540 --> 00:54:48.160
meaning that CPython builds and runs on iOS

00:54:48.160 --> 00:54:50.540
and builds and runs on Android, right?

00:54:50.780 --> 00:54:53.440
And that the core development team

00:54:54.140 --> 00:54:56.420
considers breaking that build

00:54:56.760 --> 00:54:58.940
part of breaking Python, right?

00:54:59.440 --> 00:55:01.200
There's still work to be done

00:55:01.490 --> 00:55:03.380
in terms of tooling, right?

00:55:03.540 --> 00:55:05.600
Like I'm not going to get a Python plugin

00:55:05.860 --> 00:55:07.940
for Xcode and drag a storyboard across

00:55:08.560 --> 00:55:09.540
and then publish it, right?

00:55:09.780 --> 00:55:11.640
Some of that stuff is coming from the Beware team

00:55:12.060 --> 00:55:13.920
backed by Anaconda, which is great.

00:55:14.280 --> 00:55:16.599
But I think this announcement is like

00:55:16.920 --> 00:55:19.800
the runtime CPython bits are in place.

00:55:19.800 --> 00:55:20.420
the runtime CPython bits are in place.

00:55:20.940 --> 00:55:21.500
Yeah, definitely.

00:55:21.760 --> 00:55:23.500
So like, yeah, it's not like,

00:55:23.640 --> 00:55:25.120
oh, suddenly Xcode just works

00:55:25.480 --> 00:55:27.200
and you can just write an Xcode project in Python

00:55:28.160 --> 00:55:29.280
just as easily as you would write,

00:55:29.580 --> 00:55:30.820
you know, a web app in Python.

00:55:31.860 --> 00:55:33.320
But yeah, the fact that it works at all,

00:55:33.620 --> 00:55:34.300
like the fact that you can run it on an iPhone

00:55:34.300 --> 00:55:36.440
like the fact that you can run it on an iPhone

00:55:36.940 --> 00:55:37.920
or on an Android phone,

00:55:38.220 --> 00:55:39.320
like that's huge.

00:55:39.640 --> 00:55:41.000
And the core developer team is willing to say,

00:55:41.000 --> 00:55:42.260
And the core developer team is willing to say,

00:55:42.320 --> 00:55:43.280
yeah, this is going to keep working.

00:55:43.600 --> 00:55:44.360
They should.

00:55:44.660 --> 00:55:48.000
It's not a flash in the pan, these mobile phones.

00:55:48.360 --> 00:55:48.980
Some people use them.

00:55:49.820 --> 00:55:50.100
Allegedly.

00:55:51.020 --> 00:55:51.420
Allegedly.

00:55:51.960 --> 00:55:53.120
How many do I have around me?

00:55:53.620 --> 00:55:53.900
I know.

00:55:55.340 --> 00:55:56.620
As I have one in view.

00:55:57.080 --> 00:55:57.600
Yeah, exactly.

00:55:57.980 --> 00:56:00.000
Where's the iPads and all the other stuff?

00:56:00.860 --> 00:56:02.740
Yeah, if I never see Xcode again in my life,

00:56:02.740 --> 00:56:03.700
I would be too soon.

00:56:04.400 --> 00:56:06.700
It's just such a bad, bad piece of software.

00:56:06.860 --> 00:56:08.340
It's such a bad tool for building software.

00:56:08.540 --> 00:56:10.080
I've had to work with a lot for our mobile apps.

00:56:10.680 --> 00:56:11.700
I've thankfully not have to dealt with any app development yet

00:56:11.700 --> 00:56:13.640
I've thankfully not have to dealt with any app development yet

00:56:13.660 --> 00:56:15.880
in my career. It's been all web development.

00:56:17.280 --> 00:56:19.660
It's such, you don't appreciate

00:56:20.410 --> 00:56:24.040
the freedom that you have. I know open source means freedom in some ways,

00:56:24.520 --> 00:56:28.060
but just the ability to go, I made a change. I published it.

00:56:28.390 --> 00:56:28.780
The world has it. It's not like I've had a debate with random people

00:56:28.780 --> 00:56:32.060
The world has it. It's not like I've had a debate with random people

00:56:32.060 --> 00:56:36.180
who are in a hurry and don't care about what I've built, and then they tell me that it infringes

00:56:36.180 --> 00:56:40.180
on something somebody else built, even when that's actually not true, because they don't understand

00:56:40.200 --> 00:56:40.560
what it does. That's even outside. A lot more people involved in mobile publishing. And rules

00:56:41.760 --> 00:56:42.840
what it does. That's even outside. A lot more people involved in mobile publishing. And rules

00:56:43.340 --> 00:56:48.080
what it does. That's even outside. A lot more people involved in mobile publishing. And rules

00:56:48.460 --> 00:56:53.980
that don't align with your incentives. Like we want to extract money from you. Anyway, that's a

00:56:54.120 --> 00:57:01.480
long story of through app in-app purchases. Yeah. Okay. Another one, I hinted to this, like,

00:57:01.940 --> 00:57:07.160
are we going to need to change the name of CPython? Because CPython means literally the C language

00:57:07.180 --> 00:57:12.340
implementation of python what a core developers want from rust and do they want rust in their

00:57:12.440 --> 00:57:18.600
c python you know is this a uh reese's pieces reese's peanut butter cup sort of thing you got

00:57:18.630 --> 00:57:22.140
your rust in my c or something yeah yeah yeah uh yeah this was this was a really interesting one

00:57:22.140 --> 00:57:25.400
your rust in my c or something yeah yeah yeah uh yeah this was this was a really interesting one

00:57:25.580 --> 00:57:32.960
because i think that um the room was maybe a little bit surprised by like how like open uh

00:57:32.980 --> 00:57:39.660
core developers were about maybe the idea of something optional being in cpython that is

00:57:39.660 --> 00:57:44.720
written in rust um because like cpython there's the core runtime right there's the syntax there's

00:57:44.720 --> 00:57:49.020
the interpreter there's all that stuff that like everyone uses on every single python session but

00:57:49.020 --> 00:57:56.040
then there's also all these standard library modules uh like os and sys and ssl and all of

00:57:56.040 --> 00:58:02.160
these other libraries right and those modules are kind of their own thing they're their own little

00:58:02.160 --> 00:58:07.740
project that just happens to live inside of cpython and i think the result of all of this

00:58:08.000 --> 00:58:13.900
conversation of like oh what what does what do core developers want from rust was like hey let's try

00:58:14.440 --> 00:58:20.780
let's try something uh maybe having a standard library extension module written in rust and like

00:58:20.910 --> 00:58:25.800
what would that take what would that look like um would we need to change the build system would we

00:58:25.940 --> 00:58:31.000
need to you know what would actually need to happen for for that to be a possibility um and i think

00:58:30.940 --> 00:58:35.360
there's some like huge benefits to having rust I mean David talked about a whole bunch of them

00:58:35.500 --> 00:58:39.300
where it's like this it's this new language there's lots of new programmers that are interested in it

00:58:39.500 --> 00:58:42.020
has all the memory safety stuff it has all the performance stuff and also yeah brief threading

00:58:42.020 --> 00:58:42.920
has all the memory safety stuff it has all the performance stuff and also yeah brief threading

00:58:42.920 --> 00:58:43.420
has all the memory safety stuff it has all the performance stuff and also yeah brief threading

00:58:43.420 --> 00:58:44.340
has all the memory safety stuff it has all the performance stuff and also yeah brief threading

00:58:44.380 --> 00:58:50.400
works really great with it there's just like tons of benefits to to having rust be a part of like a

00:58:50.580 --> 00:58:56.119
python python developers toolkit it's like how can we can we also have that in the cord for libraries

00:58:57.360 --> 00:59:02.800
and I think the answer was like try it out and see what happens and maybe who knows right like

00:59:03.140 --> 00:59:08.100
they definitely like core developers caveat it as like it'll definitely have to be an optional part

00:59:08.100 --> 00:59:16.200
of the standard library because not everyone is going to be using Rust on CPython and yeah maybe

00:59:16.340 --> 00:59:22.180
not one of the core parts of this of the actual of the interpreter in the runtime because they're

00:59:22.200 --> 00:59:25.780
they're quite well used and well maintained right now.

00:59:26.120 --> 00:59:26.860
So we'll see.

00:59:27.030 --> 00:59:28.680
I think it's going to be interesting to see if,

00:59:28.830 --> 00:59:31.160
if David and some other interested folks will,

00:59:31.400 --> 00:59:34.400
will put together something like a standard library module that uses rust.

00:59:34.760 --> 00:59:34.860
Yeah.

00:59:35.020 --> 00:59:35.880
Maybe in 2035,

00:59:36.110 --> 00:59:36.920
we'll still be doing this.

00:59:36.950 --> 00:59:38.200
We'll still be talking about,

00:59:38.500 --> 00:59:43.160
but we'll be talking about how the C adaptive layer to integrate with rust is

00:59:43.300 --> 00:59:43.440
working.

00:59:43.640 --> 00:59:46.540
So we can still keep all these C extensions running instead of the other way

00:59:46.680 --> 00:59:46.800
around.

00:59:47.220 --> 00:59:47.340
Yeah.

00:59:47.620 --> 00:59:47.700
Yeah.

00:59:48.020 --> 00:59:48.780
A couple of interesting takeaways.

00:59:49.620 --> 00:59:57.740
David points out, our best estimate is that somewhere between a quarter and a third of all native code being uploaded to PyPI for new projects is using Rust.

00:59:58.180 --> 01:00:10.920
Yeah, so this uses like, basically use this, it's py-code.org, where it can introspect into Python, like packages, the actual files that are uploaded, and then looks for Rust.

01:00:11.780 --> 01:00:15.300
And so like any package that is using Rust

01:00:15.980 --> 01:00:17.440
and it's a new package or a new release,

01:00:17.820 --> 01:00:21.100
you can see like what percentage of new projects

01:00:21.240 --> 01:00:24.560
are using Rust versus like C or C++ or something else.

01:00:24.960 --> 01:00:28.300
So David was able to extract that data point.

01:00:28.480 --> 01:00:30.340
Yeah, there's a lot of Rust happening for new projects.

01:00:30.460 --> 01:00:34.180
Obviously, old projects are likely very C, C++ dominated,

01:00:34.400 --> 01:00:35.120
but what are new Python developers choosing to use?

01:00:35.120 --> 01:00:36.040
but what are new Python developers choosing to use?

01:00:36.040 --> 01:00:37.400
but what are new Python developers choosing to use?

01:00:37.720 --> 01:00:39.800
Yeah, they didn't choose C.

01:00:39.940 --> 01:00:44.840
They just chose not to rewrite it in Rust yet, which is a different barrier, I suppose.

01:00:45.160 --> 01:00:50.740
Not saying they should, but I agree that choosing new projects is an interesting metric.

01:00:51.260 --> 01:00:55.500
So a couple other things from here is like, should we rewrite CPython in Rust?

01:00:56.080 --> 01:00:58.380
There's a lot of people like, or a lot of comments of like,

01:00:58.520 --> 01:01:00.640
there's a lot of people who just don't want to learn Rust.

01:01:01.120 --> 01:01:01.980
They don't care about Rust.

01:01:02.420 --> 01:01:07.940
This is a challenge for CPython is that the core developers in particular

01:01:07.960 --> 01:01:10.060
have a special skill of writing C

01:01:10.440 --> 01:01:12.040
and writing CPython in particular.

01:01:12.540 --> 01:01:14.960
And this moved the cheese for a lot of folks.

01:01:15.000 --> 01:01:16.880
And they like, how much do they care, right?

01:01:16.960 --> 01:01:19.280
Like they took Rust on Linux,

01:01:19.780 --> 01:01:22.100
Rust in Linux core as an example, right?

01:01:22.200 --> 01:01:23.360
People just, they don't want to change,

01:01:23.740 --> 01:01:24.900
which I'm not saying they should, but.

01:01:25.160 --> 01:01:26.540
Yeah, it's a really difficult question,

01:01:26.540 --> 01:01:27.240
Yeah, it's a really difficult question,

01:01:27.480 --> 01:01:30.860
especially when there's like this really tight ownership

01:01:31.260 --> 01:01:32.940
of like one or a few people

01:01:33.280 --> 01:01:35.040
with like this very specific part of code.

01:01:35.460 --> 01:01:37.400
And, you know, they've been maintaining it

01:01:37.420 --> 01:01:39.740
since for a really long time,

01:01:39.830 --> 01:01:43.560
and it's hard to try to force that sort of change onto people.

01:01:43.710 --> 01:01:46.520
But then things that are new or things that are optional,

01:01:46.960 --> 01:01:48.240
that's a really great place to start.

01:01:48.800 --> 01:01:52.560
I think learning from the Rust and Linux project

01:01:52.960 --> 01:01:54.820
is a really great idea for Python,

01:01:55.610 --> 01:01:56.900
because it's in a lot of ways,

01:01:57.150 --> 01:02:00.600
even though Linux maybe is an order of magnitude more complexity,

01:02:00.880 --> 01:02:04.700
I think that the situation or the structure of the code

01:02:04.700 --> 01:02:06.000
in the project is pretty similar,

01:02:06.180 --> 01:02:07.500
where there's like this really big core.

01:02:07.530 --> 01:02:11.080
And then there's like a ton of different smaller sub projects that are all have

01:02:11.090 --> 01:02:15.040
their own little owners, governance, contributors happening in the background.

01:02:15.460 --> 01:02:15.600
Yeah.

01:02:15.850 --> 01:02:16.380
A hundred percent.

01:02:16.790 --> 01:02:18.940
I mean, it is, it is 2025.

01:02:19.630 --> 01:02:20.920
We could try, try again.

01:02:21.580 --> 01:02:25.520
I mean, we could just vibe code it like, Hey, cursor, rewrite CPython and Rust,

01:02:25.980 --> 01:02:26.540
or you go to jail.

01:02:27.820 --> 01:02:28.220
Is that the meta these days?

01:02:28.220 --> 01:02:28.660
Is that the meta these days?

01:02:28.660 --> 01:02:28.720
Is that the meta these days?

01:02:30.500 --> 01:02:32.960
That's there's this really great video.

01:02:33.280 --> 01:02:34.520
Senior engineer tries vibe coding.

01:02:34.940 --> 01:02:37.980
It's always telling it, like, if it doesn't do it, it'll go to jail.

01:02:38.400 --> 01:02:40.580
But also it says, please, like, or you go to jail, please.

01:02:41.680 --> 01:02:42.160
It's amazing.

01:02:42.860 --> 01:02:48.980
I mean, as much as I joke, honestly, I do think AI code assistance could help in supporting

01:02:49.180 --> 01:02:49.620
the transition.

01:02:50.300 --> 01:02:52.060
I know that's good at C and it's good at REST.

01:02:52.340 --> 01:02:53.540
Not that you should vibe code it.

01:02:53.660 --> 01:02:54.380
That's not what I'm saying.

01:02:55.400 --> 01:02:58.380
But anyway, we live in weird times, Seth.

01:02:58.460 --> 01:02:58.680
We do.

01:02:58.980 --> 01:02:59.700
We really do.

01:03:00.440 --> 01:03:11.920
I think the other constraint here that maybe a lot of people don't track is that it's not just, I need to somehow make CPython work on Linux, Windows, and Mac.

01:03:12.210 --> 01:03:14.320
And if we build it in Rust, that's a different tool chain.

01:03:14.700 --> 01:03:25.500
There are a bunch of edge cases and platforms that are not very commonly used that maybe Rust itself doesn't even support that Python has promised to keep running on, right?

01:03:25.800 --> 01:03:25.920
Yeah.

01:03:26.190 --> 01:03:28.800
Or, I mean, even if not promised, right?

01:03:28.960 --> 01:03:29.940
Like there's people that are just running, running on these platforms.

01:03:29.940 --> 01:03:30.380
Like there's people that are just running, running on these platforms.

01:03:30.380 --> 01:03:32.060
Like there's people that are just running, running on these platforms.

01:03:32.540 --> 01:03:36.280
And then if something would break, they would only show up when something breaks.

01:03:36.960 --> 01:03:38.200
And what do you do?

01:03:38.380 --> 01:03:38.460
Right.

01:03:38.520 --> 01:03:39.280
Like you've been supporting these people for a very, very long time.

01:03:39.280 --> 01:03:39.760
Like you've been supporting these people for a very, very long time.

01:03:39.760 --> 01:03:41.680
Like you've been supporting these people for a very, very long time.

01:03:42.200 --> 01:03:44.240
And what, what, what happens then?

01:03:44.380 --> 01:03:45.720
What, what was stability guarantees?

01:03:45.960 --> 01:03:50.200
Do you give those people that, you know, maybe you're not like a tier one platform, but if

01:03:50.200 --> 01:03:50.600
Do you give those people that, you know, maybe you're not like a tier one platform, but if

01:03:50.660 --> 01:03:51.040
you've been, you know, making them use like they've been using Python totally normally

01:03:51.400 --> 01:03:54.200
you've been, you know, making them use like they've been using Python totally normally

01:03:54.340 --> 01:03:55.020
for all this time.

01:03:55.260 --> 01:03:55.860
What does that mean?

01:03:56.220 --> 01:03:56.280
So, yeah, well, we just talked about tier three iOS and Android.

01:03:56.460 --> 01:03:58.800
So, yeah, well, we just talked about tier three iOS and Android.

01:03:58.920 --> 01:04:04.900
support like does it work there i maybe i don't know but you've got like this little micro python

01:04:05.380 --> 01:04:09.940
circuit python chip that i got that's like i don't know like size of a thumb or something

01:04:10.750 --> 01:04:14.860
does the build system work for that i don't know yeah but i'm running python on it today yeah i

01:04:14.860 --> 01:04:15.320
does the build system work for that i don't know yeah but i'm running python on it today yeah i

01:04:15.400 --> 01:04:20.520
think that like one of the things that got identified was the state of gcc support for

01:04:20.900 --> 01:04:25.040
rust as as like something interesting so that's something to track if you're if you're interested

01:04:25.060 --> 01:04:27.760
in Rust and CPython working together,

01:04:27.960 --> 01:04:28.820
that's definitely like a project

01:04:29.280 --> 01:04:31.840
that's outside of Python and Rust's,

01:04:32.080 --> 01:04:33.040
like, and, you know,

01:04:33.440 --> 01:04:34.760
Maturin and PyO3s

01:04:35.020 --> 01:04:36.680
if you want to watch that project.

01:04:37.080 --> 01:04:37.320
Yeah.

01:04:37.900 --> 01:04:38.940
Did say we need to go faster.

01:04:39.480 --> 01:04:40.000
Lightning around.

01:04:41.240 --> 01:04:42.420
Close things out here.

01:04:42.980 --> 01:04:43.700
I guess there's really,

01:04:44.020 --> 01:04:45.420
there's just the Pyodide.

01:04:45.440 --> 01:04:46.840
We didn't talk about the docs

01:04:47.300 --> 01:04:48.020
or the lightning talks.

01:04:48.240 --> 01:04:49.540
What else should we say

01:04:49.580 --> 01:04:51.180
before we call it a wrap on this?

01:04:51.580 --> 01:04:52.080
Should we go,

01:04:52.180 --> 01:04:53.320
let's go into the lightning talks

01:04:53.320 --> 01:04:55.500
and look at Guido's.

01:04:55.840 --> 01:04:57.880
I think that one was the most well-received

01:04:58.760 --> 01:05:00.720
and interesting lightning talk,

01:05:00.920 --> 01:05:01.360
which is contrasting how Python is developed today

01:05:01.360 --> 01:05:02.720
which is contrasting how Python is developed today

01:05:02.720 --> 01:05:04.720
which is contrasting how Python is developed today

01:05:05.360 --> 01:05:07.700
versus how it was developed by Guido

01:05:08.060 --> 01:05:11.620
and what sorts of things are we kind of like leaving behind

01:05:12.080 --> 01:05:13.980
by developing Python in this way?

01:05:14.100 --> 01:05:16.040
And is there anything that we can learn from how we use it?

01:05:16.040 --> 01:05:16.880
And is there anything that we can learn from how we use it?

01:05:17.020 --> 01:05:19.520
Does he mean more committee, more community agreement?

01:05:19.520 --> 01:05:21.680
Does he mean more committee, more community agreement?

01:05:21.720 --> 01:05:22.840
Or what was he getting at?

01:05:23.060 --> 01:05:28.640
I think it's the complexity side was the part that was really big for him, where it's like,

01:05:28.680 --> 01:05:35.400
we're trying to, if you want to land a feature in CPython, you need to write a perfect pep,

01:05:35.660 --> 01:05:41.700
come with a pull request that is, you know, performant and secure and the API is perfect

01:05:42.020 --> 01:05:47.460
and it's been vetted and it's been used. And like, there's this super, super high bar to clear,

01:05:47.820 --> 01:05:49.780
to add a feature to see Python.

01:05:51.100 --> 01:05:53.360
And you're not allowed to get it wrong.

01:05:53.800 --> 01:05:57.480
The first go around basically is I think was what he's mostly mentioning.

01:05:57.960 --> 01:06:01.100
Because demanding perfection means it's like the,

01:06:01.160 --> 01:06:04.900
the code equivalent of don't let good be the enemy or the perfect great be the

01:06:05.000 --> 01:06:06.920
enemy of the good or something like that. Right. Sure. Yeah, exactly. Yeah.

01:06:07.960 --> 01:06:08.360
enemy of the good or something like that. Right. Sure. Yeah, exactly. Yeah.

01:06:08.620 --> 01:06:10.720
Stuff like that where it's like, Hey, we, if,

01:06:10.880 --> 01:06:13.560
if Python were developed in that way early on,

01:06:13.880 --> 01:06:16.260
it wouldn't have worked out because that would still be in the lab or an idea

01:06:16.260 --> 01:06:16.760
it wouldn't have worked out because that would still be in the lab or an idea

01:06:16.760 --> 01:06:17.780
it wouldn't have worked out because that would still be in the lab or an idea

01:06:17.800 --> 01:06:21.780
or something exactly so i think that's a really interesting one to check out if you're looking at

01:06:21.800 --> 01:06:22.620
lightning talks okay cool now i i know some features have to be absolutely dead center in

01:06:22.620 --> 01:06:28.320
lightning talks okay cool now i i know some features have to be absolutely dead center in

01:06:28.320 --> 01:06:34.740
the core of the cpython runtime like free threading or a no GIL initiative or some new memory model

01:06:35.220 --> 01:06:41.340
or whatever but a lot of these things probably certainly with the standard library could maybe

01:06:41.660 --> 01:06:46.080
You talked about the immutable, the thread-safe concurrency data structures.

01:06:46.620 --> 01:06:50.320
Maybe there's a more formalized path of starting these things

01:06:50.440 --> 01:06:52.580
as third-party libraries on PyPI.

01:06:53.140 --> 01:06:56.880
And once they reach a certain bar maybe of adoption and maturity,

01:06:57.380 --> 01:06:59.280
then they make a step towards that.

01:06:59.280 --> 01:07:02.940
It would be interesting if, I know people can just go and create a project and do it,

01:07:02.940 --> 01:07:09.580
but like here's the prescribed way of non-C runtime features being added to the language.

01:07:09.740 --> 01:07:13.080
and it starts out in public and it makes its way over.

01:07:13.340 --> 01:07:14.680
Yeah, I think that got discussed

01:07:14.950 --> 01:07:16.840
in the last language summit too.

01:07:16.900 --> 01:07:17.940
I'm not sure if there's been any progress

01:07:18.070 --> 01:07:20.240
on like actually making a solid model

01:07:20.420 --> 01:07:22.700
for like here's how you go from PyPI to PEP

01:07:22.900 --> 01:07:23.900
to standard library.

01:07:24.160 --> 01:07:25.540
But it's definitely,

01:07:25.770 --> 01:07:27.240
I think it's just going to keep coming up

01:07:27.350 --> 01:07:28.520
until that happens.

01:07:28.650 --> 01:07:29.740
Because it's really common, right?

01:07:29.820 --> 01:07:32.400
Like so many features get developed this way now.

01:07:32.660 --> 01:07:33.440
It's also interestingly,

01:07:34.300 --> 01:07:37.340
some of the ideas of that direction have been rejected,

01:07:37.380 --> 01:07:44.380
like moving requests into cpython standard library was rejected because it would harm the growth and

01:07:44.620 --> 01:07:49.960
status of requests not cpython even though request is clearly better than what's built into cpython

01:07:50.160 --> 01:07:54.340
for your access you know not throw no shade that stuff's been around for a long time but yeah i

01:07:54.340 --> 01:07:54.960
for your access you know not throw no shade that stuff's been around for a long time but yeah i

01:07:54.960 --> 01:07:59.100
mean request is built on it so it obviously does some job well yeah yeah exactly it's just like a

01:07:59.100 --> 01:08:00.480
mean request is built on it so it obviously does some job well yeah yeah exactly it's just like a

01:08:00.600 --> 01:08:07.340
more user-friendly higher level api in front of it and we have httpx for like concurrent basically

01:08:07.360 --> 01:08:09.360
asyncio requests equivalent.

01:08:09.820 --> 01:08:12.820
So there's certainly history or examples

01:08:12.980 --> 01:08:15.260
of stuff starting out there becoming very popular

01:08:15.520 --> 01:08:16.819
but not wanting to go in,

01:08:17.120 --> 01:08:19.339
but specifically things that you might want to.

01:08:19.520 --> 01:08:22.319
Like, for example, would data classes be a thing

01:08:22.580 --> 01:08:24.640
if Pydantic was on a trajectory

01:08:24.819 --> 01:08:26.640
to sort of fill that role or adders from Hennig

01:08:26.640 --> 01:08:27.580
to sort of fill that role or adders from Hennig

01:08:27.580 --> 01:08:28.640
or something like that, right?

01:08:29.000 --> 01:08:29.900
Maybe not, I don't know.

01:08:30.100 --> 01:08:33.759
Yeah, no, I think that that whole road of experimentation

01:08:34.240 --> 01:08:35.600
and then moving into the standard library,

01:08:35.940 --> 01:08:37.299
like, we're just going to keep seeing it

01:08:37.390 --> 01:08:38.940
because it's just, it's such a great way

01:08:38.970 --> 01:08:40.960
to get stuff in the hands of users really, really quickly.

01:08:41.299 --> 01:08:43.000
Yeah. And I don't think just like,

01:08:43.080 --> 01:08:44.319
if I just went out and made a library,

01:08:44.740 --> 01:08:45.680
said I'm doing a library

01:08:45.859 --> 01:08:47.740
and I think it would be fun to have this as part of Python.

01:08:47.980 --> 01:08:49.200
Like people go, good for you, Michael.

01:08:49.740 --> 01:08:50.540
They would ignore it. Right.

01:08:51.000 --> 01:08:54.540
But if it was a little bit blessed by the steering kit,

01:08:54.600 --> 01:08:56.920
like we're experimenting and considering this idea

01:08:57.120 --> 01:08:58.920
as core developers, it starts here,

01:08:59.100 --> 01:09:01.200
but if it gains traction, it becomes Python.

01:09:01.640 --> 01:09:04.279
I think that is a different positioning

01:09:04.600 --> 01:09:07.120
than just like a random project that looks interesting.

01:09:07.339 --> 01:09:07.940
Yeah, definitely.

01:09:08.120 --> 01:09:09.740
I think that last year,

01:09:10.339 --> 01:09:12.200
one of the things that got suggested was like,

01:09:12.359 --> 01:09:15.600
hey, maybe we allow people to have those sorts of projects

01:09:15.900 --> 01:09:17.580
once they reach some amount of maturity

01:09:18.080 --> 01:09:22.279
and like direction to be housed under the Python GitHub org

01:09:22.520 --> 01:09:22.980
to try to give them some sort of like legitimacy of like,

01:09:22.980 --> 01:09:23.700
to try to give them some sort of like legitimacy of like,

01:09:23.700 --> 01:09:25.040
to try to give them some sort of like legitimacy of like,

01:09:25.040 --> 01:09:28.580
yeah, this project is on the track to going here

01:09:28.759 --> 01:09:31.040
and here's us showing that it is, right?

01:09:31.259 --> 01:09:31.960
Yeah, yeah, yeah.

01:09:32.279 --> 01:09:34.359
I feel like I should just say one more thing though.

01:09:34.540 --> 01:09:38.799
I do think there's a lot of value in having Python be smaller

01:09:38.920 --> 01:09:41.440
and having a bigger ecosystem outside of it.

01:09:42.020 --> 01:09:45.160
I'm not suggesting that everything should just be moved in into Python.

01:09:45.299 --> 01:09:47.920
I do think that just go like, I don't care what CPython does.

01:09:48.080 --> 01:09:50.299
If I like this HTTP library, I'm going to use it.

01:09:50.580 --> 01:09:54.180
And if it wants to implement itself in Rust or OCaml or whatever,

01:09:54.299 --> 01:09:54.740
I don't care.

01:09:54.900 --> 01:09:56.500
If that's better, they can go do that.

01:09:57.200 --> 01:09:59.500
And then I'll use it and it'll be great, right?

01:09:59.620 --> 01:10:03.040
and that doesn't have to go through committees and all this kind of stuff.

01:10:03.150 --> 01:10:07.240
So I'm not necessarily saying like everything should try to like find a hub

01:10:07.360 --> 01:10:09.240
and spoke model into the core Python,

01:10:09.630 --> 01:10:11.800
but those things that do intend to be there,

01:10:11.800 --> 01:10:14.140
it'd be cool to see like this sort of progressive path.

01:10:14.340 --> 01:10:16.280
People can get to it sooner. Anyway. Yeah.

01:10:16.480 --> 01:10:18.660
Final thoughts on that before we call it a show.

01:10:18.860 --> 01:10:19.960
I think we nailed it. Honestly.

01:10:21.300 --> 01:10:26.040
No, we definitely did. We definitely did. Yeah, no, let's,

01:10:26.400 --> 01:10:29.200
let's wrap it up. Thank you for doing this. This writeup.

01:10:29.320 --> 01:10:29.940
It's really interesting.

01:10:30.060 --> 01:10:31.920
I always value this look into, you know,

01:10:32.360 --> 01:10:33.460
to where's Python going.

01:10:33.740 --> 01:10:35.520
It's a lot to take from it.

01:10:35.700 --> 01:10:37.680
Final thoughts on this year's Language Summit?

01:10:38.140 --> 01:10:41.780
It is a really exciting year to be a Python developer.

01:10:41.920 --> 01:10:43.520
I think that 3.14 is,

01:10:44.060 --> 01:10:46.560
it's got so many really interesting things

01:10:46.680 --> 01:10:47.900
and changes to try.

01:10:48.880 --> 01:10:51.780
I am quite excited to get my hands on the beta,

01:10:51.940 --> 01:10:53.320
but then also the stable releases.

01:10:53.880 --> 01:10:56.180
I really am excited to see what people actually

01:10:56.380 --> 01:10:58.060
then go and do with the stuff, right?

01:10:58.180 --> 01:11:00.080
like building web apps with Python,

01:11:00.350 --> 01:11:01.460
building mobile apps with Python,

01:11:01.760 --> 01:11:03.160
building these massively parallel

01:11:04.400 --> 01:11:05.360
applications with Python.

01:11:05.860 --> 01:11:06.440
It's a pretty good time

01:11:06.520 --> 01:11:06.660
to be a Python developer right now.

01:11:06.660 --> 01:11:07.800
to be a Python developer right now.

01:11:09.420 --> 01:11:10.120
It's only getting better.

01:11:10.490 --> 01:11:10.580
Absolutely.

01:11:11.240 --> 01:11:11.640
All right, Seth.

01:11:11.960 --> 01:11:13.240
Thanks for being back on the show

01:11:13.330 --> 01:11:14.160
and thanks for doing the write-up.

01:11:14.320 --> 01:11:14.900
Thanks for having me.

01:11:15.260 --> 01:11:15.840
Yep. See you later.

01:11:16.700 --> 01:11:17.660
This has been another episode

01:11:17.950 --> 01:11:19.080
of Talk Python To Me.

01:11:19.860 --> 01:11:20.820
Thank you to our sponsors.

01:11:21.300 --> 01:11:21.980
Be sure to check out

01:11:21.980 --> 01:11:22.500
what they're offering.

01:11:22.680 --> 01:11:23.940
It really helps support the show.

01:11:24.500 --> 01:11:25.880
Take some stress out of your life.

01:11:26.220 --> 01:11:26.920
Get notified immediately

01:11:27.500 --> 01:11:32.780
about errors and performance issues in your web or mobile applications with Sentry. Just visit

01:11:33.040 --> 01:11:38.520
talkpython.fm/sentry and get started for free. And be sure to use the promo code

01:11:38.860 --> 01:11:43.840
talkpython, all one word. Want to level up your Python? We have one of the largest catalogs of

01:11:43.960 --> 01:11:48.640
Python video courses over at Talk Python. Our content ranges from true beginners to deeply

01:11:48.900 --> 01:11:53.420
advanced topics like memory and async. And best of all, there's not a subscription in sight.

01:11:53.500 --> 01:11:56.340
Check it out for yourself at training.talkpython.fm.

01:11:57.020 --> 01:12:01.200
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:12:01.640 --> 01:12:02.540
We should be right at the top.

01:12:03.040 --> 01:12:07.720
You can also find the iTunes feed at /itunes, the Google Play feed at /play,

01:12:08.140 --> 01:12:11.900
and the direct RSS feed at /rss on talkpython.fm.

01:12:12.560 --> 01:12:14.800
We're live streaming most of our recordings these days.

01:12:15.120 --> 01:12:18.260
If you want to be part of the show and have your comments featured on the air,

01:12:18.680 --> 01:12:22.640
be sure to subscribe to our YouTube channel at talkpython.fm/youtube.

01:12:23.700 --> 01:12:24.780
This is your host, Michael Kennedy.

01:12:25.200 --> 01:12:26.040
Thanks so much for listening.

01:12:26.220 --> 01:12:27.160
I really appreciate it.

01:12:27.540 --> 01:12:29.140
Now get out there and write some Python code.

01:12:51.440 --> 01:12:54.240
*music*

