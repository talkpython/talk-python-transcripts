WEBVTT

00:00:00.020 --> 00:00:02.440
Today, we're turning tiny tips into big wins.

00:00:03.020 --> 00:00:10.420
Quinn Tran, creator of CodeCut.ai, has shipped hundreds of bite-sized Python and data science snippets across four years.

00:00:11.220 --> 00:00:18.080
We dig into open source tools you can use right now, cleaner workflows, and why notebooks and scripts don't have to be enemies.

00:00:19.020 --> 00:00:25.100
If you want faster insights with fewer yak shaves, this one's packed with takeaways you can apply before lunch.

00:00:25.500 --> 00:00:26.040
Let's get into it.

00:00:26.620 --> 00:00:32.759
This is Talk Python To Me, Episode 522, recorded September 4th, 2025.

00:00:48.100 --> 00:00:51.020
Welcome to Talk Python To Me, a weekly podcast on Python.

00:00:51.620 --> 00:00:53.180
This is your host, Michael Kennedy.

00:00:53.440 --> 00:01:44.840
Follow me on Mastodon where I'm @mkennedy and follow the podcast using @talkpython, both accounts over at fosstodon.org and keep up with the show and listen to over nine years of episodes at talkpython.fm. If you want to be part of our live episodes, you can find the live streams over on YouTube. Subscribe to our YouTube channel over at talkpython.fm/youtube and get notified about upcoming shows. This episode is brought to you by Sentry. Don't let those errors go unnoticed, use Sentry like we do here at Talk Python. Sign up at talkpython.fm/sentry. And it's brought to you by Agency. Discover agentic AI with Agency. Their layer lets agents find, connect, and work together, any stack, anywhere. Start building the internet of agents at talkpython.fm/agency, spelled A-G-N-T-C-Y. Quinn, welcome to Talk Python.

00:01:45.360 --> 00:01:46.440
Great to have you here.

00:01:46.720 --> 00:01:47.780
Happy to be here.

00:01:47.940 --> 00:02:12.860
Yes, I'm happy to have you here. It's going to be a super fun data science topic. You've got a really cool project over at CodeCut.ai. And one of our listeners reached out and said, you have Quinn on because she's doing amazing stuff over at CodeCut.ai. And I'm really getting a lot of value out of it. And I'd love to hear more about this project and maybe dive into some of the topics there.

00:02:12.900 --> 00:02:14.600
So we're going to have a really great time talking about that.

00:02:14.800 --> 00:02:18.060
But before we get to those, really quick introduction for everyone.

00:02:18.900 --> 00:02:19.200
Who are you?

00:02:19.560 --> 00:02:19.700
Yeah.

00:02:20.160 --> 00:02:20.660
Hi, everybody.

00:02:21.160 --> 00:02:22.060
I'm Khuyen Tran.

00:02:22.300 --> 00:02:24.960
I'm a developer advocate at Nixler.

00:02:25.120 --> 00:02:35.320
I am also the founder of CodeCut, where I share daily tips on both LinkedIn and my news through my newsletter.

00:02:35.340 --> 00:02:49.020
and I send out short tips which have about data science and Python in the form of code snippets that is very easy to digest in two minutes or three times a week.

00:02:49.440 --> 00:02:50.240
Three times a week.

00:02:50.560 --> 00:02:50.680
Yeah.

00:02:50.820 --> 00:02:51.220
That's a lot.

00:02:51.560 --> 00:02:56.800
Yes, it's a lot of work, but I have been doing it for four years, I think.

00:02:57.160 --> 00:02:59.800
So I have been writing tips,

00:03:00.380 --> 00:03:04.980
writing Python snippets for like basically every day of the week.

00:03:05.280 --> 00:03:07.140
on the weekday for four years.

00:03:08.060 --> 00:03:09.000
Yeah, very fun.

00:03:09.180 --> 00:03:11.160
And you also have longer form articles there.

00:03:11.560 --> 00:03:12.340
Yes, that is correct.

00:03:12.600 --> 00:03:19.200
I also enjoy writing long form articles that dive deeper into open source.

00:03:19.720 --> 00:03:26.640
So majority of the time, like 95% of the time, I write about open source, Python data science related tools.

00:03:26.760 --> 00:03:27.460
So very specific.

00:03:28.200 --> 00:03:39.220
And I like to really explore how, you know, what should data scientists use this tool and how they use it.

00:03:39.600 --> 00:03:44.660
And my assumption for every article is data scientists are very busy.

00:03:45.010 --> 00:03:54.680
And if they only have five minutes to read this article, they will be able to get some takeaway from this tool and be able to apply right away.

00:03:55.100 --> 00:04:10.780
So you will see that as a common theme for snippets, micro snippets, as for a newsletter, like very short, very easy to digest, as well as article, even though it's long form, but also very, like if they want to, they can skim it, get something out of it.

00:04:10.840 --> 00:04:19.700
Or if they really want to like die differ, you can sit down and like call along and most will work for getting out of it.

00:04:19.880 --> 00:04:20.560
Yeah, I agree.

00:04:20.739 --> 00:04:27.160
I read a bunch of your articles and I think you can certainly get it a lot even if you just have only time to skim them.

00:04:27.340 --> 00:04:29.640
I learned a couple of extra new tools.

00:04:29.880 --> 00:04:32.140
I think that we're going to have a lot of fun to talk about as well.

00:04:32.420 --> 00:04:35.520
So how do people get your code snippets?

00:04:35.550 --> 00:04:37.460
Is that through your newsletter or how you do that?

00:04:37.740 --> 00:04:41.840
Yeah, people get my code snippets through my newsletter.

00:04:42.520 --> 00:04:47.620
And if you go to the front page, see if you find how it looks like.

00:04:47.920 --> 00:04:49.040
Yes, that's how it looks.

00:04:49.480 --> 00:04:55.680
So just for the audience who's listening, so the form of my newsletter is I would.

00:04:55.920 --> 00:05:01.120
So I would extract some specific feature out of the tool, right?

00:05:01.500 --> 00:05:09.680
Because if one tool can have many features and you don't want to talk about all the features in one code snippet, it will be really difficult to digest.

00:05:10.280 --> 00:05:11.420
So I pick one feature.

00:05:11.720 --> 00:05:14.540
I compare it with something that people already know.

00:05:15.020 --> 00:05:42.180
For example, in the screen we see we are comparing between a regular expression, X library and DFLIP and we try I want to compare something people already know, something that is less and all, to highlight okay, we see the typical problem with the tool that people already know and here's a solution and this tool offers the solution and so that's through CoSnipit.

00:05:42.400 --> 00:05:55.780
My philosophy when it comes to teaching people is it's better to show than to So I put a lot of effort into making it very easy for people to, when they look at the code snippet, they can understand.

00:05:56.360 --> 00:05:58.080
But of course, there's supported text.

00:05:58.440 --> 00:06:02.940
So if you scroll down a bit more, you can see the format.

00:06:04.920 --> 00:06:06.440
Yeah, we see the problem solution.

00:06:06.700 --> 00:06:09.800
The problem is, I will just read it out loud here.

00:06:09.920 --> 00:06:20.820
Red X preprocessing achieves exact matching but fails completely on typos like iPhone 14 Pro with like two double R max.

00:06:22.020 --> 00:06:32.020
Delusion definitely provides similarity scoring that tolerates typos and character variations, enabling approximate matching where Red X fails.

00:06:32.540 --> 00:06:38.420
And they can view the full article fail on, but it needs to be digested within the newsletter.

00:06:38.440 --> 00:06:44.040
Yeah, I think you could probably read that and get a good bit of information out of that in like one minute.

00:06:44.240 --> 00:06:44.780
That's really nice.

00:06:45.040 --> 00:06:51.260
And the idea you're highlighting here is like, sure, you can search if you're doing data science, text, NLP type of stuff.

00:06:51.620 --> 00:06:54.260
If you search with regular expressions, you might find things.

00:06:54.700 --> 00:07:05.000
But what if the spacing is different between them or somebody puts a comma or they put iPhone 14 without a space between the 14 and the iPhone, right?

00:07:05.100 --> 00:07:08.080
Like all those things are really tricky to catch every variation.

00:07:08.360 --> 00:07:13.460
So there's better tools like DFLIP, which we'll probably talk about again later in an article, right?

00:07:13.640 --> 00:07:16.640
And in the article, I highlight a lot more tools.

00:07:16.780 --> 00:07:19.200
So it's from like REC-X to DFLIP.

00:07:19.430 --> 00:07:23.040
And then if you want to like even better, then fuzzy matching, right?

00:07:23.760 --> 00:07:28.320
And then if even you want semantic capture, then that's another tool.

00:07:29.360 --> 00:07:36.540
And then, of course, you can go down all the spaCy route and into LLMs and like the whole spectrum, right?

00:07:37.180 --> 00:07:41.420
But just knowing about this, because sometimes you don't want full machine learning.

00:07:41.620 --> 00:07:44.500
You just want kind of like regular expressions, but not so hard.

00:07:44.800 --> 00:07:45.120
That's correct.

00:07:45.220 --> 00:07:46.840
Like something that gets the job done.

00:07:47.980 --> 00:07:56.920
To me, the iNewTool is something that works right out of the box without a lot of boilerplate code and not too many dependencies.

00:07:57.640 --> 00:07:58.840
Yeah, that's really, really important.

00:07:59.140 --> 00:08:02.780
So let's talk about the origins of CodeCut.ai.

00:08:03.160 --> 00:08:03.900
Why did you start it?

00:08:04.140 --> 00:08:10.140
So I started when I was in college, so four years.

00:08:11.560 --> 00:08:14.860
So I started to, I didn't start the website.

00:08:15.000 --> 00:08:16.920
So I started sharing my tips first.

00:08:17.280 --> 00:08:19.120
I started on LinkedIn, right?

00:08:19.320 --> 00:08:25.720
So I make a commitment to myself that I'm going to, so I initially, I write a lot of articles.

00:08:26.560 --> 00:08:31.220
I push out two to three articles on ProWords Data Science every week.

00:08:31.600 --> 00:08:32.860
And I make the commitment.

00:08:32.919 --> 00:08:34.520
I want to do that every week.

00:08:34.900 --> 00:08:38.380
And then I was not very active on LinkedIn.

00:08:38.760 --> 00:08:41.460
And then I read a book called Share Your Work.

00:08:41.680 --> 00:08:46.320
And it said, know how messy your work is, you should just share it.

00:08:46.760 --> 00:08:49.560
And I was very into open source tools.

00:08:49.880 --> 00:08:54.200
And I often just sent a message to my friends and said, hey, check this out.

00:08:54.260 --> 00:08:54.920
This is so cool.

00:08:55.820 --> 00:08:58.780
And I was like, what if I could share it with more people?

00:08:59.240 --> 00:09:05.200
So I started to, you know, put out some of the things that I'm excited about on LinkedIn.

00:09:05.760 --> 00:09:07.520
And initially, I was so afraid.

00:09:07.620 --> 00:09:09.340
People were like, what are you talking about?

00:09:09.480 --> 00:09:10.820
You don't know what you're talking about.

00:09:11.180 --> 00:09:11.400
Yeah.

00:09:11.780 --> 00:09:14.340
But people are also very excited about it.

00:09:14.430 --> 00:09:16.260
And I was like, oh, great.

00:09:16.480 --> 00:09:18.400
I shared something I'm excited about.

00:09:18.470 --> 00:09:22.020
And I have some other people and everybody excited about the tool.

00:09:22.320 --> 00:09:22.960
I love that.

00:09:23.440 --> 00:09:24.480
So I keep doing it.

00:09:24.680 --> 00:09:26.420
Initially, I do it like every day.

00:09:26.600 --> 00:09:28.620
So seven days per week, share every day.

00:09:29.020 --> 00:09:31.460
Later, I was like, okay, I'll give myself the weekend off.

00:09:32.230 --> 00:09:35.280
But I started to do, I think, over 500 tips.

00:09:35.570 --> 00:09:38.200
And then people was like, where can I find the old one, right?

00:09:38.280 --> 00:09:47.540
Because if you want to, let's say, if you are interested in machine learning tools or data processing tools, how do you find it on LinkedIn?

00:09:48.260 --> 00:09:50.040
There's no way for you to categorize.

00:09:50.340 --> 00:09:55.400
So I started to go back to most of my, it's there's so many.

00:09:55.430 --> 00:09:58.600
So I try as many as I can, put it into a website.

00:09:58.900 --> 00:10:01.820
So it was at the time I just find like some domain.

00:10:02.000 --> 00:10:03.200
It's called mass data simplified.

00:10:03.880 --> 00:10:07.740
And then I just put a bunch there and then I send out some newsletter.

00:10:08.000 --> 00:10:10.840
So very, very not Polish at all.

00:10:11.280 --> 00:10:13.980
And I just want to have a place to capture it.

00:10:14.400 --> 00:10:22.720
And then later I figure out that people was, a lot of time people do have typo when they type because it's very long URL.

00:10:22.760 --> 00:10:29.020
So I try to make it something very short and actually capture what I will do in cold cut.

00:10:29.360 --> 00:10:30.520
So it becomes cold cut.

00:10:30.820 --> 00:10:30.960
Yeah.

00:10:31.150 --> 00:10:32.540
I like the aesthetic of it.

00:10:32.640 --> 00:10:33.240
It looks nice.

00:10:33.700 --> 00:10:36.020
It's got these soft, warm colors.

00:10:36.560 --> 00:10:36.900
Thank you.

00:10:37.240 --> 00:10:37.360
Yeah.

00:10:37.420 --> 00:10:41.340
I try to keep everything kind of like a cotton candy.

00:10:41.520 --> 00:10:42.420
So like blue and pink.

00:10:42.840 --> 00:10:42.920
Yeah.

00:10:43.360 --> 00:10:43.440
Yeah.

00:10:43.610 --> 00:10:44.800
Cotton candy definitely comes through.

00:10:44.810 --> 00:10:45.940
I can see that for sure.

00:10:46.220 --> 00:10:48.840
What platform did you use to build it?

00:10:49.040 --> 00:10:49.580
I use WordPress.

00:10:50.620 --> 00:10:50.840
Nice.

00:10:51.040 --> 00:10:58.720
So for articles, I'm creating a workflow where basically I write all my articles in, you know, Quarto, like DocuS.

00:10:58.720 --> 00:10:59.280
Yeah, yeah, yeah.

00:10:59.580 --> 00:11:03.680
I realized that, so I write and also I run my code in Quarto.

00:11:04.340 --> 00:11:11.380
And then I use a WordPress API to push it to my article in blog.

00:11:11.760 --> 00:11:12.980
So I do a lot.

00:11:15.199 --> 00:11:20.640
It's easier than, and I don't use a WordPress editor to create the article.

00:11:20.960 --> 00:11:24.400
I use VS Code through QMD.

00:11:25.020 --> 00:11:29.180
But for the aesthetic, why I like progress because I can like drag and drop.

00:11:29.330 --> 00:11:31.480
And I'm not a front-end developer,

00:11:31.780 --> 00:11:32.680
but it works for me.

00:11:32.680 --> 00:11:32.780
Yeah.

00:11:33.320 --> 00:11:34.060
You know, it's interesting.

00:11:34.060 --> 00:11:43.480
I think a lot of people who are developers get hung up feeling like they have to create their website in the same language or technology that they're an expert in.

00:11:44.400 --> 00:11:50.700
You know, if you're a Python developer, you're like, well, how do I create a website in Python for my blog or, you know, whatever.

00:11:50.820 --> 00:12:23.820
language, right? But I think there's a lot of value in just saying like, it's just a tool, I'm just going to pick it and it's going to be great. Like for example, I had for a long time, I had my stuff in WordPress under my own domain for my blog and other things. And I finally decided to move on to Hugo, but Hugo is also not Go. It's not Python, it's Go. And it's just build static sites. And I think it's really, you know, it's good if you know the technology, but it's It's certainly not something I think people should get overly hung up on because you lose out on good tools that way, right?

00:12:24.200 --> 00:12:24.900
Yeah, exactly.

00:12:25.040 --> 00:12:28.620
And I mean, you can learn, like, you can learn any language, right?

00:12:28.640 --> 00:12:33.040
If you know one language, you can learn, you're kind of guessing another, especially now with AI.

00:12:33.959 --> 00:12:35.740
Yeah, that's such an interesting topic.

00:12:35.900 --> 00:12:39.180
I do think that's actually really changed a lot of things.

00:12:39.420 --> 00:12:43.620
It's like, well, I could work with this, but I know I'll get stuck on something.

00:12:44.260 --> 00:12:47.700
And now you can just ask an agentic AI, like, I'm stuck on this.

00:12:48.530 --> 00:12:49.620
Okay, here you go, you know?

00:12:49.670 --> 00:12:55.140
And even if it's not perfect, it really, really helps handle, juggle different types of technology.

00:12:55.150 --> 00:12:56.060
Yes, exactly.

00:12:56.400 --> 00:12:57.220
Yeah, super cool.

00:12:57.540 --> 00:12:59.020
So tell me more about this Quarto thing.

00:12:59.400 --> 00:13:02.140
I didn't intend to talk about this, but I find it really interesting.

00:13:02.600 --> 00:13:03.960
Do you write in Markdown?

00:13:04.140 --> 00:13:04.920
Do you write in HTML?

00:13:05.160 --> 00:13:06.680
What do you write in and then publish?

00:13:07.060 --> 00:13:07.560
Yeah, okay.

00:13:07.690 --> 00:13:08.800
So I write in Quarto.

00:13:10.000 --> 00:13:11.040
It's in Markdown, right?

00:13:11.120 --> 00:13:16.280
I told somebody who doesn't know it's in Markdown, but it's basically really similar to.md.

00:13:16.860 --> 00:13:20.220
The only difference is you can execute the code.

00:13:20.560 --> 00:13:27.020
So my really favorite stack is in VS Code.

00:13:27.550 --> 00:13:34.000
I have Quarto on the left side, and then I open a.qmd file.

00:13:34.220 --> 00:13:36.700
People can just imagine it's like a.qmd file.

00:13:37.480 --> 00:13:40.100
But you can click the button and you can execute.

00:13:40.240 --> 00:15:06.200
so it's very similar to a notebook right but I like it I really enjoy running in markdown and it's just like a very clean right compared to a notebook it's a big QMD you think can think of like a markdown notebook just markdown and you can execute the code and this and then so after I have the image, I have the code, everything, I will, so I create some Python functions to clean it up a bit. Now, like, for example, if there's some cell that I roll, I don't want to show it on WordPress, on my website, I will say echo is false, right? It's just like a comment, Python comment on the top of the cell, as you will not show in the website, which is great. And then I can just run publish to WordPress and it's publish to WordPress. What is nice about it is let's say later some of the content is I want to change let's say in three articles I mentioned something like a link to something but now it's broken. So what I can do is I can just like you know click search by all the instances of it, update it and then I run the function sync to WordPress and then it will sync and hey, I don't need to manually go through each of it.

00:15:07.000 --> 00:15:07.940
Yeah, that's really nice.

00:15:08.080 --> 00:15:10.500
And it'll just fix all the articles that needed to be changed.

00:15:10.820 --> 00:15:11.300
Yeah, okay.

00:15:13.240 --> 00:15:15.720
This portion of Talk Python To Me is brought to you by Sentry.

00:15:16.660 --> 00:15:24.700
Over at Talk Python, Sentry has been incredibly valuable for tracking down errors in our web apps, our mobile apps, and other code that we run.

00:15:25.420 --> 00:15:34.020
I've told you the story how more than once I've learned that a user was encountering a bug through Sentry and then fix the bug and let them know it was fixed before they contacted me.

00:15:34.460 --> 00:15:35.300
That's pretty incredible.

00:15:36.000 --> 00:15:42.240
Let me walk you through the few simple steps that you need to add error monitoring and distributed tracing to your Python web app.

00:15:42.880 --> 00:15:50.480
Let's imagine we have a Flask app with a React front end and we want to make sure there are no errors during the checkout process for some e-commerce page.

00:15:51.280 --> 00:15:55.780
I don't know about you, but anytime money and payments are involved, I always get a little nervous writing code.

00:15:56.660 --> 00:15:59.120
We start by simply instrumenting the checkout flow.

00:15:59.560 --> 00:16:06.000
To do that, you enable distributed tracing and error monitoring in both your Flask backend and your React frontend.

00:16:07.080 --> 00:16:13.460
Next, we want to make sure that you have enough context that the frontend and backend actions can be correlated into a single request.

00:16:14.660 --> 00:16:17.000
So we enrich a Sentry span with data context.

00:16:17.600 --> 00:16:22.940
In your React checkout.jsx, you'd wrap the submit handler in a Sentry start span call.

00:16:23.420 --> 00:16:25.460
Then it's time to see the request live in a dashboard.

00:16:25.860 --> 00:16:27.480
We build a real-time Sentry dashboard.

00:16:28.320 --> 00:16:37.480
You spin up one using span metrics to track key attributes like cart size, checkout duration, and so on, giving you one pain for both performance and error data.

00:16:38.560 --> 00:16:38.840
That's it.

00:16:39.060 --> 00:16:46.080
When an error happens, you open the error on Sentry, and you get end-to-end request data and error tracebacks to easily spot what's going on.

00:16:47.020 --> 00:16:52.060
If your app and customers matter to you, you definitely want to set up Sentry like we have here at Talk Python.

00:16:52.699 --> 00:17:24.020
Visit talkpython.fm/sentry and use the code TALKPYTHON, all caps, just one word, that's talkpython.fm/century code talkpython thank you to century for supporting the show notebooks are awesome and the idea of notebooks are you know they really change the game i think a lot but you don't necessarily want to see all of that when your your goal is mostly writing right like you don't necessarily need to see all the import statements if you're only going to focus on one cell worth of code

00:17:24.130 --> 00:17:25.980
and it's not about the import, right?

00:17:26.260 --> 00:17:31.920
Right, especially when my goal is to make it as easy as possible for data scientists to skip.

00:17:32.210 --> 00:17:33.080
And you know, when you skip,

00:17:33.220 --> 00:17:34.820
it's like a block of code,

00:17:34.980 --> 00:17:36.920
you're like, okay, I skip, I'm done.

00:17:37.140 --> 00:17:39.080
Like, I'll read this the next time.

00:17:39.340 --> 00:17:44.840
But my goal is always raise small code snippet and highlight the core features of the tool.

00:17:45.180 --> 00:17:49.940
And a lot of time, like you need to hide the unnecessary code, right?

00:17:50.300 --> 00:17:52.020
in order for that to happen.

00:17:52.560 --> 00:17:53.960
Yeah, yeah, I totally agree.

00:17:54.600 --> 00:17:59.740
People can get hung up on completeness and it really takes away from the essence of just like skimming it.

00:18:00.740 --> 00:18:11.980
And also I think that this workflow, it sounds like this is one of the things that made it possible for you to do this frequently, like three, four times a week instead of getting overwhelmed, right?

00:18:12.200 --> 00:18:17.640
Yeah, I really need to learn so many tricks in order to, I guess it's a good thing, right?

00:18:17.720 --> 00:18:19.100
It pushed me to be more productive.

00:18:19.420 --> 00:18:25.000
Like I learned a bunch of shortcuts because, you know, without shortcuts, I cannot get things done quickly.

00:18:25.440 --> 00:18:27.100
So I know a lot of these code shortcuts.

00:18:28.540 --> 00:18:31.240
And like I use a text expansion tool.

00:18:31.660 --> 00:18:32.760
It's called Expansal.

00:18:32.930 --> 00:18:34.320
And it's game changer.

00:18:34.470 --> 00:18:36.820
I can like, you know, like view the code.

00:18:36.980 --> 00:18:37.740
This article, right?

00:18:37.900 --> 00:18:45.180
If you can just colon, doc, something, something, like two words, and then it's expand the whole text.

00:18:45.660 --> 00:18:47.120
And then you can fill in the blank.

00:18:47.820 --> 00:18:54.960
I need to learn multiple tricks and also just automate things is how I can get it out.

00:18:55.340 --> 00:19:11.580
But yeah, what I still find is, so by doing that, I can actually focus on the essence of the blog, which is to make it as easy as possible to digest as well as researching, which is very important.

00:19:11.980 --> 00:19:12.820
Yeah, absolutely.

00:19:13.060 --> 00:19:14.420
I love your philosophy here.

00:19:14.600 --> 00:19:17.620
I can see why the site is popular.

00:19:18.180 --> 00:19:21.720
And the show your work, I think that's a great philosophy as well.

00:19:21.900 --> 00:19:25.960
It's like, get it out there even if it's messy and get it out there even if it's incomplete, right?

00:19:26.080 --> 00:19:26.600
That's the idea?

00:19:27.080 --> 00:19:27.720
Yes, exactly.

00:19:27.850 --> 00:19:32.340
And I really do recommend it for especially people who try to find a job, right?

00:19:33.340 --> 00:19:40.140
At the time, I kind of like another side effect of it is you show people what you know.

00:19:40.180 --> 00:19:46.120
because so many people, they know a lot, but they don't share, right?

00:19:46.520 --> 00:20:00.380
And if you let employers to find you by guessing what you know or look at your resume, it's very hard because now with AI, everybody has very polished, very nice resume.

00:20:00.460 --> 00:20:03.200
So why should they choose you over another person?

00:20:03.560 --> 00:20:10.180
But by showing your work, by showing even the messy one, right, They will be able to see, okay, this is what they're interested in.

00:20:10.460 --> 00:20:12.060
This is what makes them excited about.

00:20:12.150 --> 00:20:13.360
And this is what they know.

00:20:13.720 --> 00:20:17.840
Then they will be able to imagine how they can use you in their company.

00:20:18.290 --> 00:20:29.840
And that's how, because of me sharing my articles as well as LinkedIn posts early on when I was in college, I was able to get multiple internships in data science.

00:20:30.360 --> 00:20:31.220
Yeah, super neat.

00:20:31.320 --> 00:20:37.080
And, you know, you're in developer relations and I think there's a strong communication aspect of that as well.

00:20:37.230 --> 00:20:41.420
And this is just another example of like, yeah, you want to hire me for this thing?

00:20:41.520 --> 00:20:42.620
I'm already doing it, right?

00:20:42.840 --> 00:20:48.360
Like one of my first important jobs I got, I was doing a lot of speaking at user groups and meetups.

00:20:48.550 --> 00:20:50.860
They weren't called meetups then because meetup.com didn't exist.

00:20:51.040 --> 00:20:53.140
But, you know, they were meetups.

00:20:53.380 --> 00:20:59.000
And I got a message from a company and they said, hey, we saw you talking to this place and that place.

00:20:59.090 --> 00:21:00.180
And you're doing that for free.

00:21:00.260 --> 00:21:02.480
we'd pay you to do this if you want to do this for a job.

00:21:02.660 --> 00:21:03.420
I'm like, great.

00:21:04.300 --> 00:21:05.060
Where do I sign up?

00:21:05.140 --> 00:21:06.160
I didn't even have to apply.

00:21:06.270 --> 00:21:07.200
They just reached out to me.

00:21:07.640 --> 00:21:12.000
And the timing was perfect because I had quit my longtime job a week before.

00:21:12.210 --> 00:21:14.380
And I'm like, okay, well, I was about to start looking for a new job.

00:21:14.510 --> 00:21:18.780
But I guess you look for a new job after you quit your job.

00:21:20.600 --> 00:21:21.280
That's very brave.

00:21:21.400 --> 00:21:23.380
Were you like intended to take a break or something?

00:21:24.140 --> 00:21:26.380
No, I was not as brave as it sounded.

00:21:26.440 --> 00:21:33.580
I am my wife got her PhD and finished and she was getting her first professor job on the other side of the country.

00:21:33.960 --> 00:21:42.360
And so I was like, well, I'll wait till we get there and look for a job because it was, you know, San Diego to New Jersey level of travel.

00:21:42.400 --> 00:21:45.180
It was far. Right. So I figured I'll find something there.

00:21:45.400 --> 00:21:46.880
I see. And then you got a new job.

00:21:47.260 --> 00:21:54.780
Yeah. I think I'd quit my job, but I was still working for a month, you know, because I knew I was going to be moving in a while.

00:21:54.900 --> 00:21:58.600
And so, like, okay, guys, I'm leaving in a month, six weeks or whatever.

00:21:58.820 --> 00:22:00.240
And about that time, people reached out.

00:22:00.380 --> 00:22:01.820
So it was a perfect, perfect deal.

00:22:02.120 --> 00:22:02.400
I see.

00:22:02.520 --> 00:22:06.620
But just like you said, it's because of the stuff I was doing out in public, right?

00:22:06.880 --> 00:22:07.160
Right.

00:22:07.500 --> 00:22:07.580
Yeah.

00:22:08.280 --> 00:22:08.420
Okay.

00:22:08.600 --> 00:22:09.440
So let's dive in.

00:22:09.760 --> 00:22:11.820
Let's dive into CodeCut here.

00:22:12.340 --> 00:22:16.020
And the idea I thought is maybe we could just go through a handful of articles.

00:22:16.860 --> 00:22:17.500
We picked 10.

00:22:17.620 --> 00:22:19.520
I don't know how much time we have to go through all of them.

00:22:19.540 --> 00:22:20.820
We probably can get through all of them.

00:22:20.880 --> 00:22:24.800
But I think this will give people an idea of what they can get from CodeCut.

00:22:24.900 --> 00:22:28.940
But also, I just think there's a bunch of interesting data science ideas and tools.

00:22:29.360 --> 00:22:29.500
Yeah.

00:22:29.700 --> 00:22:31.260
Kind of like that diff lib that we talked about.

00:22:31.560 --> 00:22:34.640
So I think it'll be a good blend of that type of stuff to talk about.

00:22:35.040 --> 00:22:42.080
So let's start with an article called Goodbye pip and Poetry, Why uv Might Be All That You Need.

00:22:42.420 --> 00:22:46.100
So tell us about this and then we can dive in a bit.

00:22:46.240 --> 00:22:52.980
Yeah, so I think a lot of people have heard of uv, which is like dependency management tool.

00:22:53.360 --> 00:23:02.900
But let me, for people who don't know about it, just kind of give some quick reason why uv is, might be something that you want to look into.

00:23:03.660 --> 00:23:07.440
So a lot of data scientists know conda and no peep, right?

00:23:07.740 --> 00:23:09.560
I think poultry is a little bit less common.

00:23:10.740 --> 00:23:18.420
But for a while, poultry is like a modern tool that allows you to manage so many things, right?

00:23:18.640 --> 00:23:22.140
Like dependency management and virtual environment.

00:23:22.740 --> 00:23:24.940
And you can handle.

00:23:25.600 --> 00:23:27.880
Anyway, so there's a lot of things in poultry.

00:23:27.930 --> 00:23:35.340
But something that I didn't like about poultry is it's pretty slow for dependency management.

00:23:35.780 --> 00:23:38.640
But when it comes to uv, it's quick, airy.

00:23:38.840 --> 00:23:40.220
like it replaced many things.

00:23:40.600 --> 00:23:43.440
And even if you are using pip, you don't want to learn new tool.

00:23:43.840 --> 00:23:49.540
Basically, you can just use uv pip install, something, something, and you have a speed boost.

00:23:51.740 --> 00:24:05.200
And yeah, so I grow an entire article about uv and I also compare it with the existing tool to give people some motivation on switching it to uv.

00:24:05.560 --> 00:24:07.540
It's so easy to switch, so why not?

00:24:07.860 --> 00:24:09.620
Yeah, I think I am a huge fan of uv.

00:24:10.010 --> 00:24:13.480
I actually just interviewed Charlie Marsh for his next project, pyx.

00:24:13.940 --> 00:24:14.460
Oh, nice.

00:24:14.750 --> 00:24:15.760
Two days ago, yeah.

00:24:16.060 --> 00:24:18.040
So uv is going to get even better.

00:24:18.680 --> 00:24:24.700
I just pulled up the performance story for uv compared to poetry and Pipsync.

00:24:24.750 --> 00:24:30.160
And yeah, it's, what is that, 20 times faster than poetry and way faster than everything else.

00:24:30.620 --> 00:24:31.060
Insane.

00:24:31.300 --> 00:24:33.160
Yeah, it's Rust because of the Rust.

00:24:33.820 --> 00:24:45.000
I think Rust and then also they just rethought the caching and other, they just, it's Rust plus a bunch of new ideas that came together to make it work really, really well.

00:24:45.220 --> 00:24:48.780
And honestly, I feel a little bit, I feel a little bit bad for the other tools.

00:24:49.080 --> 00:24:51.860
Like I'm a big fan of pip-tools and PIPX.

00:24:52.720 --> 00:24:52.960
Me too.

00:24:53.240 --> 00:24:55.400
And, you know, those things are really great.

00:24:55.620 --> 00:24:58.220
And we'll come back and talk about them a bit, I think, as well.

00:24:58.360 --> 00:25:02.820
But I think those tools laid the foundation for what uv is doing.

00:25:03.420 --> 00:25:05.640
And uv sort of naturally brought these together.

00:25:05.840 --> 00:25:12.620
But whenever I think of the contributors and maintainers of those projects, I feel a little bit bad because they're not getting as much love as they used to.

00:25:12.760 --> 00:25:13.640
But they're still great.

00:25:13.820 --> 00:25:16.000
But uv is definitely making a splash.

00:25:16.480 --> 00:25:18.360
Yeah, that's a good way to think about it.

00:25:18.960 --> 00:25:21.300
I get excited about new tools very quickly.

00:25:21.560 --> 00:25:28.900
And I don't often think about how the maintainers of the old, the tools that are less popular think of something good.

00:25:28.980 --> 00:25:32.380
Yeah, it's the natural way of things, I think.

00:25:32.540 --> 00:25:33.960
But it's also tough.

00:25:34.420 --> 00:25:35.780
So the speed is important.

00:25:35.900 --> 00:25:47.240
One thing I think is interesting, while I think this is especially interesting for data science, and you touched on this already, is I come more from the web API side of Python, I would say.

00:25:47.490 --> 00:25:49.380
And over there, it's been pip all day long.

00:25:49.640 --> 00:25:50.660
It's been pip the whole time.

00:25:51.280 --> 00:25:59.900
But in the data science side, it's really largely been Conda, Anaconda distributions, that kind of thing, Conda environments.

00:26:00.480 --> 00:26:03.280
there's been kind of this separation.

00:26:03.890 --> 00:26:06.300
And obviously those are all pulling from the same projects.

00:26:06.480 --> 00:26:08.320
They're all on GitHub and so on.

00:26:08.320 --> 00:26:10.400
But like there has been a little bit of a difference.

00:26:10.640 --> 00:26:17.300
And I feel like uv has made a really big splash in data science and kind of bringing those two worlds back together.

00:26:17.740 --> 00:26:18.180
What do you think?

00:26:18.400 --> 00:26:19.060
Yeah, I agree.

00:26:19.270 --> 00:26:22.040
I actually have an article a long time ago.

00:26:22.400 --> 00:26:24.040
I think it's probably in Colcult still.

00:26:24.640 --> 00:26:27.540
It's called Peep versus Conduct versus Coal Tree.

00:26:28.240 --> 00:26:31.740
So I was trying to give a very fair comparison.

00:26:31.980 --> 00:26:33.640
I was in favor of poetry.

00:26:34.320 --> 00:26:36.620
But, you know, I compared everything.

00:26:37.560 --> 00:26:42.020
And something that I had, to be honest, I was not a fan of Condor.

00:26:43.280 --> 00:26:49.640
And after the comparison, I was not even more of a fan of Condor because I felt like it's very heavy.

00:26:49.980 --> 00:26:52.300
You can use, I think, Mini Condor, so it's quicker.

00:26:52.820 --> 00:26:58.880
But at the same time, it installs many dependencies that you didn't ask for.

00:26:59.060 --> 00:27:03.680
So it's kind of like a solution where you have a lot of dependencies out of the box, right?

00:27:04.160 --> 00:27:08.000
But I find that a lot of times you didn't ask for some dependencies installed.

00:27:08.100 --> 00:27:15.680
So you don't really have control over what's being installed, as well as the way that it solves dependencies or not.

00:27:16.720 --> 00:27:18.060
I find it's very slow.

00:27:19.620 --> 00:27:23.880
So, so poetry was better because, you know, it's cleaner.

00:27:23.950 --> 00:27:28.180
You can see like what you put in, you can see like everything in a file.

00:27:28.490 --> 00:27:30.400
Like there's a separate file, right?

00:27:30.520 --> 00:27:32.300
One for one is what?

00:27:33.140 --> 00:27:35.380
PyProject.com and one is a lot.

00:27:35.700 --> 00:27:37.280
You want to see all the sub dependencies.

00:27:38.040 --> 00:27:43.540
And now uv is to me is like that, but to like, like poetry, but better.

00:27:44.520 --> 00:27:47.300
The fact that it can run very fast.

00:27:47.460 --> 00:27:55.740
So one drawback of poetry was sometimes it's think very hard about and take a long time to solve, install new dependencies.

00:27:56.880 --> 00:28:18.080
And also uv replace X, you know, like it kind of like an all-in-one-place tool, which is, I think, very necessary, especially for, I mean, for everybody who use Python, but for data scientists, you know, they already have so many things going on and tell them to learn, you know, good practices.

00:28:18.410 --> 00:28:23.940
You know, let's say they want to upgrade, right, from Python 3.5 to 3.6, 3.7.

00:28:24.360 --> 00:28:28.620
To, you know, use other tools, you know, to do it, it seems like a lot.

00:28:28.780 --> 00:28:37.400
If you can just use one tool and then you can run it, like upgrading in one command line, then we're not.

00:28:37.640 --> 00:28:40.040
Yeah, 100%. I think it's great.

00:28:40.200 --> 00:28:44.000
And it has a lot of compatibility with previous workflows.

00:28:44.160 --> 00:28:52.540
For example, you can use uv pip install instead of using its project management thing, like with add and sync, right?

00:28:52.800 --> 00:28:55.800
So you don't necessarily have to adopt its style.

00:28:55.910 --> 00:28:59.120
You can just say instead of pip install, you can say uv pip install.

00:28:59.560 --> 00:29:07.560
One of the things that used to bother me, and I honestly just haven't looked for a while, about Ponda was coming from a non-data science side.

00:29:08.320 --> 00:29:13.240
Some of the libraries save requests or Flask or something like that.

00:29:13.520 --> 00:29:51.720
pyramid. Those were held back quite a bit because they try to make sure there's a compatibility between the versions that they ship through Conda, which is, I think that's good for data science or reproducibility. But when it comes to web frameworks, you've got to be super on top of updates in case there's a security vulnerability. You want to release that thing the day the vulnerability is announced. You want to upgrade your website because as soon as it's announced, people start scanning the internet for any website that could possibly be susceptible to that problem right and so like the web tools were held back a lot so that's i it's one of the reasons i never really

00:29:51.860 --> 00:30:09.740
embraced conda yeah but another now that you mentioned it another i i also found it is uh one thing i didn't like about conda is you know like there's let's say data scientists like pandas right if this pandas version is available then a lot of time like sometimes it's not available on conda That's one thing.

00:30:10.160 --> 00:30:14.580
But another thing is data scientists, they collaborate with other engineers.

00:30:15.220 --> 00:30:21.980
So as someone, they need to hand over to the engineers, like machine learning engineers, data engineers, to use their code.

00:30:22.460 --> 00:30:27.880
And I think in my previous company, they didn't use Conda.

00:30:28.180 --> 00:30:33.880
So for them to need to install Conda, there's a way for you from Conda to pip.

00:30:34.440 --> 00:30:40.220
But then the dependencies look very messy and it's not like a one-to-one translation.

00:30:40.460 --> 00:30:44.080
Sometimes you don't get the same environment.

00:30:44.680 --> 00:30:45.380
Sure, interesting.

00:30:45.700 --> 00:30:48.860
Not the trouble for handing over, right?

00:30:49.080 --> 00:30:52.900
And reproducible is a big thing when it comes to data science.

00:30:53.920 --> 00:30:55.780
And dependencies play a big part of it.

00:30:55.800 --> 00:31:02.380
So if you make it hard to reproduce the dependencies, then there will be some bugs.

00:31:02.400 --> 00:31:07.020
there will be some errors and even work silent errors.

00:31:32.400 --> 00:32:08.360
core pieces engineers need to deploy multi-agent systems now belong to everyone who builds on agency. You get robust identity and access management, so every agent is authenticated and trusted before it interacts. You get open, standardized tools for agent discovery, clean protocols for agent-to-agent communication, and modular components that let you compose scalable workflows instead of wiring up brittle glue code. Agency is not a walled garden. You'll Cisco, Dell Technologies, Google Cloud, Oracle, Red Hat, and more than 75 supporting companies.

00:32:08.890 --> 00:32:09.780
The goal is simple.

00:32:10.230 --> 00:32:17.440
Build the next generation of AI infrastructure together in the open so agents can cooperate across tools, vendors, and runtimes.

00:32:18.140 --> 00:32:21.980
Agencies dropping code, specs, and services with no strings attached.

00:32:22.620 --> 00:32:23.080
Sound awesome?

00:32:23.600 --> 00:32:27.180
Well, visit talkpython.fm/agency to contribute.

00:32:27.720 --> 00:32:31.120
That's talkpython.fm/A-G-N-T-C-Y.

00:32:31.700 --> 00:32:34.540
The link is in your podcast player's show notes and on the episode page.

00:32:35.280 --> 00:32:37.860
Thank you as always to Agency for supporting Talk Python To Me.

00:32:39.520 --> 00:32:43.180
Next article, let's talk about, I think this is a big one.

00:32:44.320 --> 00:32:46.380
Reproducibility, maintainability, that kind of thing.

00:32:46.700 --> 00:32:49.380
What you talked about there was kind of a good lead into it, right?

00:32:49.500 --> 00:32:58.640
It's like the production engineers need to make sure that what they're running runs the same as what the data scientists have tested and come up with.

00:32:58.780 --> 00:33:05.740
And if the situation is different, right, the runtime environment is different, well, maybe it's going to give different answers because of different versions or something.

00:33:06.960 --> 00:33:13.840
Yeah, exactly. And dependency is a big thing, but there's also other things that come into it, right, and we can talk about it too.

00:33:14.020 --> 00:33:18.040
Yeah, so what are some of the core ideas of reproducibility?

00:33:18.320 --> 00:33:42.580
Yeah, so reproducibility, I think, is, and at the heart of reproducibility is you want to, let's say, especially for data scientists, when they create code, right, create machine learning models, it depends on some, there's a lot when it packages dependencies, but also like depends on parameters that you use.

00:33:43.060 --> 00:33:51.180
and like, you know, even you use everything the same from experiment to experiment, it can produce slightly different accuracy.

00:33:51.640 --> 00:33:57.740
So you want to be able to, let's say one data scientist say, I got a 0.9 accuracy.

00:33:58.200 --> 00:34:01.580
Then they give it, head it over to their teammate to deploy.

00:34:01.940 --> 00:34:04.960
And then it's degrading the performance.

00:34:05.440 --> 00:34:07.200
It's no longer have a 0.9 accuracy.

00:34:07.340 --> 00:34:09.940
It probably can be, you know, without 0.8.

00:34:10.440 --> 00:34:24.419
And so reproducibility is very important in terms of, you know, you want people, if you produce some result, you want other people to be able to reproduce the same results so that your company can profit out of it.

00:34:24.580 --> 00:34:40.200
But another thing is choice, right? Let's say if you data center, you create something that is good, but then you hand it over and it's bad, then it reduces the choice from your co-workers.

00:34:40.960 --> 00:34:52.220
The third thing about it is, let's say if data scientists create some project and then later they want to reuse it, right? Like for another project, they cannot reproduce the same results.

00:34:53.120 --> 00:35:00.360
then it's kind of like throw it away, creating everything from scratch.

00:35:00.880 --> 00:35:02.460
So it also time consuming.

00:35:03.580 --> 00:35:08.400
And another big theme after producing, I think go hand in hand is maintainability.

00:35:09.280 --> 00:35:10.140
But yeah, you can go ahead.

00:35:10.260 --> 00:35:11.580
Yeah, no, I totally agree.

00:35:11.680 --> 00:35:15.140
The maintainability part is super important as well.

00:35:15.260 --> 00:35:17.640
And so what are some of the pieces that go into that?

00:35:17.680 --> 00:35:36.320
I mean, the first thing that comes to mind for me is pinning your dependencies, either through using something like uv init, uv add, uv sync, or just a requirements.txt file or pinning your requirements, you know, through some other means like with poetry, but somehow clearly documenting what's used.

00:35:36.360 --> 00:35:45.640
I think it can be easy for data scientists to just import some things in a notebook and then do a magic, well, uv pip install that right here and let's just keep going.

00:35:45.720 --> 00:35:48.180
But then like, why won't it run later, you know?

00:35:48.440 --> 00:35:51.020
Yeah, are you talking about maintainability or reproducibility?

00:35:51.280 --> 00:35:55.660
Well, I was thinking maintainability, but both, yeah.

00:35:56.120 --> 00:36:02.760
So maintainability, another thing is, another aspect that comes into maintainability is readability, right?

00:36:03.540 --> 00:36:06.100
And I think this is a big thing for data scientists.

00:36:06.620 --> 00:36:11.540
A lot of data scientists don't write readable code and modular code.

00:36:11.840 --> 00:37:05.240
what you will see is like a big chunk of code with like nested if else or using global variables inside a function or not using function at all and there's a lot of duplicate in the code and I mean that is great for quick experimentation like you want to get something out of it but at the same time it's create a lot of technical debt in terms of this multiple thing that leads to not readable, right? So, and I can go deeper, I just want to list it out, readability and then reproducibility. And readability, you want your code to be readable because data scientists collaborate with other engineers. And if your code, and also another problem I saw is data scientists, they cannot read their old code in like a couple of months.

00:37:05.240 --> 00:37:15.940
They forgot. They won't be right. They're really like, what did I write? And they spend quite bit of time to understand what they write and if they cannot understand or they don't trust it right

00:37:16.060 --> 00:37:20.460
if you don't understand in a full level you cannot trust it and you cannot use the next project

00:37:20.820 --> 00:37:42.060
a lot of times they write things from scratch again so readability also if your code is not written well readability and reproducibility you cannot it's harder to reproduce the same result because let's say global variables, you use global variables and it affects your code, then it's hard.

00:37:43.080 --> 00:37:49.380
You might introduce some external factors that make the code different the next time you run.

00:37:49.640 --> 00:37:52.040
So managing really is very important

00:37:52.480 --> 00:38:00.840
and that comes with, sorry, write readable code, version control, dependencies management, configuration management,

00:38:02.100 --> 00:38:06.100
meaning you don't want to hard code the values into your code.

00:38:06.240 --> 00:38:11.060
Yeah, this is a really great article here because it shows you so many tools and techniques, I think.

00:38:11.240 --> 00:38:11.800
Yeah, thank you.

00:38:12.140 --> 00:38:20.680
And I also, so writing a maintainable data science project has been my passion for a long period of time.

00:38:21.360 --> 00:38:23.960
And it actually has become a book like this.

00:38:24.180 --> 00:38:30.020
This is the article form, but I also recently wrote a book about this, finished a book about this.

00:38:30.200 --> 00:38:32.000
It's called Production Ready Data Science.

00:38:32.580 --> 00:38:33.480
Yeah, congratulations.

00:38:33.840 --> 00:38:34.800
That's amazing.

00:38:34.960 --> 00:38:35.980
When did you finish it?

00:38:35.980 --> 00:38:36.920
When did you publish it?

00:38:37.600 --> 00:38:38.880
Two months ago, I think.

00:38:39.100 --> 00:38:40.740
Okay, so really recently, yeah.

00:38:41.040 --> 00:38:41.680
Very recently.

00:38:42.020 --> 00:38:43.240
It took me quite a while.

00:38:43.500 --> 00:38:46.260
I have other materials because I've been writing about this.

00:38:47.440 --> 00:39:01.360
I have so many materials who put it together and also make it less in an article style, explaining more of the why before the how is also what I focus a lot on this book.

00:39:01.620 --> 00:39:03.060
Yeah, that's a super important part.

00:39:03.500 --> 00:39:10.380
Now, I am a huge fan of thinking a lot about readability and spending a lot of time on readability.

00:39:10.480 --> 00:39:11.940
And I agree with you.

00:39:12.200 --> 00:39:18.780
I think we're on the same page for sure on that one because if your code is not readable, that doesn't mean it can't be read.

00:39:18.780 --> 00:39:20.180
It just means it's harder to read, right?

00:39:20.700 --> 00:39:24.120
If your code is not readable, it's harder to maintain it.

00:39:24.160 --> 00:39:25.320
It's harder to see the bugs.

00:39:25.520 --> 00:39:26.120
It's harder to read.

00:39:26.220 --> 00:39:27.860
All the things that you've pointed out.

00:39:28.180 --> 00:39:39.900
And I think it's a little bit ironic that the notebook style of development that is meant to communicate, like it's supposed to be more communication compared to regular programming, right?

00:39:40.020 --> 00:39:41.720
It's got the markdown cells.

00:39:41.920 --> 00:39:42.540
It's got the pictures.

00:39:43.080 --> 00:39:46.200
It's got little tables for like df.head, that kind of stuff, right?

00:39:46.500 --> 00:39:52.960
It's natural way of programming it leads to less maintainable, reusable code, right?

00:39:53.080 --> 00:39:54.540
Because it does not encourage functions.

00:39:55.520 --> 00:40:02.680
It's really hard to do reuse if you don't think, oh, maybe I need to write a function in this cell, collapse the cell, and then use the function later.

00:40:02.950 --> 00:40:05.080
That happens, but not very much.

00:40:05.110 --> 00:40:09.480
I was doing some research for, or just looking around, really.

00:40:09.700 --> 00:40:14.140
Research is a little bit high, putting it in a high position compared to what it was.

00:40:14.180 --> 00:40:22.900
I was looking around for some examples, and I found this really cool JPL collection of notebooks for studying, I think, galaxies.

00:40:23.440 --> 00:40:26.700
like studying the brightness of galaxies and trying to understand things about them.

00:40:26.780 --> 00:40:28.820
And they had a bunch of cool notebooks in there.

00:40:28.940 --> 00:40:34.400
And they were like 1,500 lines of code and stuff in there.

00:40:34.780 --> 00:40:35.820
One function, one.

00:40:36.120 --> 00:40:36.460
Wow.

00:40:36.600 --> 00:40:42.480
I'm like, oh, that is probably, I mean, maybe this is necessary, but it's probably not necessary.

00:40:42.480 --> 00:40:43.560
And this is JPL, right?

00:40:43.660 --> 00:40:48.700
This is like a polished published thing, not just a random notebook I ran across, right?

00:40:48.980 --> 00:40:54.680
the Jet Propulsion Laboratory in Pasadena, which is, I consider them to be pretty amazing.

00:40:54.980 --> 00:40:57.640
So maybe speak through a little bit about that,

00:40:57.780 --> 00:41:01.420
like this maintainability thing in juxtaposition with notebook style.

00:41:01.860 --> 00:41:02.300
Yeah, definitely.

00:41:03.200 --> 00:41:03.660
That's the thing.

00:41:04.100 --> 00:41:11.060
Before, I think five years ago, I wrote an article that got very popular, but also a lot of controversy.

00:41:11.340 --> 00:41:17.720
It's called, I think, something about seven reasons why I switched from notebook to Python script or something.

00:41:18.660 --> 00:41:25.800
But so anyway, so the thing about Notebook is a lot of people argue, yeah, you can write functions.

00:41:26.240 --> 00:41:27.360
Like it's just Python, right?

00:41:27.360 --> 00:41:28.120
You can write functions.

00:41:28.170 --> 00:41:32.600
You can write whatever you want, just like a Python script.

00:41:32.960 --> 00:41:37.880
But the interactive style of it kind of discourages you from doing it.

00:41:37.960 --> 00:41:44.300
Like why should I write a function when I can just like see the result and then I build upon it, right?

00:41:45.440 --> 00:41:52.240
Because in Notable, what is so great about it is you can see the results and then you can build up upon it in the next cell, next cell, next cell.

00:41:52.470 --> 00:41:58.480
So people are less likely to build a function, which like if you create a function, then like it's hide inside a function.

00:41:58.680 --> 00:41:59.940
It's not execute the code.

00:42:01.100 --> 00:42:01.900
So that's one thing.

00:42:02.300 --> 00:42:10.200
Another thing problematic about Notable is it's encouraged hard coding, you know, like a lot of time.

00:42:10.560 --> 00:42:14.840
Because if you want to see the result, you want to put your value in there to see the result.

00:42:14.960 --> 00:42:21.020
But another thing is, a very big problem is cell execution, right?

00:42:21.580 --> 00:42:41.020
If you execute cell, the fact that it gives you the ability to execute in different orders is nice, but also a disadvantage in a way that if you run it in the wrong order, then it will, like, you can get some result right now that is different from result that you want to run.

00:42:41.380 --> 00:42:41.640
Right.

00:42:41.720 --> 00:42:47.060
If you forget to run a particular cell, you go back up, run that to refresh it, and then you skip back down.

00:42:47.460 --> 00:42:50.080
Something in the middle was important and you don't rerun it.

00:42:50.180 --> 00:42:51.540
That's probably not good.

00:42:51.880 --> 00:42:52.360
Yeah, exactly.

00:42:52.580 --> 00:42:59.680
And that's, I remember when I worked in notebook before, it just gave me a headache because I would run something.

00:42:59.810 --> 00:43:01.580
I said, oh, did I rerun this?

00:43:01.740 --> 00:43:03.620
Like, did I run that score or did I not?

00:43:03.900 --> 00:43:05.340
Just to make sure I'll rerun it.

00:43:05.520 --> 00:43:06.540
So it's something.

00:43:06.960 --> 00:43:13.200
And then later, when I come back to notebook, I was like, I'm not going to reuse this notebook again because I don't know what's going on here.

00:43:13.480 --> 00:43:13.600
Yeah.

00:43:13.960 --> 00:43:17.520
I don't want people to think that I'm completely anti-notebook.

00:43:17.700 --> 00:43:18.120
I'm not.

00:43:18.500 --> 00:43:22.140
But I do think that there are some techniques and some tips that you can use.

00:43:22.320 --> 00:43:35.180
So when I was riffing on functions, one thing I think you could do, and you touched on it as well, is you could take the parts of your code that you want to reuse and put that in a Python script next to your notebook and import it, right?

00:43:35.380 --> 00:43:36.160
And then you can use it.

00:43:36.460 --> 00:44:09.080
A lot of times, I think there's a bunch of cells in notebooks that don't really have to do with the presentation or the important part they're just there like well i need to load this thing or i need to like clean up that or or something and it has to go before what you actually want to show people you could put that in a script yeah and you could just show import it and then show the important part right it's more readable more reusable it's more modular like in all ways almost it's better yes i agree i the thing about yes i'm like notebook is great it's very

00:44:09.100 --> 00:44:41.320
good for presentation but i think the problem is a lot of time people use it more than what it's supposed to desire for which is i mean it's prototype right it's to uh showcase uh something it to to showcase it with um either non-technical or technical people it's not used for like everything and and i think that's a problem like a lot of the scientists use it for everything including uh ready production ready code and again that's another argument right like can you production ready code in notebook and Netflix did that.

00:44:41.520 --> 00:44:45.360
Netflix create production ready code in notebooks and that's great.

00:44:45.780 --> 00:44:46.960
Paper mill and all that stuff.

00:44:47.030 --> 00:44:47.160
Yeah.

00:44:47.440 --> 00:44:47.500
Yeah.

00:44:47.640 --> 00:44:49.580
That technology allows you to do it.

00:44:50.160 --> 00:44:57.720
I feel like it's still, but then Temtem is, it's a tool that if you use the right, then it will serve you.

00:44:57.960 --> 00:44:58.140
Yeah.

00:44:58.280 --> 00:44:59.180
It's, it's interesting.

00:44:59.380 --> 00:45:03.940
Speaking of tools, I know you've written about, talked a little bit about Marimo.

00:45:04.540 --> 00:45:05.580
What do you think about that?

00:45:05.700 --> 00:45:07.240
I think this is a really interesting one.

00:45:07.360 --> 00:45:13.280
I just did a sort of, I did a course called Just Enough Python and it's software engineering for data scientists.

00:45:13.840 --> 00:45:14.040
Nice.

00:45:14.160 --> 00:45:15.140
And I was trying, thanks.

00:45:15.340 --> 00:45:15.460
Yeah.

00:45:15.500 --> 00:45:21.520
And it's like, okay, a lot of themes that you talk about as well, like you should probably learn Git, you know, and so on.

00:45:22.060 --> 00:45:31.140
But one of the things I really struggled with was I really wanted to use Marimo as the foundation, but, you know, 90% or more data scientists use Jupyter.

00:45:31.520 --> 00:45:52.940
So I ended up using Jupyter, but I think Marimo actually might be a little bit better in terms of software engineering and a little bit better in terms of this order of operations you talked about, like, because Marimo tracks like, hey, this cell depends upon that cell. So if you rerun this one, we got to rerun that one first. It'll catch those kind of things. But you want to maybe talk about this real quick? Because I know you wrote about it a little

00:45:53.080 --> 00:47:21.620
bit. Yeah, I really like Marimo. I think it's great. It has been, so I was actually in the middle of writing the book, right? And I know that people, data scientists love Notebook and I don't want to be like, hey, let's just write Python script. But at the same time, I really think that Notebook is really hard to write production radical. And that's, you know, my book is about production radical. So how do you find the middle ground between, you know, an interactive version of Notebook and production radical? So Marimor came out and I dig deep into it. It solved a lot problems and first is a self-execution order right so the problem in notebook is let's say you cell one cell two cell three you change something in cell one for example you all run it but then you change something in cell one if you forgot to rerun cell three then um you know the result is not going to reflect what you have changed in cell one but with marimold it can detect the dependencies. And if you change cell 1 and cell 3 depend on cell 1, depend on the variable in cell 1, then it will execute it automatically, which is great. Another big thing is, you know, notebook, not disadvantage, notebook is JavaScript, right? So it's very big, unreadable, hard to, if you want to use it or hand it over, reuse it. It's really hard.

00:47:21.680 --> 00:47:28.860
Right. It's so common to get a Git conflict when you try to pull a new version just because the output has changed.

00:47:28.980 --> 00:47:31.040
And that shouldn't even be taken into account, right?

00:47:31.440 --> 00:47:33.480
And yeah, that shouldn't be taken into account.

00:47:33.880 --> 00:47:35.540
And also the output can be big.

00:47:36.040 --> 00:47:40.860
But with Marimode, not only just a Python script under the hood.

00:47:41.060 --> 00:47:42.660
So you have the...

00:47:42.720 --> 00:47:47.160
And what great thing about Python script is you can reuse it.

00:47:47.160 --> 00:47:49.480
You can import it in another Python script.

00:47:49.600 --> 00:47:51.940
but also for CI/CD, right?

00:47:53.199 --> 00:47:56.000
And you can write unit tests.

00:47:56.290 --> 00:48:01.600
You know, like with unit tests are important, but with in Notebook, you can write unit tests.

00:48:01.780 --> 00:48:04.220
There's a hacker out, but it's a hack.

00:48:05.320 --> 00:48:11.580
And sometimes people need to put their tests inside Notebook, which is not modular, right?

00:48:11.700 --> 00:48:17.220
It's not, it's make it very messy with code and then tests inside the same place.

00:48:18.140 --> 00:48:25.880
But if you write notebook that is Python script under the hood, then you can write unit tests and you can run it with pytest.

00:48:27.040 --> 00:48:27.500
Yeah, very cool.

00:48:27.660 --> 00:48:29.380
I think this is a neat one.

00:48:29.660 --> 00:48:36.060
I generally wanted to use it, but I'm like, but at the same time, I probably got to speak the same language of the people doing that.

00:48:36.460 --> 00:48:36.580
Exactly.

00:48:37.160 --> 00:48:37.620
Yeah, yeah.

00:48:38.280 --> 00:48:44.600
Another thing I want to talk about here, actually this maintainability article has just got so much good stuff in it.

00:48:44.740 --> 00:48:49.280
Something I think that might be new to folks is Hydra, right?

00:48:49.700 --> 00:48:54.520
Let's talk about this idea of managing configuration files with Hydra.

00:48:54.840 --> 00:48:56.600
Yeah, I love Hydra.

00:48:56.760 --> 00:49:03.260
So Hydra is developed by Facebook Research, and I think I use it.

00:49:03.560 --> 00:49:04.560
It has been my two goals.

00:49:04.800 --> 00:49:06.260
So I have some core tools.

00:49:06.360 --> 00:49:10.660
I go back for every data science project, and Hydra is one of them.

00:49:13.560 --> 00:49:26.140
I guess if you think about Hydra is a configuration management tool, you can write your configuration inside a YAML file, and then you can call things.

00:49:26.620 --> 00:49:33.100
You can access the variables inside the YAML file inside a Python script.

00:49:33.520 --> 00:49:34.440
That is nothing new.

00:49:34.510 --> 00:49:41.380
People know about there's a YAML muting library in Python that allows you to work with YAML.

00:49:41.680 --> 00:49:48.220
But something I like about HIDL a lot is reduce the boilerplate code.

00:49:48.620 --> 00:49:54.180
So you can just add an app like a decorator to your Python function.

00:49:54.520 --> 00:50:00.420
And then it will be able to access everything underneath inside the Python function.

00:50:00.920 --> 00:50:15.280
And instead of using a bracket notation, like for example, if to access a nested value, you might need to use mutable nested function, but instead you can use dot notation, which is very clean.

00:50:16.120 --> 00:50:17.220
Other things are,

00:50:17.880 --> 00:50:21.840
oh, you can, as your project getting bigger, right?

00:50:22.080 --> 00:50:35.700
I mean, for a small project, maybe a YAML is enough, but as your project getting bigger, let's say you have, you want to be able to use, especially in like data science experimentation, you want to use different values.

00:50:36.050 --> 00:50:38.300
You want to experiment with different way of processing.

00:50:38.700 --> 00:50:42.340
You want to experiment with different parameters for your models.

00:50:42.710 --> 00:50:43.680
And that can get messy.

00:50:43.810 --> 00:50:45.380
Your YAML file becomes very big.

00:50:45.740 --> 00:50:51.980
So a good way to handle this is you want to break it into smaller configuration.

00:50:53.160 --> 00:51:04.900
But if you want to do that without Hydra, then you need to write Python functions to access it, to composite it, to put it together, put the pieces of puzzle together.

00:51:05.600 --> 00:51:09.720
With Hydra, you can basically, everything is handled for you.

00:51:09.920 --> 00:51:14.640
So you can break it apart and then you can refer to different part of the pieces.

00:51:15.110 --> 00:51:20.260
You can, like in one YAML file, you can refer to the other part of the YAML file.

00:51:20.380 --> 00:51:21.580
It's kind of like an import, right?

00:51:21.710 --> 00:51:22.440
Import in Python.

00:51:22.980 --> 00:51:24.520
And you can override it.

00:51:24.940 --> 00:51:29.340
Another thing I realized, you can override the parameter from the command line.

00:51:29.720 --> 00:51:30.760
Yeah, that's a cool feature.

00:51:31.100 --> 00:51:35.300
Yeah, so you don't need to go back into the, because a lot of time you want to experiment.

00:51:35.420 --> 00:51:43.260
different parameters or inside the production environment and the development environment, you might use different parameters.

00:51:43.780 --> 00:51:53.180
And if you can override from the command line, which is used a lot in different platforms, then that will be amazing.

00:51:53.520 --> 00:51:54.560
Yeah, it's super neat.

00:51:54.720 --> 00:51:57.840
Basically, you provide a bunch of default values instead of hard coding them.

00:51:58.180 --> 00:52:03.940
And then if you need to override them, you can do that through the command line or you could just do it in code or whatever, right?

00:52:04.180 --> 00:52:04.720
Yeah, exactly.

00:52:05.160 --> 00:52:05.240
Yeah.

00:52:05.300 --> 00:52:05.780
Yeah, excellent.

00:52:06.080 --> 00:52:15.700
And you bring it all together here in your article, uv run process, so you got your Hydra, you got your uv run coming together, all that stuff.

00:52:15.900 --> 00:52:17.040
So you actually have a whole article.

00:52:17.540 --> 00:52:23.540
I originally started talking about it because it was in the maintainability section, but you have a whole article called Hydra for Python Configuration, right?

00:52:23.680 --> 00:52:30.680
Yeah, the other article is more like a high level, but then I have smaller articles that talk about each tool.

00:52:31.600 --> 00:52:31.860
Super.

00:52:32.140 --> 00:52:35.280
Okay, well, we're not making very good progress through this, but that's okay.

00:52:36.480 --> 00:52:37.640
Because these are really interesting topics.

00:52:38.740 --> 00:52:42.300
Another one that you talk a lot about is doing proper logging.

00:52:42.840 --> 00:52:46.020
And you recommend Log Guru, which I love Log Guru.

00:52:46.070 --> 00:52:46.940
I think it's really great.

00:52:46.950 --> 00:52:49.720
I used Log Book for a long time from Armin Roeneker.

00:52:50.120 --> 00:52:52.640
But then I've been slowly moving towards Log Guru.

00:52:53.080 --> 00:52:53.280
Nice.

00:52:53.800 --> 00:52:54.660
Yeah, I really like.

00:52:54.910 --> 00:53:00.620
So another thing about, you know, like a lot of data scientists, they use print, which nothing wrong with print.

00:53:01.940 --> 00:53:06.720
Like, in fact, you shouldn't use, I think it's overkill.

00:53:06.820 --> 00:53:08.440
You use print in a notebook, right?

00:53:08.840 --> 00:53:16.020
But when it comes to, like, if you want to run production ready code, if you have a bunch of prints, because a lot of times you had debugging prints, right?

00:53:16.500 --> 00:53:19.960
And if, yeah, you can go back and, like, delete them and everything.

00:53:20.500 --> 00:53:21.820
But wouldn't it be great?

00:53:21.940 --> 00:53:26.080
But then, like, if you go back to development environment, then you need to, like, put it back.

00:53:26.420 --> 00:53:35.060
Or if you don't do it at all, if you keep all the prints inside your code, You go into development, now you have a bunch of noise when you see the output.

00:53:35.630 --> 00:53:47.080
So with logging, just a simple way of you thinking about, I think a big advantage of logging is you can do logging and you can use different modes like debug, info, warning, error.

00:53:47.310 --> 00:53:55.500
So you can set the level based on, you can show, let's say if you go into your in development environment, you want to show the debug level.

00:53:55.590 --> 00:54:02.000
If you go into the production environment, then you might want to do like the info level only.

00:54:02.420 --> 00:54:09.260
But one drawback of logging is, I think it's tech, quite a bit of boilerplate code.

00:54:10.180 --> 00:54:10.940
That's the first thing.

00:54:11.100 --> 00:54:19.020
So it really, even if you can pop in paste, even it's like one barrier, you know, like one barrier to use logging.

00:54:19.260 --> 00:54:22.740
Why should I do all of this code when I can just use print?

00:54:23.020 --> 00:54:27.540
Right, it's got like, you got to register handlers and all sorts of funky stuff, yeah.

00:54:28.020 --> 00:54:35.860
But what if you can have the advantage of print, like so easy to use, and the benefit of logging?

00:54:36.380 --> 00:54:41.780
Then that's why I'm such a big fan of Loggeroo, which have the best of both worlds.

00:54:42.060 --> 00:54:45.720
And other things that it allows this beautiful app in the box.

00:54:46.120 --> 00:54:50.400
So the logging output, it looks colorful.

00:54:50.920 --> 00:54:52.140
It's very easy to see.

00:54:53.280 --> 00:54:57.480
With a standard logging, you need to do a lot of, you know, what do you want to show?

00:54:57.820 --> 00:55:06.340
You want to show this, you want to show the lines of code, you want to show the function, whereas the output is coming from all those configurations.

00:55:06.800 --> 00:55:13.720
With Loggeroo, you can just say from Loggeroo import Logger and then Logger.info something, something.

00:55:14.180 --> 00:55:16.000
And the output is very beautiful.

00:55:16.720 --> 00:55:17.320
Yeah, I really like it.

00:55:17.320 --> 00:55:25.180
You can basically just, if you wanted to kind of keep your print style, you can just import it and use it and it's prints, right?

00:55:25.460 --> 00:55:25.680
Yeah.

00:55:26.020 --> 00:55:38.300
The other thing, like you pointed out, this is a super big, for people who are primarily data scientists who haven't worked with logging a lot or new programming, instead of just saying logger print, you say logger debug or logger info or logger error.

00:55:38.520 --> 00:55:40.840
And then you can say, production, just show me the errors.

00:55:41.340 --> 00:55:42.480
Or, hey, something's going wrong.

00:55:42.820 --> 00:55:46.300
Actually, show me all the warnings and the info.

00:55:46.820 --> 00:55:49.300
And you can dial it up and down without changing the code.

00:55:49.620 --> 00:55:53.160
So you can leave your effective print statements there and just turn them off with a configuration.

00:55:53.520 --> 00:55:54.360
Maybe with Hydra, who knows?

00:55:54.780 --> 00:55:55.020
Yeah.

00:55:55.340 --> 00:55:55.920
Yeah, really nice.

00:55:55.980 --> 00:56:01.580
and the color and the color is very nice as well it's very colorful yeah it's and the color it

00:56:01.740 --> 00:56:07.420
persists through files by the way right so if you have log guru logging to a file and then you tail

00:56:07.460 --> 00:56:12.140
the file in your terminal you see the color still which is awesome oh wow i didn't know that that's a

00:56:13.080 --> 00:56:52.500
yeah yeah because some of my stuff is all logging um with log guru and i tell and the color comes through and it's wow so much easier um like for example on the website one of the things that i'm logging to a separate file is what are the requests what is the response time what is the status code is it a 500 is it 200 is it a three you know whatever right all that and so i'll actually have it change the color based on what happens so if the message is a 500 it's a different color than if it's a 200 or if the response time is over 500 milliseconds it changes color to like a warning sign versus if it's under like and it all that stuff comes true and it's like so nice with log

00:56:52.480 --> 00:56:56.560
Nice. Yeah. Especially when you have a lot of logs and that is very useful.

00:56:57.060 --> 00:57:01.200
Yeah, absolutely. Okay. Git. Let's talk about source control.

00:57:02.020 --> 00:57:11.340
Yeah. Version control is, I think it's, it's huge. It's very useful. and it's very important for data scientists, but I don't see it's being used enough.

00:57:11.640 --> 00:57:20.540
I was in, yeah, and the last thing I actually, I was a machine learning engineer in Accenture and working with clients.

00:57:20.990 --> 00:57:32.360
So I was building kind of like a data science environment, data science tool that integrated with AWS SageMaker.

00:57:32.820 --> 00:57:40.480
And it's funny how many data scientists are not using Git and like their multiple data science team.

00:57:40.920 --> 00:57:42.440
And they want to communicate with each other.

00:57:42.880 --> 00:57:44.020
You know, they want to share their work.

00:57:44.200 --> 00:57:53.200
But then every time they want to share their work, it's so hard for them because they don't have a source version control, which surprised me.

00:57:53.700 --> 00:57:55.180
You know, it's a big client.

00:57:55.580 --> 00:57:56.680
I mean, it's a big one.

00:57:57.220 --> 00:57:58.180
Why don't they use it?

00:57:59.200 --> 00:58:03.120
And if they do, it's not very good practices.

00:58:05.080 --> 00:58:08.760
So that's why I want to educate the scientists more about it.

00:58:09.820 --> 00:58:14.520
And to me, yeah, this is so important for several reasons.

00:58:15.520 --> 00:58:20.420
First, let's say if you do something, right, you mess up some code.

00:58:22.840 --> 00:58:24.760
Let me give an example of data scientists.

00:58:24.840 --> 00:58:27.480
They produce, they write a model.

00:58:27.880 --> 00:58:30.740
They write code that produces a model that works great.

00:58:31.060 --> 00:58:43.260
Then, like, later, they want to switch parameters, maybe experiment with different types of processing, see if the model performance can increase and they mess it up.

00:58:44.230 --> 00:58:49.100
The model decreases in performance and they have edited two or three files.

00:58:49.250 --> 00:58:51.440
Now they need to, okay, what did I edit?

00:58:51.570 --> 00:58:52.620
Now I need to revert it.

00:58:52.790 --> 00:58:58.820
And if you don't already save the last version that was working,

00:58:59.270 --> 00:59:01.120
you cannot just revert to it, right?

00:59:01.440 --> 00:59:04.100
But with Git, you can, there's multiple things.

00:59:04.420 --> 00:59:08.880
If you're just a solo data scientist, then you can revert it to the last working version.

00:59:10.930 --> 00:59:16.660
But if you work with other data scientists, then you can share, you can also collaborate with them.

00:59:16.910 --> 00:59:22.260
Different data scientists can work on different versions or different features.

00:59:22.640 --> 00:59:33.820
And when they're ready for it to be published, then they can merge it together, which is so much better when you do it with Git than manually going life to life.

00:59:34.240 --> 00:59:53.420
I think I agree with you. I think data scientists don't use source control or version control enough. And I think that even when people work alone on their own project, they should use Git or something else. And honestly, they should just use Git these days because it's the lingua franca of everything that people are doing.

00:59:54.059 --> 00:59:57.520
But it lets you do exactly what you're talking about.

00:59:57.650 --> 01:00:00.060
And it's not just, oh, no, I have to go back.

01:00:00.360 --> 01:00:02.320
But I think a really important part of people,

01:00:02.620 --> 01:00:04.920
speaking to the people who don't really use it that much,

01:00:05.160 --> 01:00:12.920
or they only use it in their professional settings in the team, maybe, I think it lets you be fearless in exploring new ideas, right?

01:00:13.240 --> 01:00:14.920
Like, all right, I'm going to commit this version.

01:00:15.330 --> 01:00:18.600
And then let me just terrorize my code and try something crazy.

01:00:18.740 --> 01:00:19.860
And oh, my gosh, it worked.

01:00:20.130 --> 01:00:20.740
Great, we'll keep it.

01:00:20.790 --> 01:00:22.440
If it doesn't work, nothing lost.

01:00:22.500 --> 01:00:23.840
you can 100% go back.

01:00:24.110 --> 01:00:27.720
And if people don't, if they're not, I mean, that's a good reason even by yourself, right?

01:00:28.000 --> 01:00:28.840
Yeah, yeah, exactly.

01:00:29.220 --> 01:00:31.100
And it's, I feel like it's so easy.

01:00:31.640 --> 01:00:33.460
You can do git add, git commit.

01:00:33.700 --> 01:00:41.040
I mean, there's a lot of things you can do with git, but I think to just learn some basic, git add, git commit, git push.

01:00:41.480 --> 01:00:41.740
That's it.

01:00:41.940 --> 01:00:42.160
Yeah.

01:00:42.350 --> 01:00:46.580
Yeah, there's not, you don't have to learn, there's maybe five or six commands you got to learn.

01:00:46.960 --> 01:00:49.040
Mostly your tools that you're working with.

01:00:49.580 --> 01:00:50.840
You mentioned VS Code.

01:00:51.080 --> 01:00:51.900
It's got awesome git.

01:00:52.220 --> 01:00:52.500
Oh, yeah.

01:00:52.840 --> 01:00:55.080
Control integration and PyCharm and others.

01:00:55.620 --> 01:00:55.800
Yeah.

01:00:56.040 --> 01:00:56.480
Yeah, absolutely.

01:00:56.580 --> 01:00:57.800
I think that's really, really nice.

01:00:58.780 --> 01:01:01.580
Let me give you two more ideas and see how these land with you, okay?

01:01:01.940 --> 01:01:04.680
For why I think Git is now more important than ever.

01:01:05.060 --> 01:01:05.300
Yeah.

01:01:05.680 --> 01:01:13.100
Number one, if you're doing any agentic coding, here's another reason to use like a proper editor instead of a notebook as well, potentially.

01:01:13.920 --> 01:01:20.040
But you can go and say, hey, AI agent, I would like you to change this and add this feature and do this thing.

01:01:20.260 --> 01:01:23.640
And it'll just go and go for, you know, 10, 15 minutes.

01:01:24.390 --> 01:01:28.500
If what I find a lot of times with these agentic coding things is they make great progress.

01:01:28.660 --> 01:01:29.760
You're like, wow, this is amazing.

01:01:29.850 --> 01:01:30.980
It makes more great progress.

01:01:31.010 --> 01:01:32.280
Like, how is this even possible?

01:01:32.390 --> 01:01:33.100
I live in the future.

01:01:33.490 --> 01:01:35.540
And then the next step is, oh, no, it broke it all.

01:01:36.340 --> 01:01:37.000
You know what I mean?

01:01:37.220 --> 01:01:39.000
So you're like, yeah, yeah.

01:01:39.480 --> 01:01:40.340
You have the same experience.

01:01:40.660 --> 01:01:40.920
Yes.

01:01:41.040 --> 01:01:51.900
And I love that you go into this topic because that's kind of I think of the mathematics I have been mentioned, it's more important than ever now that you have AI, you're working with AI.

01:01:52.480 --> 01:01:54.420
Because two different things, right?

01:01:54.420 --> 01:01:57.940
A lot of time, you wanted to do something and then it broke.

01:01:58.280 --> 01:02:00.180
So you want to go back to the previous version.

01:02:00.380 --> 01:02:00.840
That's one thing.

01:02:01.200 --> 01:02:06.180
Another thing is if you commit very frequently, then you can see what it changed.

01:02:06.500 --> 01:02:10.000
And you can take it before you commit it or you push.

01:02:10.900 --> 01:02:16.660
Because I think it's so frequently that I do something that is not optimal.

01:02:16.880 --> 01:02:18.840
For example, Mutiful Nested.

01:02:19.900 --> 01:02:24.220
Like with AI, a lot of times it overcomplicates the solution.

01:02:24.380 --> 01:02:29.860
It makes it so many tries, exec, accept, and if, else, or like it uses.

01:02:30.080 --> 01:02:30.760
It's hard code.

01:02:31.040 --> 01:02:31.940
It's just bad practices.

01:02:32.620 --> 01:02:37.640
But if you control, you use version control, you can see like the difference.

01:02:37.860 --> 01:02:44.900
like the last call and the new call and you can catch it before you commit and yeah yeah it's more

01:02:45.040 --> 01:02:51.280
important than ever i 100 yeah you're 100 right you're right on it i find that when i'm doing the

01:02:51.320 --> 01:03:28.000
agentic coding side of things i actually have the source control tab open in my editor not the files tab but the source control and as it's going i'll see what files are changed and i'll start like looking at the diffs even while it's still working i'm like oh it's on a good path oh no this it shouldn't be doing this and either you ask it to fix it or you just go no i'm reverting it yeah i added a feature to the website not a super big one but kind of touched a lot of files i think there was 15 commits to achieve that that change because every time a major i'm like okay the ai has gotten something right i'm like save that to get yes take because because it's it's like exactly like you

01:03:28.100 --> 01:04:28.640
described it's awesome yeah i i experienced the same like i would have so many commits for like want future change because also something that I tell to do is uh you know just let's say if I want to implement like a something I really like to do is go very thoroughly with like planning very very thoroughly in advance before even code to ensure like everything is uh what I expected and then I let it run right um and what I did depends on what I run I do but recently I tried develop like a workflow to go from you know my code into newsletter so I wanted to implement something uh and I want to be I want to be able to walk away and go back and and be able to go back to each so I break into phases like let's say I break into five phases right the um the easiest and the more complicated phase, like the nicer have feature.

01:04:29.120 --> 01:04:32.680
Now I want to go back into each phase and see if it breaks.

01:04:32.750 --> 01:04:34.100
I want to know when it breaks.

01:04:35.640 --> 01:04:37.880
So for every phase, ask it to commit.

01:04:38.620 --> 01:04:40.100
So that, you know, if I want to,

01:04:40.300 --> 01:04:41.520
if it breaks somewhere,

01:04:41.840 --> 01:04:46.660
I can go back to the previous version, which also another thing that you can ask it to commit.

01:04:47.920 --> 01:04:48.460
Yeah, yeah.

01:04:48.640 --> 01:04:48.960
That's interesting.

01:04:49.080 --> 01:04:50.500
I haven't thought about asking it to commit.

01:04:50.620 --> 01:04:50.940
That's cool.

01:04:51.220 --> 01:04:53.839
I'll give you one final reason

01:04:54.220 --> 01:04:56.320
to use Git in the agentic world.

01:04:56.560 --> 01:04:57.880
And then I think we're out of time.

01:04:57.980 --> 01:04:58.680
I'm going to have to call it.

01:04:59.010 --> 01:05:00.360
But this has been a great conversation.

01:05:01.220 --> 01:05:05.320
One other thing you talked about, like, oh, it's made good progress and then something didn't work.

01:05:05.490 --> 01:05:07.200
And you can actually tell it.

01:05:07.560 --> 01:05:08.400
You gave your example.

01:05:08.800 --> 01:05:09.940
Let me make this more concrete.

01:05:09.950 --> 01:05:13.640
You gave your example of, oh, I made some changes as, forget the AI, right?

01:05:13.720 --> 01:05:14.380
I made some changes.

01:05:14.880 --> 01:05:17.400
It turns out that the performance fell apart.

01:05:17.680 --> 01:05:18.620
I edited three files.

01:05:18.670 --> 01:05:20.240
I couldn't quite remember what was wrong.

01:05:20.520 --> 01:05:22.840
You could go to an agentic AI and say,

01:05:23.120 --> 01:05:30.600
please look at my local Git history from this commit forward and try to understand why the performance fell apart.

01:05:30.710 --> 01:05:34.780
And I bet you it will have some really good ideas, if not know exactly why.

01:05:34.850 --> 01:05:37.700
And it will do what we described for us in reverse.

01:05:37.960 --> 01:05:40.160
It'll just look at the Git history and go, this changed, this changed.

01:05:40.520 --> 01:05:42.120
Oh, if this changed, I bet it had this effect.

01:05:42.210 --> 01:05:42.920
And then, right.

01:05:43.100 --> 01:05:46.880
So you can leverage it in reverse and feed it to the AI to get understanding too.

01:05:47.200 --> 01:05:47.600
Yeah, yeah.

01:05:47.680 --> 01:05:50.880
That's such a great use case that you just talked about a lot of time.

01:05:51.140 --> 01:05:52.920
You're like, okay, use GitDiv.

01:05:53.160 --> 01:05:55.960
look at the difference and tell me what's wrong.

01:05:56.700 --> 01:06:00.560
That's another thing that I use very often.

01:06:01.460 --> 01:06:09.140
Also, another thing on top of it is, let's say it doesn't code the way you, like everybody has the old preferred style to do things, right?

01:06:09.440 --> 01:06:22.900
So sometimes you can edit it and you tell it, okay, look at your implementation and my implementation and just kind of taking notes of the difference so that the next time it will be able to create

01:06:22.920 --> 01:06:37.360
similar, more similar to the style you're looking for. Yeah. Yeah. That's a great idea. I feel like we honestly could talk about this for hours, but we're out of time. We're out of time, Quinn. So thank you for being here. I think let's leave it with this. Let's leave it with two things.

01:06:37.940 --> 01:06:49.040
First of all, maybe final call to action. People are interested in CodeCut AI, all of the stuff you've created. How do they get started with all of your resources? Yes. So just go to my website,

01:06:49.500 --> 01:06:53.620
Codecut, so C-O-D-E-C-U-T dot A-I.

01:06:54.000 --> 01:06:57.380
And then you will see how to sign up for newsletter.

01:06:57.960 --> 01:07:04.560
There's also a book tab that if you want to, if you're interested in production, ready data science, you can buy it there.

01:07:04.820 --> 01:07:05.980
It's currently on sales.

01:07:06.700 --> 01:07:07.660
It's Labor Day week.

01:07:08.020 --> 01:07:09.120
So 20% off.

01:07:09.600 --> 01:07:11.200
And yeah, that's it.

01:07:11.360 --> 01:07:13.560
And if you want to read my blog, go to blog.

01:07:13.800 --> 01:07:17.500
If you want to see a sample of my code snippet, go to short post.

01:07:18.080 --> 01:07:19.760
Everything is very easy to navigate.

01:07:20.380 --> 01:07:21.880
Just go to Word.ai.

01:07:22.260 --> 01:07:22.620
Fantastic.

01:07:22.880 --> 01:07:23.060
All right.

01:07:23.090 --> 01:07:26.100
Well, thank you so much for being here and sharing all your experience and your work.

01:07:26.480 --> 01:07:28.440
Really, congratulations on CodeCut.

01:07:28.520 --> 01:07:29.440
It's a cool project.

01:07:29.820 --> 01:07:30.500
Thank you so much.

01:07:30.800 --> 01:07:30.980
You bet.

01:07:31.500 --> 01:07:31.800
See you later.

01:07:32.080 --> 01:07:32.520
We'll see you.

01:07:32.700 --> 01:07:32.860
Bye.

01:07:34.100 --> 01:07:36.640
This has been another episode of Talk Python To Me.

01:07:37.380 --> 01:07:38.340
Thank you to our sponsors.

01:07:38.820 --> 01:07:40.040
Be sure to check out what they're offering.

01:07:40.200 --> 01:07:41.460
It really helps support the show.

01:07:42.100 --> 01:07:43.480
Take some stress out of your life.

01:07:43.720 --> 01:07:49.280
Get notified immediately about errors and performance issues in your web or mobile applications with Sentry.

01:07:49.780 --> 01:07:54.220
Just visit talkpython.fm/sentry and get started for free.

01:07:54.590 --> 01:07:57.840
And be sure to use the promo code talkpython, all one word.

01:07:58.540 --> 01:07:58.900
Agency.

01:07:59.540 --> 01:08:01.320
Discover agentic AI with agency.

01:08:01.820 --> 01:08:05.880
Their layer lets agents find, connect, and work together, any stack, anywhere.

01:08:06.560 --> 01:08:12.600
Start building the internet of agents at talkpython.fm/agency, spelled A-G-N-T-C-Y.

01:08:13.180 --> 01:08:23.319
Want to level up your Python? We have one of the largest catalogs of Python video courses over at Talk Python. Our content ranges from true beginners to deeply advanced topics like memory and async.

01:08:23.700 --> 01:08:28.859
And best of all, there's not a subscription in sight. Check it out for yourself at training.talkpython.fm.

01:08:29.560 --> 01:08:33.740
Be sure to subscribe to the show, open your favorite podcast app, and search for Python.

01:08:34.160 --> 01:08:44.420
We should be right at the top. You can also find the iTunes feed at /itunes, the Google Play feed at /play, and the direct RSS feed at /rss on talkpython.fm.

01:08:45.080 --> 01:09:01.660
We're live streaming most of our recordings these days. If you want to be part of the show and have your comments featured on the air, be sure to subscribe to our YouTube channel at talkpython.fm/youtube. This is your host, Michael Kennedy. Thanks so much for listening. I really appreciate it. Now get out there and write some Python code.

01:09:29.400 --> 01:09:30.799
We'll be right back.

