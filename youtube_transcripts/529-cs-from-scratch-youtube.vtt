WEBVTT

00:00:01.219 --> 00:00:02.820
<v Michael Kennedy>David, welcome back to Talk Python To Me.

00:00:03.670 --> 00:00:05.940
<v David Kopec>Thank you so much for having me back, Michael. It's really an honor.

00:00:06.799 --> 00:00:08.740
<v Michael Kennedy>Yeah, it's an honor to be here with you.

00:00:09.720 --> 00:00:14.880
<v Michael Kennedy>Got some really fun stuff to talk about, computer science from scratch.

00:00:15.260 --> 00:00:19.500
<v Michael Kennedy>What does that even mean? We're going to find out, because you wrote the book on it.

00:00:20.510 --> 00:00:21.260
<v Michael Kennedy>And we're going to dive in.

00:00:21.800 --> 00:00:26.000
<v David Kopec>Yeah, I'm excited. And this book just came out, so it's kind of fresh off the press.

00:00:26.190 --> 00:00:29.280
<v David Kopec>And I want to thank you for being the technical reviewer on the book, actually.

00:00:29.880 --> 00:00:40.260
<v Michael Kennedy>Yeah, it was really fun. You reached out and asked me. I don't normally do things like that, but I'm like, you know, that'd be kind of fun. It would be a good experience. And I do think it was.

00:00:40.380 --> 00:00:44.340
<v Michael Kennedy>It taught me some about creating books and I guess that pays off as well.

00:00:45.080 --> 00:00:48.500
<v David Kopec>And congratulations, by the way, on Talk Python in production coming out.

00:00:49.059 --> 00:01:00.340
<v Michael Kennedy>Yeah, thanks. I started that last December and it came out, I think the beginning of this month, maybe end of September, something like that, but pretty recently. So yeah, I really appreciate it.

00:01:00.460 --> 00:01:05.480
<v Michael Kennedy>It's going really well. We're in kind of the same phase because Computer Science from Scratch

00:01:05.680 --> 00:01:20.520
<v David Kopec>officially came out end of September also. So we're just in this kind of, you know, one month out from these books coming out. And so I think it's an exciting time for both of us. And I've started reading Python in production and I'm really loving it. So congrats on it. Awesome. Thank you. And I

00:01:20.600 --> 00:01:28.060
<v Michael Kennedy>really enjoyed your book and I had to read it with a little more detail than just appreciate it, I had to take notes and help you with some feedback.

00:01:28.320 --> 00:01:30.320
<v Michael Kennedy>So that was a really cool experience, and thanks.

00:01:31.080 --> 00:01:36.220
<v Michael Kennedy>You know, it's been six, almost, over five years, let's put it that way.

00:01:36.640 --> 00:01:38.560
<v Michael Kennedy>It's been over five years since you've been on the show.

00:01:38.680 --> 00:01:43.780
<v Michael Kennedy>We talked about classic computer science programs in Python, I believe it was.

00:01:45.800 --> 00:01:53.540
<v Michael Kennedy>Yeah, that was really a fun and popular episode, but let's do a quick refresher, a quick introduction for you to everyone who's new to the show in the last five years.

00:01:54.340 --> 00:02:01.240
<v David Kopec>Okay, so I'm a computer. My name is David Kopech. I'm a computer science professor at Albright College in Redding, Pennsylvania.

00:02:01.720 --> 00:02:07.600
<v David Kopec>I actually just moved over here from Champlain College, where I was for the past nine years in a similar role.

00:02:08.080 --> 00:02:11.160
<v David Kopec>And I'm also the program director of computer science and information technology.

00:02:11.260 --> 00:02:19.400
<v David Kopec>We're launching three new majors, a little plug for Albright, a revamped computer science major, an artificial intelligence major, and cybersecurity.

00:02:19.940 --> 00:02:23.080
<v David Kopec>And so I'm managing the launch of those for fall 2026.

00:02:23.900 --> 00:02:28.060
<v David Kopec>My background is for the past decade, obviously, as a computer science educator.

00:02:28.600 --> 00:02:38.340
<v David Kopec>I've written five books on computer science and programming, the most successful of which was Classic Computer Science Problems in Python, which, of course, I was on the show five years ago about.

00:02:38.600 --> 00:02:43.100
<v David Kopec>And this book, Computer Science from Scratch, is kind of for a similar audience.

00:02:43.940 --> 00:02:55.540
<v David Kopec>Both books are for Python programmers, folks who are intermediate or advanced Python programmers, but maybe who want to fill in the kind of computer science topics that they don't know, maybe because they're self-educated.

00:02:55.680 --> 00:02:57.400
<v David Kopec>Maybe they learned Python on their own.

00:02:57.410 --> 00:02:58.800
<v David Kopec>They didn't have a formal CS degree.

00:02:59.540 --> 00:03:08.700
<v David Kopec>Or maybe they did have a formal CS degree, but now they're preparing for interviews or transitioning to a more CS in-depth role, and they want to refresh on some of these topics.

00:03:09.260 --> 00:03:13.860
<v David Kopec>So both books are for folks who know Python but want to go deeper on CS.

00:03:14.360 --> 00:03:14.660
<v Michael Kennedy>Right.

00:03:15.480 --> 00:03:18.900
<v Michael Kennedy>Here's how you do a loop in Python, or here's what InterTools is.

00:03:19.080 --> 00:03:22.220
<v Michael Kennedy>It's true, computer science topics, right?

00:03:22.960 --> 00:03:23.060
<v David Kopec>Right.

00:03:23.200 --> 00:03:26.380
<v David Kopec>And I think somebody at that stage will be very frustrated by the books.

00:03:26.780 --> 00:03:27.560
<v David Kopec>They really are.

00:03:27.820 --> 00:03:29.200
<v Speaker 3>And so we have to put that preface in.

00:03:29.200 --> 00:03:32.320
<v David Kopec>They really are for intermediate or advanced Python programmers.

00:03:33.520 --> 00:03:40.480
<v David Kopec>So, you know, so I'm trying to reach the same audience, but they're totally different books in terms of the type of topics they cover.

00:03:40.940 --> 00:03:45.920
<v David Kopec>So classic computer science problems in Python was more of a data structures and algorithms type of book.

00:03:46.240 --> 00:03:50.880
<v David Kopec>Did some AI type topics as well, but very much on the algorithm side.

00:03:51.300 --> 00:03:59.200
<v David Kopec>Computer science from scratch is more, let's build up the layers of the software stack from the bottom up that Python kind of runs on top of.

00:03:59.200 --> 00:04:01.540
<v David Kopec>So you understand what's actually happening under the hood.

00:04:01.720 --> 00:04:03.340
<v David Kopec>So how does an interpreter work?

00:04:04.300 --> 00:04:06.180
<v David Kopec>What's the hardware software interface like?

00:04:06.180 --> 00:04:07.620
<v David Kopec>We get that with emulators.

00:04:08.280 --> 00:04:10.380
<v David Kopec>And then there is still some algorithmic stuff as well.

00:04:10.580 --> 00:04:16.459
<v David Kopec>different topics than in the prior book, but stuff like a little computer art stuff, a little bit of machine learning.

00:04:16.820 --> 00:04:18.579
<v David Kopec>So we try, it's still a survey book.

00:04:18.690 --> 00:04:24.320
<v David Kopec>It's still pretty broad, but it's more about the layers of the software stack than classic computer science problems in Python was.

00:04:25.020 --> 00:04:25.280
<v Michael Kennedy>Yeah.

00:04:26.200 --> 00:04:26.340
<v Michael Kennedy>Yeah.

00:04:26.340 --> 00:04:27.640
<v Michael Kennedy>There's some pretty low level stuff.

00:04:27.690 --> 00:04:43.600
<v Michael Kennedy>And it's interesting you're doing in Python, you know, a lot of, I think a lot of times that would be taught in at least a pointer based language, you know, like C or you can even see it being taught in assembly, like you're talking to the machine, like literally.

00:04:44.760 --> 00:05:03.580
<v David Kopec>Absolutely. And you know, if you took these classes, like if you took an architecture class, which I'm going to be teaching next semester at Albright, it's going to be an assembly language, right? And if you took a compilers course, it's usually in something like C or today, it might be in a Rust, a low level language where you do have that direct access to memory.

00:05:04.240 --> 00:05:22.300
<v David Kopec>But I wanted to make the book accessible. And Python is the most accessible language in the world, it's the most popular language in the world, and it's the language that we're increasingly using in computer science education anyway. So it is actually a little unusual to cover some of these topics in Python, but it makes the topics accessible to a much wider audience.

00:05:22.820 --> 00:06:02.900
<v Michael Kennedy>Yeah. It definitely makes it accessible to a wider audience. Let's take a step back and talk about this role you have in this new college university you're at. So you said that you're revamping the CS program, you're adding AI and cybersecurity. That's a big shift. Do you want to just talk to people about how that's changing, why you decided to change? I look at a lot of CS programs and I don't know how connected they are to the real world. So I imagine some of these changes are to sort of realign it with what's happened recently. Absolutely. Yeah. So I'm coming from

00:06:03.100 --> 00:06:12.500
<v David Kopec>a college, the Champlain College in Vermont, where I was at for nine years, which was a professionally focused college. So it was a college where we were preparing students for their careers.

00:06:13.100 --> 00:06:32.060
<v David Kopec>I moved now to Albright, which is a liberal arts college. So it's a college that's more teaching people how to think, creating great citizens, and hopefully we prepare them for their careers very well too. But there's that liberal arts foundation underneath everything. So one of the challenges in developing these three new majors was how do you fit them into a liberal arts curriculum?

00:06:32.600 --> 00:06:36.120
<v David Kopec>And how do you make them relevant to careers while still being true to the liberal arts?

00:06:36.560 --> 00:06:42.580
<v David Kopec>And so what I found the best way to do it is to still focus on how to help people think computationally.

00:06:43.160 --> 00:06:48.000
<v David Kopec>And so there's a firm foundation of computer science and mathematics throughout all three majors.

00:06:48.580 --> 00:06:55.140
<v David Kopec>So whether you're doing cybersecurity, artificial intelligence, or computer science, you're going to have a lot of classes in common with one another.

00:06:55.560 --> 00:06:59.220
<v David Kopec>And we also need to infuse some of the issues we see in the workforce today.

00:06:59.380 --> 00:07:02.800
<v David Kopec>Like all of them will have a computer ethics course that's incorporated.

00:07:03.720 --> 00:07:06.280
<v David Kopec>And all of them will have an internship course that's incorporated.

00:07:06.290 --> 00:07:09.780
<v David Kopec>So students are getting real world experience as they're going through these majors.

00:07:10.400 --> 00:07:11.560
<v Michael Kennedy>I think that's a great idea.

00:07:11.800 --> 00:07:25.120
<v Michael Kennedy>It's really important to have done software engineering hands-on with other companies, real products, and real product managers, in addition to just knowing the algorithms and foundations.

00:07:26.040 --> 00:07:26.400
<v David Kopec>Absolutely.

00:07:26.550 --> 00:07:27.220
<v David Kopec>I couldn't agree more.

00:07:27.540 --> 00:07:29.480
<v David Kopec>And so we're trying to blend the two.

00:07:29.840 --> 00:07:32.360
<v David Kopec>And that's been one of the exciting things.

00:07:32.560 --> 00:08:07.640
<v David Kopec>and you asked why I changed, I was excited about this opportunity to build these new majors from the ground up. We'll be one of the first teaching colleges, small teaching colleges, to offer an artificial intelligence major. It's just been in the last five years that we've seen colleges start to offer an undergraduate major in artificial intelligence. And it's mostly been big name brand colleges like CMU that are offering these first artificial intelligence bachelor's degrees. But we get to be at the forefront of how do you fit that into a small liberal arts college and still make it career relevant and still have that firm liberal arts foundation.

00:08:09.919 --> 00:08:14.560
<v Michael Kennedy>Are you concerned about not all these hackers in on your network if you're teaching a cybersecurity?

00:08:15.380 --> 00:08:19.240
<v Michael Kennedy>Well, I won't be teaching the cybersecurity courses. So I'm firmly just in the computer

00:08:19.350 --> 00:08:58.000
<v David Kopec>science education course, and we're hiring additional faculty in cybersecurity and in artificial intelligence. I'm more on the management side of those two programs. But, you know, look, it's more relevant than ever. When you look at actually the number of students going to college for cybersecurity, it's been exploding over the last decade. You know, I just talked about how artificial intelligence has just come about as a bachelor's degree. Cybersecurity was kind of there 15 years ago. So cybersecurity started out as maybe you took a computer security course at the end of your computer science degree. Then it became a concentration you could do within some computer science degrees. And then in the 2010s, it broke out and became its own bachelor's degree.

00:08:58.620 --> 00:09:36.480
<v David Kopec>And so we're seeing the same thing right now with AI. It started out, you know, when you did undergrad computer science, maybe in the 90s, or like me and the OOs, you might have one course, like an intro to AI course that you have at the end of your bachelor's degree. Then it started to be something where you do a concentration at Champlain, I developed a concentration in artificial intelligence. Now, just in the last five years, we're seeing it break out from being just a part of a CS degree to being its whole own, you know, adjacent degree. So I think it's an exciting time for that. Of course, there's a hype cycle right now about AI. So a lot of colleges are jumping in. And I think some of them are doing it the right way. And, you know, having that firm

00:09:36.740 --> 00:09:40.740
<v Speaker 3>foundation in computer science and mathematics, so it's durable. And some of them are doing it in

00:09:40.880 --> 00:09:50.800
<v Michael Kennedy>kind of a shallow way. We're trying to do it the right way. Yeah, that sounds great. And obviously, cybersecurity is one of those things that's highly valuable.

00:09:51.100 --> 00:09:54.180
<v Speaker 3>Nobody wants to be in the news for that reason, right?

00:09:54.460 --> 00:09:57.660
<v Michael Kennedy>So companies are certainly looking for people with those skills.

00:09:59.780 --> 00:10:01.820
<v Michael Kennedy>Let's talk one more thing about the university.

00:10:04.540 --> 00:10:06.840
<v Michael Kennedy>Not the AI focus, but just AI.

00:10:07.200 --> 00:10:55.380
<v Michael Kennedy>One of the things I think is, of all the places that's getting the most scrambled, changed, under pressure, whatever you call it, from AI, I think it's education in general. And I'm not talking just college. I'm talking, I don't know, like third grade. As soon as the kids can start using AI, they're like, this is like the calculator with a rocket booster on it. You know what I mean? Like this will solve the problems. And I think there's a really big challenge for you as universities to connect with students, keep academic integrity as well. But there's also a huge problem, I think, for the students to not let it undercut their education and end up going, well, all I know I have to do is to do ChatGPT. You're absolutely right. I mean, it's a huge

00:10:55.700 --> 00:11:06.560
<v David Kopec>challenge in computer science education. And I don't think the computer science education community has yet completely figured it out. Well, basically, what it breaks down to is exactly what you said.

00:11:06.600 --> 00:11:30.400
<v David Kopec>students are just using ChatGPT or GitHub Copilot to do their homework. And if you're in a first year or second year class, I've been mostly teaching upper level CS for the past like six plus years, and I'm teaching an intro class for the first time in a long time this semester. And it's been eye-opening for me to see how many students are trying to just do every assignment with ChatGPT.

00:11:30.400 --> 00:11:39.440
<v David Kopec>And we still have to give them basic assignments. When you're first learning how to do a for loop or what a function is or what an if statement is even, right? You got to write. You can't say

00:11:39.920 --> 00:11:42.820
<v Michael Kennedy>implement a database and get back to me next week. You got to start somewhere.

00:11:43.440 --> 00:12:41.300
<v David Kopec>So we still have to teach these fundamentals, but we have this opponent to us in some sense of this ease of access to something that can just do all the work for you. And so I'm sure that, like you mentioned, mathematics educators had similar challenges in the 1970s, 1980s as calculators became prominent. So what I've done, and I've been adjusting as since ChatGPT came out in fall 2022, I've been constantly adjusting and reevaluating, but I have had to go back to the future a little bit. And people might find this a little anachronistic, but I've heard about it from other CS educators as well. Going back to doing some paper exams. I know that sounds crazy. And I know that sounds like bizarre. But at some point, you need to evaluate if students actually know how to write a for loop because you know while we think ll some people think llms are going to replace software engineers in the next two years you still need to understand what it's outputting and i don't think it's i don't i don't know about you michael but i don't think they're completely

00:12:41.560 --> 00:12:47.480
<v Speaker 3>replacing software engineers no way no way and that's coming i don't know how many people maybe

00:12:47.680 --> 00:13:11.040
<v Michael Kennedy>don't necessarily i'm a huge fan of agentic coding and and the what it can do for productivity and it's incredibly powerful, but it's, it's one of those things that is, it needs someone to guide it who knows how to, how to do that. And then it becomes a superpower. If you don't, you end up with like, how do we end up on react? I thought this was a rust project. You're like, what happened

00:13:11.180 --> 00:14:00.240
<v David Kopec>here? Yeah. And you need to understand when it makes mistakes, you need to know how to correct those mistakes. And of course you need to be, you need to be understanding everything that it's outputting, so you're auditing it. So we are having a real challenge, especially in those intro classes of how do you kind of force students to not use these tools essentially, because you're not learning anything if the tool writes the for loop for you when you're first learning how to do a for loop. And so you have to find ways to encourage it, to win hearts and minds. I think, of course, that's a big part of it, is convincing students and being dynamic and enthusiastic about how good it feels to really understand how this actually works. But then there has to be enforcement too. And sometimes that feels a little anachronistic being forceful about it or going back to,

00:14:00.510 --> 00:14:05.780
<v Speaker 3>you know, doing tests on paper. But we have to have ways of ensuring the knowledge is actually

00:14:06.040 --> 00:14:46.440
<v Michael Kennedy>there. I feel like this is not just a college student issue, but it's I think it's especially relevant in that part of your career that the struggle is not in the way the struggle is often part of part of what's unlocks your thinking it's part of what like cements the knowledge and makes you feel a true sense of accomplishment when you're like i tried this and i couldn't get it to work but three hours later i finally figured it out and i i now understand iterators finally You know what I mean? And it's just so easy to push the easy button and just say, chat, why?

00:14:49.040 --> 00:14:54.140
<v David Kopec>And that's what feels good about being a teacher is being there for those aha moments with students.

00:14:54.470 --> 00:14:59.180
<v David Kopec>I had some moments like that last week and they reminded me like, this is why you're in this career.

00:15:01.079 --> 00:15:05.500
<v David Kopec>It's really something that can become addictive to students actually.

00:15:05.670 --> 00:15:08.120
<v Michael Kennedy>When they start having those aha moments, they want more of them.

00:15:08.580 --> 00:15:09.980
<v David Kopec>And it spurs on.

00:15:10.520 --> 00:15:12.080
<v Michael Kennedy>That's how you end up at like 3 a.m.

00:15:12.920 --> 00:15:13.500
<v Michael Kennedy>Really hungry.

00:15:14.280 --> 00:15:16.140
<v Michael Kennedy>Wonder why you haven't gone to sleep but still programming.

00:15:16.320 --> 00:15:17.720
<v David Kopec>You're like, this is amazing.

00:15:17.780 --> 00:15:18.380
<v David Kopec>I can't stop.

00:15:19.120 --> 00:15:19.640
<v David Kopec>Right, right, right.

00:15:19.780 --> 00:15:21.220
<v David Kopec>And it takes a certain mindset

00:15:21.700 --> 00:15:24.400
<v Speaker 3>to be able to appreciate those moments.

00:15:26.059 --> 00:15:33.900
<v David Kopec>And this is like a sidebar, but one thing we're also seeing in computer science education is we see a lot of folks who go into it sometimes for the wrong reasons.

00:15:34.640 --> 00:15:47.680
<v David Kopec>Folks sometimes go into computer science just because they hear, this is a great way to get a good job. And if that's your only motivation going into it, you're probably not going to be successful in it. Unfortunately.

00:15:48.220 --> 00:15:49.880
<v Michael Kennedy>It's going to be tough. Yeah, it's going to be tough.

00:15:50.540 --> 00:15:54.960
<v Michael Kennedy>Yeah. But a lot of people are there for the right reasons. So I think that that's good.

00:15:55.620 --> 00:16:10.400
<v David Kopec>Absolutely. And I hope with a book like this, folks who came in from the other side, folks who came in, you know, because they had that interest, but they didn't have the chance to either go to university, maybe they couldn't afford it, maybe they studied something else and they're later in their career.

00:16:11.640 --> 00:16:18.680
<v David Kopec>This will hopefully give them a bunch of those aha moments and about topics that are deeper than just how to write a for loop.

00:16:19.240 --> 00:16:19.880
<v Michael Kennedy>Yeah, absolutely.

00:16:21.640 --> 00:16:22.080
<v Michael Kennedy>Well, good.

00:16:22.180 --> 00:16:32.960
<v Michael Kennedy>I mean, I feel like there's probably some middle ground you might be able to accomplish if you're like, all right, we're going to give you a laptop, a testing laptop that has no internet.

00:16:33.560 --> 00:16:35.960
<v Michael Kennedy>We've gone in there and crushed the network card.

00:16:36.700 --> 00:16:36.800
<v Michael Kennedy>Yeah.

00:16:37.100 --> 00:16:38.040
<v Michael Kennedy>Here, take the test.

00:16:38.520 --> 00:16:41.480
<v Michael Kennedy>And here's your thumb drive to submit your work, you know, potentially.

00:16:42.100 --> 00:16:42.360
<v David Kopec>Yeah, yeah.

00:16:42.420 --> 00:16:43.480
<v David Kopec>And we do stuff like that.

00:16:43.520 --> 00:16:47.160
<v David Kopec>Like I just did a test on, you know, an online test for my students.

00:16:47.660 --> 00:16:50.400
<v David Kopec>And I'm just monitoring to make sure nobody's using the tools.

00:16:51.560 --> 00:16:54.100
<v David Kopec>You know, but there is something said still for paper exams.

00:16:54.220 --> 00:16:54.780
<v David Kopec>I'll tell you why.

00:16:55.000 --> 00:17:01.720
<v David Kopec>Sometimes even today on today's tools for giving exams, sometimes you want students to draw something, especially if it's a data structures and algorithms class.

00:17:02.020 --> 00:17:05.959
<v Speaker 3>You might want them to draw a tree and it's just actually easier for them to do that on paper.

00:17:06.060 --> 00:17:09.160
<v David Kopec>So when people hear paper, they might be like, oh my goodness, what are you doing that for?

00:17:09.500 --> 00:17:10.260
<v David Kopec>No, there's real reasons.

00:17:11.220 --> 00:17:11.660
<v Michael Kennedy>Yeah, of course.

00:17:11.959 --> 00:17:13.819
<v David Kopec>But yeah, we have monitoring tools too.

00:17:14.620 --> 00:17:15.240
<v Michael Kennedy>Yeah, very good.

00:17:16.220 --> 00:17:16.459
<v Michael Kennedy>All right.

00:17:17.120 --> 00:17:21.839
<v Michael Kennedy>Let's maybe take a couple of different examples or different chapters in the book and talk through them.

00:17:24.520 --> 00:17:30.060
<v Michael Kennedy>The first one, the first main topic is the smallest possible programming language, right?

00:17:30.860 --> 00:17:31.560
<v David Kopec>Yes, yes.

00:17:31.740 --> 00:17:32.860
<v David Kopec>Tell us about this.

00:17:33.380 --> 00:17:38.800
<v David Kopec>Yeah, the premise of the chapter is what's the minimum that we need to have a programming language?

00:17:39.400 --> 00:17:40.640
<v David Kopec>And there's a famous programming language.

00:17:40.800 --> 00:17:45.600
<v David Kopec>I'm actually not going to use the name of the language on the show, I think, just because it has the F word in it.

00:17:45.640 --> 00:17:47.020
<v Speaker 3>And I didn't make up the language.

00:17:47.580 --> 00:17:50.180
<v David Kopec>It was developed 30 years ago, but we'll just call it BF.

00:17:50.480 --> 00:17:50.580
<v David Kopec>Okay.

00:17:50.860 --> 00:17:51.100
<v Michael Kennedy>Yeah.

00:17:52.280 --> 00:17:53.100
<v Michael Kennedy>Brain F star.

00:17:53.740 --> 00:17:54.460
<v Michael Kennedy>Yeah, sure.

00:17:54.780 --> 00:17:55.280
<v Michael Kennedy>Brain F star.

00:17:55.940 --> 00:17:59.000
<v David Kopec>This language, it only has eight symbols in it.

00:17:59.060 --> 00:18:01.080
<v David Kopec>I mean, it literally only has eight symbols in it.

00:18:01.220 --> 00:18:03.340
<v David Kopec>Yet, it's what we call Turing complete.

00:18:04.140 --> 00:18:09.000
<v David Kopec>And I won't go into the full details of what it means for something to be Turing complete, but let me put it this way.

00:18:09.290 --> 00:18:17.060
<v David Kopec>A language that is Turing complete can theoretically solve any of the same algorithmic problems as any other language that's Turing complete.

00:18:17.720 --> 00:18:23.620
<v David Kopec>And every programming language that you use is Turing complete, whether it's Java, Python, C, whatever, of course, they're all Turing complete.

00:18:24.120 --> 00:18:27.740
<v David Kopec>This language with only eight symbols in it is also Turing complete.

00:18:28.400 --> 00:18:40.840
<v David Kopec>So while you could code something like Quicksort in Python, you could also code it in BF with just eight symbols. While you could code a JSON parser in Python, you could also code a JSON parser in BF.

00:18:41.340 --> 00:19:08.980
<v David Kopec>So by learning this really, really basic language and actually implementing it, so implementing an interpreter for it, something that can actually run programs written in it, you really get to understand just how little we need to solve computational problems. We don't need much. We need very minimum amount of computing machinery and very minimum amount of syntax to be able to solve most problems. Now, would you want to solve most problems in PF? Of course not.

00:19:09.440 --> 00:19:28.180
<v David Kopec>We just use it as an illustrative example to show this is how simple a programming language can really be and still have all the same capabilities as a more advanced programming language. And you might wonder then why do we have such much more advanced programming languages? Because they give us a lot more developer productivity. They have more abstractions that let us think as human beings

00:19:28.740 --> 00:19:34.500
<v Speaker 3>instead of thinking like machines. The expressiveness, absolutely. And so that's great that we have all

00:19:34.580 --> 00:19:39.280
<v David Kopec>of that. But if you really want to understand essentially what the language is doing at the

00:19:39.400 --> 00:19:52.679
<v Michael Kennedy>lowest levels, you only need these few bits. So what's the key message here? Obviously, you're not trying to get people to become BF experts, right? I mean, maybe you learn Cobalt

00:19:52.700 --> 00:19:58.080
<v Speaker 3>over bf these days still work for the social security administration yeah yes exactly there's

00:19:58.140 --> 00:20:12.800
<v Michael Kennedy>going to be some high-paying cobalt jobs out there um but this is more about like writing an actual interpreter very much like c python itself in a sense conceptually right conceptually i mean much

00:20:12.920 --> 00:20:19.640
<v David Kopec>much much simpler and actually in the next chapter we get to writing a basic interpreter which is like just one step up from BF.

00:20:20.240 --> 00:20:21.620
<v David Kopec>And we can talk about that in a minute.

00:20:21.860 --> 00:20:26.100
<v Speaker 3>But yeah, it's about understanding how it works at a low level.

00:20:26.340 --> 00:20:27.440
<v David Kopec>What's it actually doing?

00:20:27.600 --> 00:20:30.240
<v David Kopec>And it feels good to make something that can run programs.

00:20:31.820 --> 00:20:36.440
<v David Kopec>A lot of people, when they get into computer science, are actually excited about making their own language.

00:20:37.220 --> 00:20:40.920
<v David Kopec>So by doing these first couple chapters of the book, you're actually on the path to that.

00:20:40.920 --> 00:20:49.720
<v David Kopec>I think after reading these first two chapters, you could go implement your own simple language and really make that kind of dream that a lot of us have come true.

00:20:50.330 --> 00:20:52.020
<v David Kopec>So it's about understanding how it works at a low level.

00:20:52.180 --> 00:20:54.780
<v David Kopec>I have to say the book is not a practical book.

00:20:54.900 --> 00:21:01.980
<v David Kopec>It's not like talk Python in production where you're going to learn, you know, here's some useful tools and tips and strategies.

00:21:02.370 --> 00:21:05.600
<v Michael Kennedy>Install this thing and set up that config and then run it this way.

00:21:06.280 --> 00:21:06.360
<v Michael Kennedy>Right.

00:21:06.760 --> 00:21:10.760
<v David Kopec>Computer Science from Scratch is not going to help you build your next app that you're building.

00:21:11.430 --> 00:21:12.040
<v Speaker 3>Not directly.

00:21:12.560 --> 00:21:25.500
<v David Kopec>Not directly, but it is going to help you understand a lot more about what's happening under the covers, which is ultimately going to make you think more broadly as a software developer and understand different strategies that you might be able to use.

00:21:25.500 --> 00:21:27.400
<v David Kopec>I'll give you an example with this interpreter stuff.

00:21:28.280 --> 00:21:36.220
<v David Kopec>You might be writing a program that needs to have some kind of configuration files, and you want to maybe be able to parse those configuration files.

00:21:36.820 --> 00:22:14.780
<v David Kopec>Well, part of writing an interpreter is writing a parser, something that understands the syntax of the programming languages and starts to get towards the semantics. And you might want to be able to write a parser later on for some very specific configuration type format that you've come up with for some, or maybe even just a file format for more of like an office type program. And you're going to need some way of understanding the techniques of how to parse that. Learning how an interpreter works will help you write that program later on. So it's about learning computational techniques, learning problem solving techniques more than it is about like something that's going to necessarily be, this is exactly how you do this for the next app you're going to build.

00:22:15.960 --> 00:22:31.880
<v Michael Kennedy>It's not something that you would just stumble across most of the time, I think, right? You'll stumble across, oh, here's a web framework. You'll stumble across, you know, oh, here's an ML library or something, but you don't typically stumble across and here's how you build a parser from

00:22:32.160 --> 00:22:43.860
<v David Kopec>scratch. Right. And so, you know, there has to be that curiosity there. So I will admit that if you have no interest and you're not the type of person who wants to understand how things work, you won't like this book.

00:22:44.000 --> 00:22:45.640
<v David Kopec>And that is some folks and that's okay.

00:22:45.800 --> 00:22:52.760
<v David Kopec>There's folks who go into programming because they're only interested in what they can build and they're not so interested in how things work.

00:22:53.240 --> 00:22:55.940
<v David Kopec>And if that's you, this is probably not the book for you.

00:22:56.320 --> 00:22:58.200
<v Speaker 3>But if you're the type of person who has that curiosity

00:22:58.460 --> 00:23:03.600
<v David Kopec>and you really wanna understand how everything's actually working under the covers, then this is a great book.

00:23:04.400 --> 00:23:05.060
<v Michael Kennedy>Yeah, absolutely.

00:23:06.160 --> 00:23:18.580
<v Michael Kennedy>And it's a simple enough thing that you can grasp the ideas pretty quickly with this BF language, right? It's not so complicated that you, you know, a day later are still trying to make the thing parse.

00:23:19.500 --> 00:23:32.480
<v David Kopec>Absolutely. I mean, what's crazy is to interpret BF, you only need about 30 lines of code, 30 lines of Python. And then you actually have something that can run any program written in this language.

00:23:33.520 --> 00:23:38.820
<v Michael Kennedy>And to be clear, you have like something.bf files that you can put the language into.

00:23:38.960 --> 00:23:42.820
<v Michael Kennedy>And then you say Python, this module, that file.

00:23:42.980 --> 00:23:47.260
<v Michael Kennedy>And it'll run it as if it were an interpreter for that thing, right?

00:23:47.860 --> 00:23:48.240
<v David Kopec>Exactly.

00:23:48.420 --> 00:23:48.600
<v David Kopec>Yeah.

00:23:48.780 --> 00:23:51.780
<v David Kopec>You're literally implementing the whole programming language in like 30 lines of Python.

00:23:52.320 --> 00:23:57.120
<v David Kopec>And I think what's great about this too is it takes away the feeling that everything is magic.

00:23:57.740 --> 00:24:02.800
<v David Kopec>You know, that's another thing I love when people read also classic computer science problems in Python.

00:24:03.460 --> 00:24:10.480
<v David Kopec>You know, sometimes when you think about how these things work, like in that book, we cover the A star algorithm, which is something that Google Maps work, right?

00:24:10.840 --> 00:24:10.980
<v David Kopec>Uses.

00:24:11.350 --> 00:24:15.100
<v David Kopec>When you think about Google Maps, like it feels like magic when you use it.

00:24:15.100 --> 00:24:20.360
<v David Kopec>It just, but actually there's really understandable, logical algorithms that are underneath the surface.

00:24:20.920 --> 00:24:21.620
<v David Kopec>It's the same thing here.

00:24:21.740 --> 00:24:24.120
<v David Kopec>Python itself might feel like magic to a lot of folks.

00:24:24.470 --> 00:24:31.600
<v David Kopec>But by the time you get through these first couple of chapters, especially through the basic interpreter chapter, you'll start to be on the road to think, oh, you know what?

00:24:31.740 --> 00:24:37.420
<v David Kopec>I bet I could dive into the CPython source code with enough additional training and really understand it.

00:24:37.440 --> 00:24:39.120
<v David Kopec>It gives you that confidence that this is not just magic.

00:24:39.120 --> 00:24:40.280
<v Michael Kennedy>We've already got the parser.

00:24:40.680 --> 00:24:44.720
<v Michael Kennedy>You just got to look at the bytecodes and look at it go.

00:24:45.360 --> 00:24:49.780
<v David Kopec>Not to say there's not a lot more there, but it just gets you on that journey and makes you see it's not magic.

00:24:50.380 --> 00:24:50.500
<v Michael Kennedy>Right.

00:24:50.820 --> 00:24:54.920
<v Michael Kennedy>Well, it's that zero to one sort of gap that's the hardest to cross.

00:24:55.740 --> 00:24:55.980
<v David Kopec>Yeah.

00:24:56.539 --> 00:24:56.940
<v Michael Kennedy>Yeah.

00:24:57.580 --> 00:25:19.240
<v Michael Kennedy>you know, like the second language with sync, second programming language you learn, or the third or the fourth, they only get easier to learn, not harder to learn. Whereas, you know, maybe when you're first starting out, and you're trying to get something to compile, and it won't even run, you're like, Oh, my God, how am I going to do I can't even learn this one, there's all these things I'm going to have to know. And it's really kind of upside down.

00:25:19.940 --> 00:25:32.600
<v David Kopec>Yeah, absolutely. And so, you know, when we think about understanding how Python itself works, I think the second chapter of the book about basic gets us a lot further along on that journey because here this isn't just a made up.

00:25:33.180 --> 00:25:40.000
<v David Kopec>BF is it's a language that's been around in computer science education for like 30 years, but it's not a real language that people actually used.

00:25:40.780 --> 00:25:45.300
<v Michael Kennedy>Very few people ever said that they were BF programmers at a dinner party, right?

00:25:45.800 --> 00:25:46.140
<v David Kopec>Absolutely.

00:25:46.750 --> 00:25:48.940
<v David Kopec>But plenty of people said they were basic programmers.

00:25:49.460 --> 00:25:54.000
<v David Kopec>And it was the first programming language of a lot of people who grew up in the 70s, 80s, or even the 90s.

00:25:54.000 --> 00:25:55.220
<v David Kopec>It was my first programming language.

00:25:55.740 --> 00:26:00.460
<v David Kopec>And there was a dialect of BASIC called Tiny BASIC that came out in the late 1970s.

00:26:00.620 --> 00:26:03.360
<v David Kopec>It was actually one of the first free software projects.

00:26:04.100 --> 00:26:09.320
<v David Kopec>And it would run on machines that just had two or four kilobytes of RAM.

00:26:09.940 --> 00:26:12.080
<v David Kopec>So that's why it was called Tiny BASIC.

00:26:12.400 --> 00:26:13.320
<v David Kopec>I mean, it truly was tiny.

00:26:13.780 --> 00:26:17.220
<v David Kopec>And so we re-implemented dialect of Tiny BASIC in Chapter 2.

00:26:17.300 --> 00:26:25.320
<v David Kopec>So this is re-implementing a real programming language that people actually used for real work in the late 1970s and up to the early 1980s.

00:26:25.940 --> 00:26:28.300
<v David Kopec>and it can run real programs from that period.

00:26:28.500 --> 00:26:30.900
<v David Kopec>So you could go download a program from the late 70s.

00:26:31.200 --> 00:26:34.180
<v David Kopec>We were missing like one or two features from the real language.

00:26:34.760 --> 00:26:36.620
<v David Kopec>But if you have a program, not all programs use all those features.

00:26:37.180 --> 00:26:38.560
<v David Kopec>You could actually run it in this interpreter.

00:26:38.780 --> 00:26:44.780
<v David Kopec>So we go from the first language where it's really esoteric, educational, you know, weird language to the second chapter.

00:26:45.080 --> 00:26:45.780
<v David Kopec>This was a real thing.

00:26:46.840 --> 00:26:47.780
<v Michael Kennedy>Yeah, absolutely it was.

00:26:48.280 --> 00:26:50.680
<v Michael Kennedy>You know, I'm just going to give a little shout out to Visual Basic.

00:26:51.700 --> 00:26:51.860
<v David Kopec>Yeah.

00:26:52.100 --> 00:26:53.900
<v Michael Kennedy>I don't know if you, did you ever do Visual Basic?

00:26:54.320 --> 00:26:57.140
<v David Kopec>I did, and I did a version on the Mac called Real Basic.

00:26:57.640 --> 00:26:59.240
<v David Kopec>So this is really esoteric.

00:26:59.440 --> 00:27:02.300
<v David Kopec>But anyone who used Real Basic late 90s, I'm in your camp.

00:27:02.800 --> 00:27:03.320
<v Michael Kennedy>There you go.

00:27:04.880 --> 00:27:12.340
<v Michael Kennedy>I don't know if we even today still have something as approachable and productive as Visual Basic was.

00:27:12.740 --> 00:27:14.780
<v Michael Kennedy>For people who haven't used it, you're like, there's just no way.

00:27:14.960 --> 00:27:16.000
<v Michael Kennedy>There's no way that this basic.

00:27:16.580 --> 00:27:18.120
<v Michael Kennedy>But you would just get a visual thing.

00:27:18.120 --> 00:27:23.080
<v Michael Kennedy>You would drag it together to build your, you know, here I want to have, literally you would drag over.

00:27:23.260 --> 00:27:24.120
<v Michael Kennedy>Here's a web browser.

00:27:24.440 --> 00:27:51.159
<v Michael Kennedy>here's the address bar here's a go button and then you would you could double click the go button and we'd create an event handler and then you would go web browser dot go to text dot value or whatever i mean that was literally you could do it in five minutes you could like create something that is a functional web browser without much it was incredible and so yeah i just thinking back to a few things i built with it was amazing you know michael a lot of people agree with you there's a lot of articles

00:27:51.840 --> 00:27:54.940
<v David Kopec>that I've seen on blogs and stuff where people reminisce about Visual Basic.

00:27:55.640 --> 00:27:56.560
<v David Kopec>And I agree.

00:27:56.700 --> 00:28:00.540
<v David Kopec>I mean, for desktop app development, it was incredibly productive.

00:28:00.960 --> 00:28:06.140
<v David Kopec>I mean, I think it still rivals some of the tools we have for building web apps today.

00:28:06.300 --> 00:28:08.720
<v David Kopec>When you think about how easy it was to lay out a user interface.

00:28:09.440 --> 00:28:24.540
<v David Kopec>And for designers, it was great too, because designers didn't need to know how to code and they could lay out the interface in the same way that it would really appear in the program, which is different from how designers work today, where they'll often do mock-ups and the developer will have to take the mock-up and turn it into code.

00:28:25.220 --> 00:28:33.240
<v David Kopec>And so you kind of lose something there with the designer being able to have the final product in front of them as they're changing around how things look.

00:28:34.240 --> 00:28:37.400
<v David Kopec>So there were elements of it that were still missing today, I think.

00:28:37.900 --> 00:28:40.360
<v Michael Kennedy>Yeah, I think it really hasn't been matched.

00:28:40.420 --> 00:28:46.820
<v Michael Kennedy>You know, Windows forms from.NET kind of approached that, but it was still itself was also a little bit more complicated.

00:28:47.020 --> 00:28:49.100
<v Michael Kennedy>Just there was something special about that.

00:28:49.680 --> 00:29:01.340
<v Michael Kennedy>And now, don't get me wrong, it's not like I'm saying we should just go back to it, because the software we build is way more advanced, does a lot of other things, but there's just that lower area is just kind of missing.

00:29:01.510 --> 00:29:05.020
<v Michael Kennedy>And I want to talk, sort of transition from that to something else, really.

00:29:05.430 --> 00:29:09.520
<v Michael Kennedy>We're looking at these two examples of the BF language interpreter and the basic interpreter.

00:29:11.860 --> 00:29:17.880
<v Michael Kennedy>I hear that to really understand computer science, really to work on these things, I have to.

00:29:18.740 --> 00:29:19.440
<v Michael Kennedy>It's not preferable.

00:29:19.560 --> 00:29:23.400
<v Michael Kennedy>I have to do a language with pointers, malloc, free.

00:29:24.240 --> 00:29:24.900
<v Michael Kennedy>I've got to.

00:29:25.240 --> 00:29:27.340
<v Michael Kennedy>I've got to work at that level, or I just won't understand anything.

00:29:28.360 --> 00:29:30.580
<v Michael Kennedy>In Python, we don't really have those concepts.

00:29:30.960 --> 00:29:37.480
<v Michael Kennedy>And the irony, I think, is Python has more pointers than C++ because there's no stack at all, not at all, really.

00:29:37.570 --> 00:29:39.900
<v Michael Kennedy>I mean, in the interpreter there is, but not in your writing.

00:29:40.160 --> 00:29:42.080
<v Michael Kennedy>Even a number one is just a pointer.

00:29:44.460 --> 00:29:47.920
<v Michael Kennedy>So Python's full of pointers, but not in the way that computer science thinks about it.

00:29:48.420 --> 00:29:51.500
<v Michael Kennedy>What are your thoughts about that sort of tension, right?

00:29:51.530 --> 00:30:02.560
<v Michael Kennedy>On one hand, you have this really understandable language talking about these ideas, but the computer is calling malloc on a page of memory and that's what's happening and they're not seeing it.

00:30:03.159 --> 00:30:06.600
<v David Kopec>Okay, so let me talk about it from a pedagogy standpoint.

00:30:07.060 --> 00:30:09.720
<v Michael Kennedy>So at my last institution, Champlain College,

00:30:09.960 --> 00:30:11.920
<v David Kopec>we had a big debate over my nine years there.

00:30:12.010 --> 00:30:15.740
<v David Kopec>Should we do our first three classes in Python or in C++?

00:30:16.540 --> 00:30:19.120
<v David Kopec>And when I came in, the first three classes were in C++.

00:30:19.360 --> 00:30:22.820
<v David Kopec>And we actually decided over the years to keep it there for exactly what you mentioned.

00:30:22.880 --> 00:30:32.900
<v David Kopec>We wanted to give students both that high-level experience with object-oriented programming, but we also wanted them to have experience with pointers, with memory management, and understand how things work at a low level.

00:30:33.440 --> 00:30:39.560
<v David Kopec>But in that same period of time, many schools have moved to Python because of the other thing we talked about, which is accessibility.

00:30:40.860 --> 00:30:45.260
<v David Kopec>I think Python simply is an easier language to learn than C++.

00:30:45.780 --> 00:30:49.240
<v David Kopec>I don't think that most people who know both languages would really debate that.

00:30:50.060 --> 00:30:59.940
<v David Kopec>And so if we're trying to make those first ramp up classes where you're first learning CS as easy as possible, I think Python is the way to go if we want to encourage more people into

00:31:00.040 --> 00:31:05.280
<v Speaker 3>the discipline. That doesn't mean there shouldn't be a C or C++ course later on, where folks,

00:31:05.700 --> 00:31:17.060
<v David Kopec>maybe when they take operating systems or even as part of an architecture class to see how the assembly language matches to a C program, that kind of thing. It doesn't mean there shouldn't be C or C++ in the curriculum or Rust or whatever.

00:31:17.960 --> 00:31:24.320
<v David Kopec>But if we're thinking about what's best for a student who's just coming into the field, I think we need to think about accessibility.

00:31:25.520 --> 00:31:31.520
<v David Kopec>But at the same time, my advice to all students is learn one language well before you learn any other language.

00:31:32.020 --> 00:31:33.480
<v David Kopec>So whether you're starting with Python

00:31:33.640 --> 00:31:34.760
<v Speaker 3>or you're starting with C++,

00:31:36.060 --> 00:31:42.600
<v David Kopec>spend a year or two on it and become really decent at it before you go and learn another language.

00:31:42.900 --> 00:31:45.960
<v David Kopec>And that's the biggest mistake I see folks who are self-taught make.

00:31:46.240 --> 00:31:50.560
<v David Kopec>The biggest mistake I see folks who are self-taught make is constantly switch around from language to language.

00:31:51.100 --> 00:31:51.960
<v Michael Kennedy>I need to know this.

00:31:52.220 --> 00:31:52.880
<v Michael Kennedy>Okay, I got it.

00:31:53.000 --> 00:31:54.100
<v Michael Kennedy>Now it's time to learn this.

00:31:54.200 --> 00:31:56.640
<v Michael Kennedy>And they're trying to fill all these gaps, right?

00:31:57.040 --> 00:31:57.420
<v David Kopec>Right, right.

00:31:57.660 --> 00:32:02.200
<v David Kopec>Because once you learn Python well, a lot of the stuff in C or C++ will make sense to you.

00:32:02.200 --> 00:32:06.580
<v David Kopec>The pointers might not, but a lot of the other stuff, like how does a function work?

00:32:06.720 --> 00:32:07.360
<v David Kopec>How does a loop work?

00:32:07.780 --> 00:32:08.560
<v David Kopec>What are variables?

00:32:09.240 --> 00:32:10.160
<v David Kopec>What's a global versus local?

00:32:10.240 --> 00:32:10.880
<v David Kopec>All that kind of stuff.

00:32:11.600 --> 00:32:12.700
<v David Kopec>That's going to make sense to you.

00:32:12.780 --> 00:32:18.160
<v David Kopec>And that's going to be transferable skills once you've really learned it in any one language across any other language.

00:32:18.270 --> 00:32:19.920
<v David Kopec>And then pointers you can learn later on.

00:32:19.920 --> 00:32:22.900
<v David Kopec>You don't need to learn that at the beginning of your CS education.

00:32:23.840 --> 00:32:26.660
<v David Kopec>It's not people make it sound like it's a totally mystical topic.

00:32:27.900 --> 00:32:34.520
<v David Kopec>If you are able to do calculus, which basically every CS degree requires calculus one, you can learn pointers.

00:32:35.300 --> 00:32:37.040
<v Michael Kennedy>You'll be OK. You can learn pointers.

00:32:38.000 --> 00:32:41.880
<v Michael Kennedy>Yeah, exactly. Like double integrals and all that kind of stuff is way worse.

00:32:43.820 --> 00:33:13.740
<v Michael Kennedy>I feel like you could also cycle right so you could start with Python for a couple of classes then go deeper closer to the machine with C but then you could come back and say let's look at Python again with new eyes and try to understand interpreted dynamic languages better because now you know you can take the red pill and you can see the arenas and the blocks of the memory allocator and the GC and all that kind of stuff, right?

00:33:13.800 --> 00:33:16.440
<v Michael Kennedy>You could go, actually, you didn't know any of this stuff.

00:33:16.440 --> 00:33:19.420
<v Michael Kennedy>You didn't, nobody probably even thought to think, is this here?

00:33:20.580 --> 00:33:24.880
<v Michael Kennedy>And yet look at what's underneath that you're taking, you're building on top of, right?

00:33:25.320 --> 00:33:28.400
<v David Kopec>Yeah, and also remember how long an academic semester is.

00:33:28.520 --> 00:33:29.360
<v David Kopec>It's 15 weeks.

00:33:29.820 --> 00:33:34.440
<v David Kopec>So if you're taking a class in college, you're forced to be doing that same language for 15 weeks.

00:33:34.900 --> 00:33:39.320
<v David Kopec>That's really the challenge for self-taught folks is they could just spend two days on one, two days on another, right?

00:33:39.540 --> 00:33:40.200
<v Michael Kennedy>But absolutely, you're right.

00:33:40.400 --> 00:33:43.520
<v David Kopec>Once you've had enough time in one, you can cycle to the others back and forth.

00:33:44.130 --> 00:33:44.540
<v Michael Kennedy>Yeah, fine.

00:33:46.360 --> 00:34:01.860
<v Michael Kennedy>I personally am a fan of it being in Python because I feel like one of the biggest challenges to keeping people in computer science and programming is that they don't get enough early wins and early like, yes, aha, right?

00:34:02.040 --> 00:34:07.400
<v Michael Kennedy>It's like, okay, in week 12, we'll let you write a program, but we're going to talk pointers for a while.

00:34:07.950 --> 00:34:09.879
<v Michael Kennedy>And then you'll finally get to make some, you know what I mean?

00:34:10.020 --> 00:34:15.860
<v Michael Kennedy>Like it's just so delayed and that's fine for certain people, but there's a lot of people are like, oh, forget this.

00:34:16.520 --> 00:34:17.960
<v David Kopec>This is not what I thought I'm out.

00:34:18.440 --> 00:34:21.919
<v David Kopec>And a huge part of that is the Python library ecosystem.

00:34:22.600 --> 00:34:28.840
<v David Kopec>How easy it is to drop PI game into an intro class and get somebody building a really simple game.

00:34:29.919 --> 00:34:37.399
<v David Kopec>You know, it's much harder in C or C++ to start integrating libraries and start having students understand how to use those libraries.

00:34:37.500 --> 00:34:43.179
<v David Kopec>And it usually requires a lot more knowledge buildup to be able to use pointers and stuff with those libraries.

00:34:43.610 --> 00:34:45.419
<v David Kopec>So Python just makes everything more accessible.

00:34:46.100 --> 00:34:46.520
<v Michael Kennedy>Awesome.

00:34:47.919 --> 00:34:48.020
<v Michael Kennedy>Cool.

00:34:48.320 --> 00:34:48.600
<v Michael Kennedy>All right.

00:34:49.100 --> 00:34:59.520
<v Michael Kennedy>The next area that was pretty interesting and a little bit, maybe a little artsy, is the computational art.

00:34:59.620 --> 00:35:00.260
<v Michael Kennedy>Tell us about that.

00:35:01.180 --> 00:35:01.340
<v David Kopec>Yeah.

00:35:01.410 --> 00:35:04.360
<v David Kopec>So there's two chapters in the book on computational art.

00:35:04.440 --> 00:35:08.880
<v David Kopec>The first one is really starting to understand what a pixel is on the screen.

00:35:09.260 --> 00:35:19.360
<v David Kopec>And the way we do that is we take modern photos and then we want to display them on like an ancient Mac, a Mac from the 1980s, like the Mac Plus.

00:35:20.220 --> 00:35:31.120
<v David Kopec>And so we're going to take that modern photo and use what's called a dithering algorithm to break it down into patterns of black and white pixels, because those early Macs were only black and white.

00:35:31.180 --> 00:35:35.740
<v David Kopec>that will then still kind of look like the photo in black and white with these specialized patterns.

00:35:36.440 --> 00:35:38.420
<v David Kopec>So you're learning a bunch of things by doing this.

00:35:38.600 --> 00:35:40.780
<v David Kopec>One thing you're learning is you're learning really what is a pixel.

00:35:41.020 --> 00:35:43.240
<v David Kopec>And a pixel is really pretty simple at its base.

00:35:43.360 --> 00:35:45.060
<v David Kopec>I mean, it's just a color and a location.

00:35:46.320 --> 00:35:48.360
<v David Kopec>And so understanding how those pixels are organized.

00:35:49.200 --> 00:35:55.480
<v David Kopec>And really, they're just organized usually as an array or, you know, as a list in Python or a numpy array or whatever.

00:35:56.800 --> 00:35:59.200
<v David Kopec>And then we're understanding some algorithmic stuff.

00:35:59.440 --> 00:36:03.020
<v David Kopec>So understanding that dithering algorithm is giving us some algorithmic practice.

00:36:03.580 --> 00:36:11.280
<v David Kopec>And then a cool thing we do at the end is we actually convert it into a file format called Mac Paint for displaying on, you know, an ancient Mac.

00:36:11.660 --> 00:36:17.640
<v David Kopec>And that Mac Paint format uses a very simple compression scheme called run length encoding.

00:36:18.140 --> 00:36:23.480
<v David Kopec>So we're getting some other kind of algorithmic practice in there as well, understanding a simple compression algorithm.

00:36:23.860 --> 00:36:29.680
<v David Kopec>And we're understanding something about file formats too, which is really kind of an interesting CS topic as well.

00:36:29.780 --> 00:36:30.540
<v Speaker 3>Yeah, it sure is, yeah.

00:36:30.810 --> 00:36:35.420
<v David Kopec>Because we have to properly format the file so the Mac Paint program on the ancient Mac will open it correctly.

00:36:36.360 --> 00:36:44.360
<v Michael Kennedy>Yeah, that was something actually when I first got into programming, I feel like I just stuck with text-oriented files pretty much as long as I could.

00:36:46.300 --> 00:36:58.180
<v Michael Kennedy>Because looking at a binary file, it has a header and we read the first few bytes and then the value of that byte tells you how long the rest of the header is and then like what this means and then you skip.

00:36:58.720 --> 00:37:03.100
<v Michael Kennedy>And I don't know, that was just, it was a bridge too far for me in my early programming days.

00:37:03.860 --> 00:37:04.980
<v Michael Kennedy>And I was like, wow, this is intense.

00:37:05.720 --> 00:37:08.560
<v Michael Kennedy>And I was in awe of people like, yeah, we just read the header and we do this.

00:37:08.620 --> 00:37:11.480
<v Michael Kennedy>I'm like, okay, if you say so.

00:37:12.740 --> 00:37:16.280
<v David Kopec>You know, it's a classic CS trade-off between time and space.

00:37:16.820 --> 00:37:19.720
<v David Kopec>Anything that we do in a binary file, we could do in a text file.

00:37:20.660 --> 00:37:28.300
<v David Kopec>But binary files can be more efficient because they can be more compact and they can be faster to read from for certain kinds of data.

00:37:28.960 --> 00:37:37.580
<v David Kopec>So, you know, it's not that we have to use binary files, but understanding what a binary file format is like can be eye opening to some readers.

00:37:38.360 --> 00:37:42.380
<v Speaker 3>And if you think about like modern file formats, of course, text formats are much more explainable.

00:37:42.640 --> 00:37:49.780
<v David Kopec>Right. That's why we have the rise of things like XML in the late 90s up to today or even JSON as a data change data interchange format.

00:37:50.020 --> 00:37:56.540
<v David Kopec>There's alternatives to JSON, of course, that are much more efficient for coding your web app and for distributing the data back and forth.

00:37:57.200 --> 00:37:58.260
<v Speaker 3>But JSON is human readable.

00:37:59.160 --> 00:37:59.640
<v Speaker 3>Yeah, yeah, yeah.

00:38:00.190 --> 00:38:01.280
<v David Kopec>But JSON is human readable.

00:38:01.530 --> 00:38:06.740
<v David Kopec>So we can right away understand what it's supposed to represent and debug it really well.

00:38:07.290 --> 00:38:09.180
<v David Kopec>And so it's one of those classic tradeoffs.

00:38:09.230 --> 00:38:18.380
<v David Kopec>We can have something more efficient or we can have something that might take up a little bit more time, but actually is better for us as human beings.

00:38:19.100 --> 00:38:19.280
<v Michael Kennedy>Yeah.

00:38:21.480 --> 00:38:33.400
<v Michael Kennedy>it's just, I think it's a good skill. And also something that was prevalent throughout the book is juggling bits, bits and bytes, not just juggling bytes, but bits and bit flipping and shifting.

00:38:33.760 --> 00:38:39.100
<v Michael Kennedy>And there's a lot of that going on, especially in the emulator layers and stuff like that.

00:38:39.860 --> 00:38:49.480
<v David Kopec>Yeah. And even in the Mac paint chapter, because the way Mac paint stores pixels is as individual bits. So you have like a one or a zero representing a black or a white pixel on the screen.

00:38:50.000 --> 00:38:56.600
<v David Kopec>And so you have to find a way to take those bits and compact them into bytes and then run the right run length encoding algorithm to compress it.

00:38:56.720 --> 00:39:03.060
<v David Kopec>It's yeah, but there's a lot of that. And, you know, when you do really low level work in computing, you need to understand bits and bytes.

00:39:03.740 --> 00:39:11.820
<v David Kopec>If you're going to if you're going to work on device drivers or operating systems or file formats, you really need to understand this stuff at an intimate level.

00:39:11.900 --> 00:39:23.000
<v David Kopec>So we try to make fun, you know, projects in the book that you get something, you know, that's interesting as a way of making this, you know, a little of sugar to help the medicine go down kind of thing.

00:39:24.200 --> 00:39:26.340
<v Speaker 3>And I also, we were talking about the computer graphics chapters.

00:39:26.500 --> 00:39:30.940
<v David Kopec>I also wanted to mention chapter four because I love the program in that called Impressionist.

00:39:31.460 --> 00:39:37.640
<v David Kopec>It makes images that look like an Impressionist painter painted a photograph.

00:39:38.220 --> 00:39:42.760
<v Speaker 3>So you give it a photograph and then it builds kind of abstract art out of that photograph.

00:39:42.970 --> 00:39:48.320
<v David Kopec>And people usually think you need a neural network for that or you need some kind of really advanced machine learning algorithm for that.

00:39:49.060 --> 00:39:53.180
<v David Kopec>But actually, we show in the chapter that you can do it using a pretty simple algorithm.

00:39:53.360 --> 00:40:05.020
<v David Kopec>All the algorithm does is it puts a vector shape on the screen and it tries to position the vector shape so that it overlaps a region of color on the original photo that is close to the color in the vector shape.

00:40:05.440 --> 00:40:12.040
<v David Kopec>And if you keep doing that and you put enough vector shapes on the screen, you start to have like abstract shapes that look like the original photo.

00:40:12.600 --> 00:40:21.000
<v David Kopec>And so I think that's that chapter is kind of powerful because it shows you how a simple technique, a simple computational technique can really have some pretty powerful output.

00:40:22.640 --> 00:40:24.960
<v Michael Kennedy>Yeah, it's a really interesting idea and it comes out looking great.

00:40:25.120 --> 00:40:33.420
<v Michael Kennedy>It's sort of it's approaching the problem from a different perspective, which I suspect is probably a pretty interesting CS lesson.

00:40:34.040 --> 00:40:40.580
<v Michael Kennedy>You know, there's these problems that are incredibly expensive and difficult to compute the one true answer.

00:40:41.460 --> 00:40:45.920
<v Michael Kennedy>But then there's amazingly fast ways to get a, that's pretty much it, answer.

00:40:46.380 --> 00:40:49.000
<v Michael Kennedy>I'm thinking like Monte Carlo simulations and stuff like that.

00:40:49.200 --> 00:40:52.000
<v Michael Kennedy>You're like, this could take two weeks or three milliseconds.

00:40:52.300 --> 00:40:53.020
<v Michael Kennedy>Which would you prefer?

00:40:53.420 --> 00:40:54.820
<v David Kopec>You know, you're pretty much going to get the same answer.

00:40:55.580 --> 00:40:55.700
<v David Kopec>Yeah.

00:40:56.540 --> 00:41:00.080
<v David Kopec>And, you know, we talked about like why is the book in Python?

00:41:00.660 --> 00:41:08.360
<v David Kopec>And, you know, that is one of the challenges of writing the book in Python is simply Python doesn't have great performance when you write in pure Python.

00:41:09.340 --> 00:41:16.120
<v David Kopec>And so, you know, we've all seen the benchmarks where Python's like 50 or 70 times slower than C on certain benchmarks.

00:41:16.430 --> 00:41:46.920
<v David Kopec>Right. And yeah, honestly, for some of the programs in this book, you really see that performance deficit you have with Python, like the abstract art chapter, where if I wrote that same program in C using some C graphics library instead of in Python with Pillow, even though Pillow, I think, is mostly implemented in C anyway, but still just with the overhead of having our algorithmic part of it in Python, that program is probably 30, 50 times slower than it would be in C. So you have to wait like 20 minutes to see that abstract

00:41:47.340 --> 00:42:10.160
<v Michael Kennedy>art that would have been like less than a minute in a C program. Not that it's relevant to the book or the courses, but you probably could bring in some optimizations like Cython or Numba, a couple of the things that'll take just the inner two loops and just make them go different,

00:42:10.400 --> 00:42:29.740
<v David Kopec>but it's not the point of the book. That's true. And so I put that as an exercise for the reader in the NES emulator chapter, because the NES emulator chapter, where we actually build up a real NES emulator. So this, I didn't write in the book for legal reasons, but it can actually play Donkey Kong. So it can play Donkey Kong from the original Nintendo Entertainment System.

00:42:29.820 --> 00:42:33.420
<v Michael Kennedy>Let's talk about the NES, the Nintendo Entertainment System.

00:42:33.900 --> 00:42:54.700
<v David Kopec>Yeah. So, I mean, the NES, a lot of us remember growing up with, and if you're of a younger generation, this was like the main video game system of the 1980s to early 1990s that everyone had. It's where the original Super Mario came out, the original Legend of Zelda. And, you know, it's actually, of course, like all video game systems, it's a computer. And being a video game

00:42:54.880 --> 00:43:00.080
<v Speaker 3>system from the 1980s, it's a pretty simple computer, actually. It has a 6502 microprocessor,

00:43:00.540 --> 00:43:15.120
<v David Kopec>which is the same microprocessor that was in the Apple II or the Commodore 64 or the TRS, I think the TRS-80 also. And that microprocessor, it only has 56 instructions, the NES version of it.

00:43:15.740 --> 00:43:30.220
<v David Kopec>And so you can write an interpreter for that microprocessor pretty compactly, not quite as compact as the BF interpreter in chapter one, but compactly enough that it's only a few hundred lines of Python to be able to really write a simulator of that CPU.

00:43:30.980 --> 00:43:38.400
<v David Kopec>And so the NES is just that CPU plus a graphics processor called the picture processing unit, plus an audio processor.

00:43:38.960 --> 00:43:41.580
<v David Kopec>So in the chapter, we implement the full CPU.

00:43:42.260 --> 00:43:49.040
<v David Kopec>We implement a simplified version of the PPU, not advanced enough to run Super Mario Brothers, but it is advanced enough to run Donkey Kong.

00:43:50.200 --> 00:43:52.200
<v David Kopec>And we don't implement the APU.

00:43:52.250 --> 00:43:55.760
<v David Kopec>So the audio processing unit's a little more complicated and we don't do the audio.

00:43:56.310 --> 00:43:59.260
<v David Kopec>But we do all of this in the chapter so you can run real NES games.

00:44:00.040 --> 00:44:03.340
<v David Kopec>And what you're getting is you're getting to understand that software hardware interface.

00:44:03.570 --> 00:44:13.560
<v David Kopec>You're starting to understand like, how does our software actually get run on hardware by re-implementing what a CPU actually does?

00:44:13.980 --> 00:44:15.540
<v David Kopec>And you're re-implementing the memory map too.

00:44:15.600 --> 00:44:17.340
<v David Kopec>So how does the CPU connect to memory?

00:44:17.760 --> 00:44:19.760
<v David Kopec>How does the CPU connect to the graphics processor?

00:44:20.540 --> 00:44:22.340
<v David Kopec>You're doing all of that in that chapter.

00:44:23.100 --> 00:44:33.980
<v Michael Kennedy>And so it's kind of like- Yeah, so before you talked about like writing an interpreter for the BF in basic languages, here you're completely emulating the hardware.

00:44:35.120 --> 00:44:43.860
<v Michael Kennedy>of the NES and you're giving it the potentially given it open source NES games and it can run them,

00:44:44.020 --> 00:45:38.060
<v David Kopec>right? Correct. Yeah. It runs several NES open source games. Like I said, I didn't put it for legal reasons, but it can run real commercial games as well for the NES. And so you're doing the whole soup to nuts, like entire system, except the audio, but it is Python and it's pure Python, except for, of course, the library we're using. And we're using,  Pygame for, for displaying the window, which is written a lot of it in C. But because it's pure Python, the emulator doesn't run at full speed. So it runs on my Mac. It runs at about 15 frames per second. The real NES ran at 60 frames per second. So we leave as an exercise to the reader. Yeah, go use Cython or something like that. And I'm sure you can get this up with several different techniques. Definitely with Cython, but with several different techniques, you could get this up to 60 frames per second, but you're going to have to incorporate something that gets outside of just pure Python.

00:45:38.500 --> 00:45:38.920
<v Michael Kennedy>Sure.

00:45:41.620 --> 00:45:50.300
<v Michael Kennedy>There's a bunch of ways that you already mentioned, but one new way that's kind of officially new just this month is free-threaded Python.

00:45:51.720 --> 00:45:58.620
<v Michael Kennedy>And I went back to my async programming course where there's a lot of examples of like, let's do this synchronously.

00:45:58.760 --> 00:45:59.860
<v Michael Kennedy>Now let's do it with threads.

00:46:00.040 --> 00:46:39.320
<v Michael Kennedy>let's do it with multiprocessing now let's do it with async io right and see like how those all compare and the threads one anything was computational it's like yeah it's the same speed or maybe even slower right but then i ran it with i did uv run --python 3.14 t and it went 10 times faster or eight times faster or on my 10 core machine and it's literally just running on the i didn't change the codes from pre free threaded python and it just took off So I'm thinking here, there's graphics amongst many things is primed for this embarrassingly parallel processing.

00:46:40.260 --> 00:46:45.180
<v Michael Kennedy>You could break up the screen into little chunks and go, well, we got 10 chunks and 10 cores.

00:46:45.960 --> 00:46:46.320
<v Michael Kennedy>Let's go at it.

00:46:47.100 --> 00:46:49.320
<v David Kopec>What do you think about it as a plausibility?

00:46:50.120 --> 00:46:56.880
<v David Kopec>Unfortunately, for a lot of emulators, especially emulators that are for more modern systems, threading would be a huge advantage.

00:46:57.000 --> 00:47:00.960
<v David Kopec>For the NES, it's not because of the way that everything was timed.

00:47:01.840 --> 00:47:11.100
<v David Kopec>So every time that the CPU does one cycle, the PPU, the picture processing unit, has to be timed to do exactly three cycles.

00:47:11.800 --> 00:47:16.060
<v David Kopec>So you can't just go ahead and, you know, you don't just give it work.

00:47:16.140 --> 00:47:18.780
<v David Kopec>It's not like a modern GPU where you just give it a bunch of chunks of work.

00:47:18.800 --> 00:47:21.640
<v David Kopec>It works on its own and then provides that to the screen.

00:47:22.160 --> 00:47:24.080
<v David Kopec>It's completely synchronized to the CPU.

00:47:24.680 --> 00:47:26.580
<v Speaker 3>And so is the audio processing unit, too.

00:47:26.760 --> 00:47:29.480
<v Michael Kennedy>So it all has to kind of be synchronized within a single thread.

00:47:29.710 --> 00:47:32.340
<v Michael Kennedy>And all the games assume that that's how it works, right?

00:47:32.480 --> 00:47:33.480
<v Michael Kennedy>That's how they have it all set.

00:47:33.570 --> 00:47:33.680
<v Michael Kennedy>Yeah.

00:47:34.160 --> 00:47:34.380
<v David Kopec>Yeah.

00:47:34.490 --> 00:47:34.580
<v David Kopec>Yeah.

00:47:34.650 --> 00:47:43.740
<v David Kopec>And what they had, what was called a V blank period, which was a period where it had already drawn the screen and then it actually tells the CPU, hey, I'm done drawing the screen.

00:47:43.920 --> 00:47:47.480
<v David Kopec>Now you can do all kinds of work and be ready for the next time that you draw the next frame again.

00:47:48.380 --> 00:47:52.000
<v David Kopec>So they had really tight synchronization between the graphics and the CPU.

00:47:53.160 --> 00:47:53.380
<v Michael Kennedy>Interesting.

00:47:55.200 --> 00:47:55.660
<v Michael Kennedy>Still cool.

00:47:56.420 --> 00:48:05.060
<v Michael Kennedy>Still pretty cool. There's a lot going on there. If you want to understand hardware, that's a pretty low level look at it, right? I think it's kind of the crown jewel of the book.

00:48:05.260 --> 00:48:29.380
<v David Kopec>You know, there's a lot of people who are interested in emulators. And what I found before writing the book is there's not a single book out there that talks about writing an NES emulator, which is the most common emulator that people want to write. So I think this is the first book that has a chapter on writing an NES emulator. I will admit I was a little scared of like if Nintendo's legal team is going to like be upset about the book or something like that.

00:48:29.520 --> 00:48:31.020
<v David Kopec>But we did research on it.

00:48:31.020 --> 00:48:34.740
<v David Kopec>I mean, everything we're doing is perfectly legal in the book in the United States, at least.

00:48:36.180 --> 00:48:36.860
<v David Kopec>So, yeah.

00:48:37.800 --> 00:48:38.380
<v Speaker 3>But anyway.

00:48:38.400 --> 00:48:38.720
<v Speaker 3>Scary, right?

00:48:38.980 --> 00:48:39.800
<v Speaker 3>Yeah, absolutely.

00:48:40.120 --> 00:48:43.280
<v David Kopec>And we put a big disclaimer at the top of the chapter, as you remember reading.

00:48:44.280 --> 00:48:48.240
<v Michael Kennedy>I have a legal, I have a Nintendo story for you.

00:48:48.820 --> 00:48:49.060
<v David Kopec>Great.

00:48:49.220 --> 00:48:50.300
<v Michael Kennedy>From when I was young.

00:48:50.480 --> 00:48:58.960
<v Michael Kennedy>And this was, I think this is very late 80s, early 90s, last century.

00:48:59.540 --> 00:49:00.440
<v Michael Kennedy>Now, this was not me.

00:49:01.460 --> 00:49:08.020
<v Michael Kennedy>Someone I knew, someone I was friends with, had, I think it was a Super NES.

00:49:08.950 --> 00:49:09.100
<v Michael Kennedy>Okay.

00:49:09.340 --> 00:49:15.820
<v Michael Kennedy>And people may not remember, but they had these big honking cartridges that go chonk, honk, and you would chunk them down in there.

00:49:16.340 --> 00:49:23.700
<v Michael Kennedy>You would turn on, you basically reboot the NES and it would boot up from the big cartridge, game cartridge you put in there.

00:49:25.400 --> 00:49:32.100
<v Michael Kennedy>And there was this guy that they've, they found somehow, I don't, because there's no internet.

00:49:32.520 --> 00:49:34.640
<v Michael Kennedy>Maybe it's through a BBS. I don't know how this was found.

00:49:35.540 --> 00:49:41.020
<v Michael Kennedy>But they found this guy who built a thing that the bottom half of it looked like a game cartridge.

00:49:42.060 --> 00:49:49.840
<v Michael Kennedy>The top was this whole computer that at the top of it, it had a 3.5 inch floppy drive.

00:49:50.600 --> 00:49:50.720
<v David Kopec>Wow.

00:49:51.300 --> 00:50:00.360
<v Michael Kennedy>So you would go to your BBS, you would find a game, you would put it on a floppy, and then you would slot this huge extra computer down into the NES and you would turn it on.

00:50:01.080 --> 00:50:07.280
<v Michael Kennedy>And it would like delegate the file IO through the little fake cartridge back to it.

00:50:07.840 --> 00:50:08.860
<v Michael Kennedy>And it worked like crazy.

00:50:08.860 --> 00:50:09.360
<v Michael Kennedy>It was perfect.

00:50:10.180 --> 00:50:12.000
<v Michael Kennedy>That guy was not in business for very long.

00:50:12.180 --> 00:50:12.900
<v Michael Kennedy>The guy who sold them.

00:50:13.200 --> 00:50:17.800
<v Michael Kennedy>Not my friend, but the person he got it from wasn't available after a while.

00:50:18.330 --> 00:50:21.380
<v David Kopec>So Super NES comes out in like 91.

00:50:22.580 --> 00:50:23.820
<v David Kopec>It might have been a regular.

00:50:24.260 --> 00:50:25.960
<v Michael Kennedy>No, I think I might have been in college.

00:50:26.160 --> 00:50:28.180
<v Michael Kennedy>So yeah, it would be 91 onward.

00:50:28.470 --> 00:50:28.560
<v Michael Kennedy>Yeah.

00:50:28.780 --> 00:50:28.940
<v David Kopec>Okay.

00:50:29.310 --> 00:50:33.360
<v David Kopec>I mean, that is very advanced for that time.

00:50:33.510 --> 00:50:37.320
<v David Kopec>When you think about the type of stuff people were modding at that time, that guy was a genius.

00:50:38.040 --> 00:50:38.680
<v David Kopec>Yeah, he was.

00:50:38.760 --> 00:50:56.080
<v Michael Kennedy>he should have been hired if he wasn't you know what i mean yeah yeah absolutely yeah he was building himself out of his dorm room or something i don't know it was i think it was in uh manhattan in uh kansas state university i'm not sure where the guy was but wow oh well anyway yeah that guy

00:50:56.100 --> 00:51:32.100
<v David Kopec>was playing with fire yeah absolutely and you know what um sometimes like understanding how the rom cartridge works right like we think again that it's like all magic right but actually what those big cartridges that we had that we like inserted in the nes were is they were mostly plastic like that did nothing and there was a little rom chip like inside the big hunk of plastic and the rom chip rom just stands for read only memory so most of them were just like a big chunk of memory with a very tiny bit of logic chips that were called mappers on the nes that said like read this memory at this time But again, it wasn't really magic.

00:51:32.320 --> 00:51:35.680
<v David Kopec>And those cartridges look so intimidating, but they were really just a big piece of memory.

00:51:36.560 --> 00:51:36.740
<v Michael Kennedy>Yeah.

00:51:37.560 --> 00:51:43.160
<v Michael Kennedy>Think about how much you've got to make that work right before you ship it.

00:51:44.040 --> 00:51:44.160
<v Michael Kennedy>Yeah.

00:51:45.080 --> 00:51:45.780
<v Michael Kennedy>There's no patches.

00:51:46.200 --> 00:51:47.240
<v Michael Kennedy>There's no download and update.

00:51:47.580 --> 00:51:49.880
<v Michael Kennedy>Once it's shipped, it's shipped.

00:51:50.440 --> 00:51:52.320
<v Michael Kennedy>And it's burned into the ROM and that's it.

00:51:52.880 --> 00:51:54.880
<v David Kopec>I have some friends who work in game development.

00:51:55.320 --> 00:52:00.160
<v David Kopec>And before they even shipped the 1.0, nowadays they're working on the first patch.

00:52:00.780 --> 00:52:04.900
<v David Kopec>and they just know they're not going to ship the perfect program in 1.0.

00:52:05.300 --> 00:52:07.020
<v David Kopec>Now, to be fair, games were much simpler

00:52:07.400 --> 00:52:09.260
<v Speaker 3>in the 1980s than they are today.

00:52:09.720 --> 00:52:10.500
<v David Kopec>But they had to be perfect.

00:52:11.220 --> 00:52:12.220
<v David Kopec>Literally had to be perfect.

00:52:13.200 --> 00:52:21.780
<v David Kopec>And so there was a certain, I think, different attitude around game development than there is today. And remember, they were also working in assembly language.

00:52:23.420 --> 00:52:26.860
<v Michael Kennedy>It's not even an easy language to work in. I don't know if people like

00:52:26.960 --> 00:52:31.740
<v David Kopec>this word, but I would call it kind of hardcore writing NES games in the 1980s.

00:52:34.600 --> 00:52:39.380
<v Michael Kennedy>It was, you know, that kind of programming, it was just different.

00:52:39.800 --> 00:52:40.520
<v Michael Kennedy>It was just different.

00:52:40.700 --> 00:52:45.660
<v Michael Kennedy>You had to be so detail-oriented and you had to be so thorough.

00:52:46.020 --> 00:52:51.400
<v Michael Kennedy>It's almost like writing, you know, spaceship control software type of thing.

00:52:52.020 --> 00:52:52.680
<v Michael Kennedy>Not quite, but almost.

00:52:53.380 --> 00:52:54.700
<v David Kopec>And the machines were so slow.

00:52:54.840 --> 00:53:04.760
<v David Kopec>The NES, which, you know, we emulate in Chapter 6, ran on a 1.8 megahertz CPU, 6502, 1.8 megahertz, right?

00:53:05.150 --> 00:53:10.020
<v David Kopec>So Super Mario was like an incredible accomplishment on a 1.8 megahertz.

00:53:10.250 --> 00:53:21.480
<v David Kopec>So people had to worry about all these computer science topics in a way that they don't today as programmers because you had to squeeze every last bit of algorithmic performance out of the machine.

00:53:22.180 --> 00:53:27.300
<v David Kopec>And so today, I think we have sloppier software today because we have an embarrassment of riches.

00:53:27.620 --> 00:53:33.120
<v David Kopec>We got such powerful computers with so much memory that people don't worry about writing things as efficiently as possible.

00:53:33.550 --> 00:53:41.000
<v David Kopec>And so we end up with inefficient software sometimes because people don't bother to do the algorithms right.

00:53:41.880 --> 00:53:47.420
<v Michael Kennedy>Yes, but I'm going to put a little double dagger, like see the footnote by your comment.

00:53:48.800 --> 00:53:53.480
<v Michael Kennedy>Absolutely true for software, not necessarily true for software developers.

00:53:54.360 --> 00:54:06.060
<v Michael Kennedy>The efficiency of writing a 99.9% correct Python program, how quickly that gets done versus something in assembly language straight on a ROM.

00:54:06.880 --> 00:54:06.960
<v Michael Kennedy>Yep.

00:54:07.480 --> 00:54:07.900
<v Michael Kennedy>You know what I mean?

00:54:08.780 --> 00:54:23.180
<v Michael Kennedy>I think this is an interesting arc, and maybe you could speak to it a little bit from your academic perspective, but I think it's a really interesting arc of it used to be really hard to program, and we'd solve small problems with lots of effort.

00:54:24.000 --> 00:54:24.960
<v Michael Kennedy>And it's getting easier.

00:54:25.010 --> 00:54:26.440
<v Michael Kennedy>And a lot of times it gets easier.

00:54:26.540 --> 00:54:27.640
<v Michael Kennedy>People say, well, there it goes.

00:54:28.440 --> 00:54:29.080
<v Michael Kennedy>Job's over.

00:54:29.660 --> 00:54:32.400
<v Michael Kennedy>There's not going to be programmers anymore because everyone can do it.

00:54:32.840 --> 00:54:35.100
<v Michael Kennedy>And we just solve bigger, more complex problems.

00:54:35.900 --> 00:54:36.900
<v Michael Kennedy>And it just keeps building.

00:54:37.430 --> 00:54:48.840
<v Michael Kennedy>You know, like a web app, a basic e-commerce app from today was a keynote presentation of how like a Fortune 500 company pulled it off in 1990.

00:54:49.070 --> 00:54:49.560
<v Michael Kennedy>You know what I mean?

00:54:49.780 --> 00:54:55.240
<v Speaker 3>Like, here's how we got the SSL termination special machines to handle the SSL decryption

00:54:55.880 --> 00:54:58.100
<v Michael Kennedy>so that we could do this under two seconds of requests.

00:54:58.300 --> 00:54:59.660
<v David Kopec>I mean, like crazy stuff.

00:55:00.080 --> 00:55:01.080
<v Michael Kennedy>What do you think about this?

00:55:01.520 --> 00:55:02.480
<v David Kopec>Well, it's not an either or.

00:55:02.740 --> 00:55:06.160
<v David Kopec>I mean, we want developers to be productive and we also want efficient software.

00:55:06.400 --> 00:55:15.440
<v David Kopec>So, I mean, the good news is that means that after we make it easier and easier to build software, we still need folks who are going to work on optimizing that software after it's built.

00:55:15.540 --> 00:55:18.540
<v David Kopec>So there's still jobs for software developers who are interested in that.

00:55:18.900 --> 00:55:28.720
<v David Kopec>I think you actually touched on this in Talk Python in production to some degree, because you talk about in the book, the appropriate level of complexity for the type of app that you're building.

00:55:29.160 --> 00:55:38.240
<v David Kopec>And so you talk about like, you know, maybe you don't need a Kubernetes cluster if you're just building, you know, something for 10 million requests a month and not something

00:55:38.440 --> 00:55:39.560
<v Michael Kennedy>for a billion requests a month.

00:55:39.600 --> 00:55:46.240
<v Michael Kennedy>And it's going to be run by one person or one person part time versus a team or somebody who's a DevOps expert, right?

00:55:46.720 --> 00:55:47.380
<v David Kopec>Right, right, right.

00:55:47.600 --> 00:56:17.380
<v David Kopec>So if I'm working on a run-of-the-mill e-commerce thing, maybe I don't worry about squeezing out every last bit of performance because I want to productively make something that, like you said, is 99.9% of the way there as quickly as possible. But if I'm building a 3D game, they still build most 3D games in C++ because they need to squeeze out every last bit of performance, even if it's a little less efficient for the programmers. The programmers could write the games faster maybe in another language or another framework than they're using, whatever.

00:56:17.860 --> 00:56:21.020
<v David Kopec>but they use something that squeezes out every last bit of performance.

00:56:21.420 --> 00:56:23.820
<v David Kopec>So I think you have to think about what is the app that we're building?

00:56:23.930 --> 00:56:25.380
<v David Kopec>What is the domain that we're in?

00:56:25.760 --> 00:56:27.540
<v Speaker 3>And it's also just not an either or.

00:56:27.800 --> 00:56:34.480
<v David Kopec>Like, you know, we want to have software that's both developer productive to build, but also that's efficient to run.

00:56:35.020 --> 00:56:36.300
<v David Kopec>And it's an ongoing process.

00:56:36.510 --> 00:56:40.600
<v David Kopec>We might need to make that trade-off more in the way when we're first building it in developer productivity.

00:56:41.180 --> 00:56:44.320
<v David Kopec>And then as we're maintaining it, maybe we go more towards the efficiency side.

00:56:44.680 --> 00:56:52.200
<v David Kopec>But if you don't think about some of the efficiency things up front, you can end up in a bad spot because you can get some technical debt.

00:56:52.230 --> 00:56:59.360
<v David Kopec>You could end up in a situation where it's hard to undo some of the algorithmic mistakes that you made early on and the system starts to depend on.

00:57:00.760 --> 00:57:02.160
<v David Kopec>So you should think about it at least a little bit.

00:57:02.460 --> 00:57:03.140
<v Michael Kennedy>Yeah, absolutely.

00:57:03.550 --> 00:57:08.780
<v Michael Kennedy>And I think you're talking about they've got to squeeze out that little extra bit of performance because they want high frame rates.

00:57:09.320 --> 00:57:14.140
<v Michael Kennedy>They might have to squeeze out that little bit extra performance because it's either possible or not possible.

00:57:15.080 --> 00:57:27.620
<v Michael Kennedy>you know you look at some of the stuff in the unreal engine these days and you're like that's real time that's the game that looks like a rendered cgi movie not a game

00:57:28.550 --> 00:57:49.720
<v David Kopec>yeah yeah yeah yeah and i mean so a lot of it is being done for us today by library authors right so library authors are thinking about a lot of the low-level stuff so us as like run-of-the-mill developers don't need to, which is great. But if you're doing something really de novo, something with an innovative algorithm, you still need to consider efficiency at least.

00:57:50.010 --> 00:58:14.280
<v Michael Kennedy>Yeah. And the other thing is, you can write really slow code in C, and you can write really fast code in Python or vice versa. It's easier to make it slow in Python, to be fair. But algorithms and data structures are tremendous influences, right? If you're using, you should a set or a dictionary and you're using a list, you're probably having a real bad time performance.

00:58:15.080 --> 00:58:47.800
<v David Kopec>And you caught me multiple times on the technical review in places where I should have used a set and I used a list. So thank you for that. But that's absolutely, that's a great example. I mean, just knowing that basic fact that, you know, in this situation, just swapping out, which is a simple switch, by the way, you know, one data structure for another can totally change the performance characteristics. That's the type of things you do learn in the CS degree that you don't necessarily learn when you're a self-taught programmer kind of hacking everything out on your own, which is why a book like classic computer science problems in Python, or maybe computer

00:58:47.890 --> 00:58:58.340
<v Michael Kennedy>science from scratch is good for that. Yeah, it exposes you to this. Here's a data structure you haven't thought about, but here's why we're using it and the advantages and stuff. Yeah, absolutely.

00:59:00.580 --> 00:59:31.400
<v Michael Kennedy>All right, well, we've covered a lot. We've covered pretty much solved computer science in 2025. That's good. And then the book is bringing computer science to so many people who are self-taught, you know, like me. I went to college, but I studied many, many years of math and found my way into programming. So I took a few CS programs, but not so many. So, you know, it certainly showed me many things that I hadn't seen. Like I've never emulated hardware before, for example. That was wild.

00:59:34.280 --> 00:59:41.720
<v David Kopec>And, you know, Michael, I was reading in Talk Python in production that you actually worked on Windows desktop apps. Is that right? I did. Yeah.

00:59:42.240 --> 00:59:45.420
<v Michael Kennedy>For 10 years, more than 10 years. Almost 15 years, yeah.

00:59:45.900 --> 00:59:54.560
<v David Kopec>Wow. So I'm curious, you know, how did you feel about that experience versus the kind of Python GUI frameworks that exist today?

00:59:56.240 --> 00:59:57.780
<v Michael Kennedy>You heard my rant about Visual Basic.

00:59:58.080 --> 00:59:59.880
<v David Kopec>I was such a fan of Windows Forms.

01:00:00.190 --> 01:00:04.600
<v Michael Kennedy>I started actually in C++, starting the hard way, doing MFC.

01:00:04.810 --> 01:00:06.620
<v Speaker 3>I don't know if you ever played with that or heard of that.

01:00:06.620 --> 01:00:07.680
<v Speaker 3>Yeah, like the soft foundation classes.

01:00:07.870 --> 01:00:08.180
<v Speaker 3>Yeah, yeah.

01:00:08.280 --> 01:00:10.660
<v Michael Kennedy>And that was actually pretty decent for C++ framework.

01:00:10.850 --> 01:00:14.600
<v Michael Kennedy>And then as soon as I found Visual Basic and C#, I'm like, this is so much better.

01:00:15.460 --> 01:00:19.400
<v Michael Kennedy>It goes from weeks to days of UI work and stuff like that.

01:00:19.430 --> 01:00:24.340
<v Michael Kennedy>And it took me a while to really appreciate building for the web.

01:00:25.100 --> 01:00:27.400
<v Michael Kennedy>I think I probably made that switch around the year 2000.

01:00:27.880 --> 01:00:32.100
<v Michael Kennedy>There's a little bit after that, but I really like the web these days.

01:00:32.190 --> 01:00:33.240
<v Michael Kennedy>I think the web is special.

01:00:33.760 --> 01:00:39.660
<v Michael Kennedy>I just wish it was easier to take apps from the web and get them to people.

01:00:39.960 --> 01:00:43.540
<v Michael Kennedy>For example, Firefox canceled progressive web apps.

01:00:44.820 --> 01:00:48.960
<v Michael Kennedy>iOS has them, but they're kind of, let's not talk about those.

01:00:49.130 --> 01:00:51.800
<v Michael Kennedy>And if you know the secret, you can probably install one, but you probably shouldn't.

01:00:52.040 --> 01:00:58.020
<v Michael Kennedy>And we're going to, you know, like if it's just, it's like right on the verge of one more step.

01:00:58.540 --> 01:01:02.380
<v Michael Kennedy>And the web would be really, a really good replacement for those.

01:01:02.640 --> 01:01:08.840
<v Michael Kennedy>And now we have things like Electron and so on, which I'm not a huge fan of, but it's, it's kind of what we need to make that happen.

01:01:09.130 --> 01:01:12.480
<v Michael Kennedy>But we don't necessarily need Electron, right?

01:01:12.510 --> 01:01:13.280
<v Michael Kennedy>It would be really great.

01:01:13.480 --> 01:01:14.700
<v Michael Kennedy>I'm also really excited.

01:01:14.790 --> 01:01:16.020
<v Michael Kennedy>I don't know how you feel about it.

01:01:16.060 --> 01:01:22.340
<v Michael Kennedy>I'm really excited about PyScript and the possibility of running Python for your front-end stuff.

01:01:23.460 --> 01:01:30.240
<v David Kopec>Well, I guess what I was getting at is why do you think Python is not taken off more for desktop GUI development?

01:01:30.330 --> 01:01:31.860
<v Speaker 3>So like we've seen things like Givi.

01:01:32.260 --> 01:01:38.660
<v David Kopec>Of course, we have PyQT and several other frameworks that wrap into older C++ GUI frameworks.

01:01:39.420 --> 01:01:42.260
<v David Kopec>But like Python now is so mature.

01:01:42.380 --> 01:01:43.680
<v David Kopec>It's the most popular language in the world.

01:01:44.160 --> 01:01:45.320
<v Michael Kennedy>There's nothing preventing it.

01:01:45.540 --> 01:01:51.900
<v Michael Kennedy>Yeah, there's nothing preventing it from making a really nice platform for native app development, right?

01:01:52.700 --> 01:02:01.400
<v Michael Kennedy>Fundamentally, you could come up with a framework that abstracts talking to Objective-C, the API's there, or the Win32 API.

01:02:02.720 --> 01:02:16.040
<v Michael Kennedy>You know, one of the things I'm starting to realize that makes desktop development really different from back in the day, if you will, there are so many gatekeepers and barriers to getting your app onto a machine, right?

01:02:16.120 --> 01:02:22.360
<v Michael Kennedy>Like if I built a cool desktop app and I gave it to you, your Mac would go, no, we're not running that.

01:02:22.560 --> 01:02:26.720
<v Michael Kennedy>We moved it to the trash for you because it wasn't notarized, right?

01:02:26.980 --> 01:02:28.680
<v Michael Kennedy>And something similar happens on Windows.

01:02:29.280 --> 01:02:32.440
<v Michael Kennedy>And so there's these steps you got to jump through.

01:02:33.200 --> 01:02:42.560
<v Michael Kennedy>And I think there's just been too many gotchas and steps for anybody to push a framework or a way of doing this all the way through.

01:02:44.040 --> 01:02:49.700
<v Michael Kennedy>I mean, in a sense, the web is kind of good enough that we don't have to figure out a way to build this.

01:02:50.800 --> 01:03:00.040
<v Michael Kennedy>I think, honestly, if I were to be more concerned, I'd be more concerned that we can't create truly straightforward mobile apps with Python than desktop apps.

01:03:00.840 --> 01:03:01.400
<v David Kopec>Yeah, what do you think?

01:03:01.760 --> 01:03:03.760
<v David Kopec>That's where I was going to go to next, yeah.

01:03:03.930 --> 01:03:05.820
<v David Kopec>And I mean, Kivy has been an attempt at that.

01:03:06.640 --> 01:03:11.380
<v David Kopec>But, you know, I don't really think it's gotten a ton of track from what I see.

01:03:12.040 --> 01:03:16.340
<v David Kopec>It doesn't look like it's gotten a ton of traction in the way people in the Python community hoped it would.

01:03:17.520 --> 01:03:18.580
<v Michael Kennedy>So, you know, I don't.

01:03:18.760 --> 01:03:21.660
<v Michael Kennedy>We're doing good work, but it's also not there yet.

01:03:21.730 --> 01:03:22.320
<v Michael Kennedy>I don't think.

01:03:22.890 --> 01:03:27.480
<v David Kopec>I wonder if some of the performance issues, you know, are part of this.

01:03:28.220 --> 01:03:36.380
<v David Kopec>So, you know, people expect one of the reasons we like desktop apps and native mobile apps over web apps is because we get instantaneous feedback.

01:03:36.440 --> 01:03:39.280
<v David Kopec>and, you know, really high performance in our user interfaces.

01:03:40.180 --> 01:03:48.540
<v David Kopec>And, you know, I still find even a PyQT app sometimes a little bit slower than, you know, a regular QT app.

01:03:48.740 --> 01:03:49.460
<v Speaker 3>Yeah, yeah.

01:03:49.700 --> 01:03:51.560
<v David Kopec>And, you know, it's unfortunate.

01:03:52.060 --> 01:03:59.840
<v David Kopec>For me, like the big want for the whole Python ecosystem is what started to be the focus, I think, of the core developers, which is performance improvements.

01:04:00.440 --> 01:04:02.240
<v Speaker 3>Like, I think that performance improvements

01:04:02.620 --> 01:04:11.260
<v David Kopec>would make everyone's lives in the ecosystem so much better, you know and so i i think rightly that that this has become like one of the central focuses

01:04:12.060 --> 01:04:28.880
<v Michael Kennedy>of um you know of the core developers yeah guido mark shannon bram buker a bunch of people whose names i'm not including they've all done really good work over the last three or four years um i was a little bit sad to see microsoft cancel that project or cancel the funding

01:04:29.020 --> 01:04:36.160
<v David Kopec>for that project i mean the project continues but still you know i like what has happened is

01:04:36.180 --> 01:04:41.040
<v Michael Kennedy>so, so much better. That is really a big deal. Yeah. Yeah. And you know, I even saw it in the

01:04:41.090 --> 01:05:00.940
<v David Kopec>course of writing the book. I started writing the book in 2021 and that NES emulator on the same machine was something like 12 frames per second in 2021. And by 2025, it was like 17 frames or 15 or 17. So it really, you know, I really saw it in these computationally intensive programs in the

01:05:00.860 --> 01:05:33.440
<v Michael Kennedy>book? I'm pretty positive for it. I mean, there's, there's a lot of things that could be better, but I think one of the real superpowers is it's approachable, but it's ceiling of Python. That is it's ceiling of what you can accomplish is not that low, right? You can go pretty far if you have CS skills and ideas. And then, you know, pip install, uv install, like the options of what is out there to just build and click together are incredible.

01:05:34.080 --> 01:05:45.100
<v David Kopec>What do you think about, and I know you talked about on the show before I heard about a while ago on the show about Mojo and about,  you know, a total attempt that, you know, let's just

01:05:46.120 --> 01:05:50.860
<v Michael Kennedy>redo it. and we'll get, let's keep the language syntax, but not the runtime.

01:05:51.360 --> 01:06:06.900
<v David Kopec>Right, right, right. And I mean, PyPy is also, of course, kind of an attempt at that as well. And some people call for it, right? I see sometimes people are like, why don't they replace CPython with PyPy? What do you think about kind of just like the whole, maybe it's too big a topic for the end of this.

01:06:06.920 --> 01:06:07.560
<v Michael Kennedy>No, it's interesting.

01:06:07.700 --> 01:06:10.900
<v Michael Kennedy>I think all of those are interesting.

01:06:11.820 --> 01:06:15.260
<v Michael Kennedy>I think the Mojo performance story is very powerful.

01:06:16.580 --> 01:06:22.460
<v Michael Kennedy>It's also really hard to bring over to CPython because there's so many different ways that it's used.

01:06:22.500 --> 01:06:28.680
<v Michael Kennedy>And there's so many-- it runs on this piece of hardware doing this thing that we just could never optimize for.

01:06:31.420 --> 01:07:05.280
<v Michael Kennedy>And then, like I said, with 600,000 or whatever there are packages, you know, how much of that are you willing to carve away to get a faster language? And what I think also is a really interesting aspect that people might not think about or take into account that often is you'll see a lot of these benchmarks like here's the three body solving the three body problem in Python and here's solving it in Mojo. Here's solving the three body problem in Rust and look at that huge difference. But what often happens in Python is you find yourself orchestrating native code anyway.

01:07:05.540 --> 01:07:09.060
<v Michael Kennedy>Like, okay, we're going to use pollers, and we're going to do this thing.

01:07:09.350 --> 01:07:12.700
<v Michael Kennedy>But when I call the pollers functions, I'm no longer running Python.

01:07:12.920 --> 01:07:16.300
<v Michael Kennedy>I'm running like a drop of Python and a bunch of Rust.

01:07:17.220 --> 01:07:18.420
<v Speaker 3>And then you write back in the same...

01:07:18.690 --> 01:07:20.640
<v Michael Kennedy>Or I'm talking to a database layer.

01:07:21.860 --> 01:07:25.600
<v Michael Kennedy>Or my web app is running on a Rust-based server.

01:07:25.720 --> 01:07:34.100
<v Michael Kennedy>There's just all these little parts where a lot of times your code speed is more about how you're putting the pieces together.

01:07:36.080 --> 01:07:36.180
<v Michael Kennedy>Yeah.

01:07:36.540 --> 01:07:36.860
<v Michael Kennedy>Not always.

01:07:36.920 --> 01:07:40.500
<v Michael Kennedy>If you're doing computational stuff, that's out the window potentially.

01:07:40.920 --> 01:07:47.260
<v Michael Kennedy>But when you're kind of, you know, you're doing machine learning, you're doing web apps, you're doing database calls.

01:07:47.300 --> 01:07:50.320
<v Michael Kennedy>A lot of these are like just a layer and then off it goes.

01:07:52.020 --> 01:07:53.320
<v David Kopec>Yeah, that totally makes sense.

01:07:53.480 --> 01:08:05.220
<v David Kopec>But then I think it is holding Python back from some of those, you know, some of these real interesting domains that people want to get into, especially when they're first learning programming, like 3D games.

01:08:12.540 --> 01:08:16.020
<v David Kopec>Let's stick with that, because I'm thinking of ones for people in computer science education.

01:08:16.880 --> 01:08:20.279
<v David Kopec>A lot of people who study computer science is because they want to make a game.

01:08:20.640 --> 01:08:20.799
<v Michael Kennedy>Sure.

01:08:21.200 --> 01:08:22.420
<v David Kopec>And when they want to make a game...

01:08:22.420 --> 01:08:23.180
<v Michael Kennedy>And I can see a world...

01:08:23.180 --> 01:08:25.359
<v Michael Kennedy>Look at one of the biggest game companies in the world.

01:08:25.520 --> 01:08:26.020
<v Michael Kennedy>It's Unity.

01:08:26.630 --> 01:08:26.759
<v Speaker 3>Yeah.

01:08:27.080 --> 01:08:27.200
<v Michael Kennedy>Right?

01:08:27.580 --> 01:09:36.160
<v Michael Kennedy>right as a foundational like building your game with not creator of games they're built i believe in csharp and.net if i remember correctly yep and that's a faster language but it's not raging fast you know it's it's it's a lot faster but it's still a decent way from a c like a pure c language right yeah a pure c implementation and they're really really successful they got close enough i could easily see some company go we're going to build a game engine and we're going to use python as the language to get as many people who have been left out in the cold in a sense to do it but we're going to do a mojo like thing or we're going to do something where you don't get to use every library but do you really need flask in your game not in your game you know what i mean yeah we're going to build like a a smaller focused high performance version that looks as close as it could be. And we're going to sell you a game engine in a way to ship those games on Steam, a way to ship those games on Metal to macOS, etc. Right?

01:09:36.319 --> 01:09:40.740
<v David Kopec>Like I could see that world happen. Yeah, yeah. I don't see me making that world, but I could see

01:09:40.859 --> 01:09:44.759
<v Michael Kennedy>that happen. And then actually, I think it would be okay. How do you feel? Like, do you see that

01:09:44.839 --> 01:10:22.380
<v David Kopec>as possible? No, that makes total sense. I think another thing we think about is like how much our skills becoming more transferable because of LLMs. So can somebody who already learned Python well, now quickly pick up C# in Unity, because the LLM is doing a lot of the detailed syntax for them. And they just have to understand the programmatic ideas. So is like, you know, maybe Python will continue to always be this great first language for everybody. And it'll be easier for people to now transition to other languages for specific domains. And so it matters less that we everything in the original language.

01:10:23.780 --> 01:10:32.420
<v Michael Kennedy>Okay, out in the chat, there's the recommendation for-- that's Godot.

01:10:32.640 --> 01:10:33.400
<v Michael Kennedy>Do you remember Godot?

01:10:33.460 --> 01:10:34.780
<v Michael Kennedy>I'm not super familiar with it.

01:10:35.000 --> 01:10:37.000
<v David Kopec>I think it's an open source game engine.

01:10:37.320 --> 01:10:39.900
<v Michael Kennedy>Yes, that much I know, but that's where my knowledge stops.

01:10:40.300 --> 01:10:49.980
<v David Kopec>Right, and I think it has like a Godot script or something, or Gscript or something, is its language, which I think has more of a Python-like syntax. Somebody in the chat

01:10:50.070 --> 01:10:50.600
<v Michael Kennedy>can correct me.

01:10:52.720 --> 01:10:59.220
<v Michael Kennedy>Interesting. Okay, but I think if you took an end-to-end thing, it's not just a matter of like, oh, you can run the game engine with this.

01:11:00.760 --> 01:11:03.960
<v Michael Kennedy>You've got to take it all the way to, here's how you ship your games.

01:11:05.020 --> 01:11:09.860
<v Michael Kennedy>Because what is the very first thing you want to do once you get your game working and fun? You want to show your friends.

01:11:10.200 --> 01:11:13.660
<v Michael Kennedy>You know what I mean? And you've got to find a way to send it out.

01:11:14.600 --> 01:11:21.820
<v David Kopec>So this goes back to what you were talking about earlier is all the hurdles around, you know, getting something on the Mac App Store, Steam or, you know, or whatever.

01:11:23.120 --> 01:11:29.800
<v David Kopec>And that goes also to another big thing that we're trying to solve in the Python ecosystem, which is the packaging story, right?

01:11:30.360 --> 01:11:36.860
<v David Kopec>Which there are many solutions for, but just not one decided on, let's make this the standard, like, you know, as easy as possible thing.

01:11:37.540 --> 01:11:38.380
<v Michael Kennedy>Yeah, it's getting better.

01:11:38.820 --> 01:11:39.760
<v Michael Kennedy>Things are definitely getting better.

01:11:39.980 --> 01:11:47.460
<v Michael Kennedy>but it's still, there is no Python build --format equals exe.

01:11:48.010 --> 01:11:48.140
<v Speaker 3>Right.

01:11:48.380 --> 01:11:59.620
<v Michael Kennedy>You know, where what comes out and then some sort of tooling that automatically signs that stuff with your certificate you've got as a Windows developer so it doesn't get flags as malware.

01:12:00.320 --> 01:12:05.100
<v Michael Kennedy>There's just, even if you get the thing to build, there's like these three or four other steps.

01:12:05.310 --> 01:12:06.960
<v Michael Kennedy>You know, I'm thinking about in iOS.

01:12:07.260 --> 01:12:17.260
<v Michael Kennedy>It's like, okay, we got it to run Python, But really what we needed to do is like integrate with Swift UI and have storyboards where I can weave it.

01:12:17.320 --> 01:12:19.880
<v Michael Kennedy>And you're like, well, that's a long ways away.

01:12:20.080 --> 01:12:23.560
<v Michael Kennedy>Like I know, but that's, you got to go through those stages to get it.

01:12:23.620 --> 01:12:24.020
<v Michael Kennedy>I don't know.

01:12:24.120 --> 01:12:27.560
<v Michael Kennedy>It's just, there's a little bit further to go, I guess.

01:12:27.680 --> 01:12:28.780
<v Michael Kennedy>But I would love to see it.

01:12:28.800 --> 01:12:30.260
<v Michael Kennedy>And I think it'll happen probably.

01:12:30.760 --> 01:12:31.880
<v David Kopec>It's not that you can't do it.

01:12:31.880 --> 01:12:33.380
<v David Kopec>It's just there's too much friction right now.

01:12:33.880 --> 01:12:34.100
<v Michael Kennedy>Yeah.

01:12:34.600 --> 01:12:34.840
<v Michael Kennedy>Yeah.

01:12:35.860 --> 01:12:35.920
<v Michael Kennedy>Yeah.

01:12:36.720 --> 01:12:39.600
<v Michael Kennedy>Well, hopefully you give some people some ideas.

01:12:40.180 --> 01:12:48.920
<v Michael Kennedy>Somebody's going to go start the Unity, the Pi Unity company or whatever, and let's make it happen.

01:12:49.320 --> 01:12:49.560
<v Speaker 3>Yeah.

01:12:50.460 --> 01:12:50.560
<v Michael Kennedy>Yeah.

01:12:51.120 --> 01:12:54.540
<v Michael Kennedy>Oh, and also just real-time follow-up out there.

01:12:54.840 --> 01:12:57.600
<v Michael Kennedy>Godot is apparently the pronunciation.

01:12:57.840 --> 01:12:58.080
<v Michael Kennedy>It's French.

01:12:58.100 --> 01:12:58.400
<v Speaker 3>Sorry.

01:12:58.940 --> 01:12:59.060
<v Michael Kennedy>Okay.

01:12:59.060 --> 01:13:00.000
<v Speaker 3>No, no, I didn't know it either.

01:13:01.220 --> 01:13:02.700
<v Michael Kennedy>I think, honestly, just shout out to everyone.

01:13:02.800 --> 01:13:07.580
<v Michael Kennedy>if you have a weird name for your project on GitHub, put an mp3 and say this is how you say it.

01:13:07.630 --> 01:13:13.480
<v Michael Kennedy>Just get it. Let's help us out. Not that French is weird, but just, you know,

01:13:14.040 --> 01:13:17.360
<v David Kopec>we should actually do that with English Project 2, right? Yeah, absolutely.

01:13:17.750 --> 01:13:31.820
<v Michael Kennedy>Yeah, even accessible to the, yeah. As simple, yeah, it has nothing to do with French. I'm thinking even as something simple as G Unicorn is often said, Gunicorn. And half the people out out there are probably thinking, Michael, you're wrong.

01:13:31.850 --> 01:13:33.040
<v Michael Kennedy>It's Goonicorn, not G-U-N-I-C-O-N.

01:13:33.960 --> 01:13:36.080
<v Michael Kennedy>But their logo is a green unicorn.

01:13:37.940 --> 01:13:40.400
<v Michael Kennedy>I'm like, well, it's probably the G stand, just G.

01:13:40.530 --> 01:13:44.360
<v Michael Kennedy>And then certainly the unicorn part is probably unicorn because unicorn is-- you know what I mean?

01:13:44.640 --> 01:13:51.060
<v Michael Kennedy>But it's totally reasonable to look at it and go, Goonicorn, you know what I mean?

01:13:51.540 --> 01:13:57.900
<v Michael Kennedy>But if they just put a little MP3, or even just a word, it's pronounced G-E-E-Dash Unicorn.

01:13:57.950 --> 01:13:58.360
<v Michael Kennedy>You know what I mean?

01:13:58.760 --> 01:13:59.160
<v Speaker 3>Yeah, yeah.

01:13:59.440 --> 01:14:00.560
<v David Kopec>I think we all need to do that.

01:14:00.810 --> 01:14:00.920
<v Michael Kennedy>Yeah.

01:14:01.200 --> 01:14:01.340
<v Michael Kennedy>Yeah.

01:14:03.900 --> 01:14:04.200
<v Michael Kennedy>All right.

01:14:04.290 --> 01:14:12.780
<v Michael Kennedy>Well, the chat is getting lively, but we're going to have to call it because we might be just a tiny bit over time and it's getting late and you're part of the world.

01:14:13.420 --> 01:14:16.860
<v David Kopec>Well, thank you so much for having me on again, Michael.

01:14:17.220 --> 01:14:17.960
<v David Kopec>It was really a pleasure.

01:14:18.240 --> 01:14:20.540
<v David Kopec>Congratulations again on Talk Python in production.

01:14:21.260 --> 01:14:21.540
<v Michael Kennedy>Thank you.

01:14:22.720 --> 01:14:24.260
<v Michael Kennedy>And Computer Science from Scratch as well.

01:14:24.660 --> 01:14:24.820
<v Michael Kennedy>Yeah.

01:14:25.080 --> 01:14:32.040
<v David Kopec>If folks want to check out the book, there's a website that I'm sure you'll put in the show notes, computersciencefromscratch.com.

01:14:32.900 --> 01:14:39.340
<v David Kopec>And you can just learn more about the different projects we do and some of the ideas in the book.

01:14:39.820 --> 01:14:40.320
<v Michael Kennedy>Yeah, awesome.

01:14:40.480 --> 01:14:42.020
<v Michael Kennedy>People want to get in touch with you otherwise?

01:14:42.220 --> 01:14:42.760
<v Michael Kennedy>How do they do that?

01:14:43.260 --> 01:14:43.580
<v David Kopec>Sure.

01:14:44.260 --> 01:14:49.100
<v David Kopec>You can find me on X, I guess, at Dave Kopech, D-A-V-E-K-O-P-C.

01:14:49.290 --> 01:14:54.640
<v David Kopec>And if you go to my website, davekopech.com, there's email and a bunch of other ways to contact me.

01:14:54.900 --> 01:14:56.900
<v David Kopec>So D-A-V-E-K-O-P-E-C.com.

01:14:57.680 --> 01:14:58.400
<v Michael Kennedy>Yeah, I'll put it in the show notes.

01:14:59.190 --> 01:14:59.620
<v David Kopec>Thanks, Michael.

01:15:00.540 --> 01:15:01.140
<v Michael Kennedy>Yeah, you bet.

01:15:01.450 --> 01:15:01.760
<v Michael Kennedy>You bet.

01:15:02.020 --> 01:15:04.940
<v Michael Kennedy>So, David, thanks for being back on the show.

01:15:05.300 --> 01:15:05.860
<v Michael Kennedy>It's been really fun.

01:15:06.440 --> 01:15:07.420
<v Michael Kennedy>And yeah, we'll talk to you later.

01:15:07.940 --> 01:15:08.200
<v David Kopec>Awesome.

01:15:08.440 --> 01:15:08.740
<v David Kopec>Thanks, Michael.

01:15:09.220 --> 01:15:09.740
<v Michael Kennedy>Yeah, see ya.

