WEBVTT

00:00:00.300 --> 00:00:01.120
Oh, actually.

00:00:02.420 --> 00:00:03.640
Khuyen, welcome to Talk Python To Me.

00:00:04.540 --> 00:00:05.420
Great to have you here.

00:00:05.980 --> 00:00:07.340
I'm happy to be here.

00:00:08.060 --> 00:00:10.540
Yes, I'm happy to have you here.

00:00:10.940 --> 00:00:14.080
It's going to be a super fun data science topic.

00:00:15.520 --> 00:00:19.560
You've got a really cool project over at CodeCut.ai.

00:00:20.500 --> 00:00:27.720
And one of our listeners reached out and said, you have Khuyen on because she's doing amazing stuff over at CodeCut.ai.

00:00:28.060 --> 00:00:29.800
And I'm really getting a lot of value out of it.

00:00:29.900 --> 00:00:36.300
And I'd love to hear more about this project and maybe dive into some of the topics there.

00:00:36.330 --> 00:00:38.060
So we're going to have a really great time talking about that.

00:00:38.260 --> 00:00:41.520
But before we get to those, really quick introduction for everyone.

00:00:42.700 --> 00:00:43.020
Who are you?

00:00:44.360 --> 00:00:44.460
Yeah.

00:00:45.080 --> 00:00:45.680
Hi, everybody.

00:00:46.060 --> 00:00:46.920
I'm Quynh Truong.

00:00:47.160 --> 00:00:50.100
I'm a developer advocate at Nixler.

00:00:50.300 --> 00:01:01.520
I am also the founder of CodeCut, where I share daily tips on both LinkedIn and through my newsletter.

00:01:01.720 --> 00:01:11.260
And I send out short tips, which have about data science and Python in form of code snippets.

00:01:12.400 --> 00:01:17.000
That is very easy to digest in two minutes, three times per week.

00:01:18.420 --> 00:01:19.160
Three times a week.

00:01:19.840 --> 00:01:20.340
That's a lot.

00:01:21.259 --> 00:01:22.740
Yes, it's a lot of work.

00:01:23.040 --> 00:01:27.240
But I have been doing it for four years, I think.

00:01:27.860 --> 00:01:38.920
So I have been writing tips, writing Python snippets for like basically every day of the week on the weekday for four years.

00:01:40.179 --> 00:01:41.440
Yeah, very fun.

00:01:41.710 --> 00:01:43.700
And you also have longer form articles there.

00:01:45.920 --> 00:01:46.620
Yes, that is correct.

00:01:46.900 --> 00:01:54.240
I also enjoy writing long form articles that dive deeper into open source.

00:01:54.920 --> 00:02:01.880
So majority of the time, like 95% of the time, I write about open source Python data science related tools.

00:02:01.880 --> 00:02:02.680
So very specific.

00:02:03.600 --> 00:02:16.040
And I like to really explore how, why should data scientists use this tool and how they use it.

00:02:16.580 --> 00:02:22.020
And my assumption for every article is data scientists are very busy.

00:02:22.640 --> 00:02:32.400
And if they only have five minutes to read this article, they will be able to get some takeaway from this tool and be able to apply right away.

00:02:33.240 --> 00:02:50.100
So you will see that as a common theme for snippets, micro snippets, as well as newsletter, like very short, very easy to digest, as well as article, even though it's long form, but also very, like if they want to, they can skim it, get something out of it.

00:02:50.150 --> 00:02:54.800
Or if they really want to like die different, you can sit down and like call along.

00:02:55.520 --> 00:02:59.640
And both will work for getting out of it.

00:03:01.120 --> 00:03:01.740
Yeah, I agree.

00:03:01.810 --> 00:03:09.120
I read a bunch of your articles and I think you can certainly get it a lot even if you just have only time to skim them.

00:03:11.500 --> 00:03:13.760
I learned a couple of extra new tools.

00:03:14.000 --> 00:03:16.320
I think that we're going to have a lot of fun to talk about as well.

00:03:16.540 --> 00:03:20.260
So how do people get your code snippets?

00:03:20.290 --> 00:03:22.180
Is that through your newsletter or how you do that?

00:03:23.680 --> 00:03:27.740
Yeah, people get my code snippets through my newsletter.

00:03:28.540 --> 00:03:33.660
And if you go to the front page, see if you find how it looks like.

00:03:34.700 --> 00:03:35.720
Yes, that's how it looks.

00:03:36.270 --> 00:03:42.800
So just for the audience who's listening, so the form of my newsletter is I would.

00:03:43.640 --> 00:03:49.260
So I would extract some specific feature out of the tool, right?

00:03:49.520 --> 00:03:58.320
Because if one tool can have many features and you don't want to talk about all the features in one code snippet, it will be really difficult to digest.

00:03:58.860 --> 00:04:03.160
So I pick one feature. I compare it with something that people already know.

00:04:04.020 --> 00:04:12.740
For example, in the screen, we see we are comparing between a regular expression, RedX, Library and DFLIP.

00:04:13.220 --> 00:05:17.880
and we try we I want to so compare something people already know something that is lesser know to highlight okay we see the typical problem with the tool that people all know and here's a solution and this tool offer the solution and so that's for co-snipeat my my philosophy when it comes to teaching people is it's better to show than to tell so I put a lot of effort into making it very easy for people to when they look at the code snippet they can understand but of course there's supported text so if you scroll down a bit more so you can see the format of it yeah we is the problem solution. The problem is, I will just read it out loud here, RedX pre-processing achieves exact matching but fails completely on typos like iPhone 14 Pro with like 2 double R max.

00:05:20.060 --> 00:05:40.700
Dolution deeply provides similarity scoring that tolerates typos and character variations, enabling approximate matching where uh red x pairs and they can do the full article fair one but it's yeah that's cool mean to be digested within the newsletter yeah i think you could you could

00:05:40.780 --> 00:06:08.240
probably read that and get a good uh bit of information on that in like one minute that's really nice and the idea you're highlighting here is like sure you can search if you're doing data science text nlp type of stuff if you search with regular expressions you might find things But what if the spacing is different between them or somebody puts a comma or they put iPhone 14 without a space between the 14 and the iPhone, right?

00:06:08.380 --> 00:06:11.380
Like all those things are really tricky to catch every variation.

00:06:11.540 --> 00:06:17.120
So there's better tools like DiffLib, which we'll probably talk about again later in an article, right?

00:06:17.380 --> 00:06:20.480
And in the article, I highlight a lot more tools.

00:06:20.500 --> 00:06:23.300
So it's from like Red X to DiffLib.

00:06:23.960 --> 00:06:27.680
And then if you want to like even better than fuzzy matching, right?

00:06:28.620 --> 00:06:33.180
And then if even you want semantic capture, a capture, and that's another tool.

00:06:35.420 --> 00:06:42.680
And then of course you can go down all the spaCy route and into LLMs and like the whole spectrum, right?

00:06:44.340 --> 00:06:48.600
But just knowing about this, because sometimes you don't, you don't want full machine learning.

00:06:48.830 --> 00:06:51.980
You just want kind of like regular expressions, but not so hard.

00:06:53.040 --> 00:06:53.440
That's correct.

00:06:53.620 --> 00:06:55.160
like something that get the job done.

00:06:56.200 --> 00:07:05.320
To me, the idea tool is something that works right out of the box without a lot of boilerplate code and not too many dependencies.

00:07:06.060 --> 00:07:07.700
Yeah, that's really, really important.

00:07:10.200 --> 00:07:13.940
So let's talk about the origins of CodeCut.ai.

00:07:15.040 --> 00:07:15.740
Why did you start it?

00:07:17.080 --> 00:07:19.820
So I started when I was in college.

00:07:20.060 --> 00:08:26.420
so uh a couple um for you uh so i started to i didn't start the website so i started sharing my tips first i started on linkedin right so i make a commitment to myself that i'm gonna so i i initially i write a lot of articles i i push out through two to three articles on towards data science every week and I make the commitment I want to do that every week and then I was not very active on LinkedIn and then I read a book called share your work and it said how no matter how messy your work is you should just share it and I was very into open source tools and I I often just send a message to my friends, say, "Hey, check this out, this is so cool." And I was like, "What if I could share with more people?" So I started to put out some of the things that I'm excited about on LinkedIn.

00:08:27.360 --> 00:08:31.020
And initially I was so afraid, people were like, "What are you talking about?

00:08:31.080 --> 00:08:35.979
You don't know what you're talking about." But people also very excited about it.

00:08:36.099 --> 00:08:43.719
And I was like, "Oh, great." I share something I'm excited about and I help some other people and everybody excited about the tool.

00:08:44.390 --> 00:08:45.040
I love that.

00:08:45.490 --> 00:08:46.560
So I keep doing it.

00:08:47.020 --> 00:08:48.700
Initially, I do it like every day.

00:08:48.790 --> 00:08:50.940
So seven days per week, share every day.

00:08:51.460 --> 00:08:53.920
Later, I was like, okay, I'll give myself the weekend off.

00:08:55.460 --> 00:08:58.500
But I started to do, I think, over 500 tips.

00:08:58.790 --> 00:09:01.420
And then people was like, where can I find the old one, right?

00:09:01.600 --> 00:09:14.860
because if you want to play, let's say, if you are interested in machine learning tools or data processing tools, how do you find it on LinkedIn? There's no way for you to categorize.

00:09:15.520 --> 00:09:24.600
So I started to go back to most of my, there's so many, so I try as many as I can, put it into a website.

00:09:24.980 --> 00:09:30.160
So it was at the time, I just find like some domain, it's called Math Data Simplified.

00:09:30.800 --> 00:09:58.500
and then i just put a bunch there and then i sent out some newsletter so very very not polish at all and but i just want to have a place to capture it and then later i figure out that people was a lot of time people do have typo when they type because it's very long um url so i try to make it something very short and actually capture what I would do in cold cut.

00:09:58.930 --> 00:10:00.220
So it become cold cut.

00:10:01.640 --> 00:10:01.740
Yeah.

00:10:02.680 --> 00:10:04.020
I like the aesthetic of it.

00:10:04.030 --> 00:10:04.640
It looks nice.

00:10:05.260 --> 00:10:07.680
It's got these soft, warm colors.

00:10:09.120 --> 00:10:09.480
Thank you.

00:10:09.800 --> 00:10:15.900
Yeah, I try to keep everything kind of like a cotton candy, so like blue and pink.

00:10:16.520 --> 00:10:18.540
Yeah, cotton candy definitely comes through.

00:10:18.550 --> 00:10:19.660
I can see that for sure.

00:10:20.700 --> 00:10:23.400
What platform did you use to build it?

00:10:24.480 --> 00:10:25.220
I use WordPress.

00:10:27.100 --> 00:10:36.520
But so for articles, I'm creating a workflow where basically I write all my articles in, you know, Quarto, like Docu.

00:10:36.520 --> 00:10:37.120
Yeah, yeah, yeah.

00:10:37.680 --> 00:10:38.840
I realized that.

00:10:38.940 --> 00:10:41.800
So I write and also I run my code in Quarto.

00:10:42.400 --> 00:10:50.100
And then I use a WordPress API to push it to my article in blog.

00:10:50.960 --> 00:11:14.380
so I do a lot through it's easier I don't use a WordPress editor to create the article I use VS Code through QMD but for the aesthetic why I like WordPress because I can drag and drop I'm not a front end developer so it works for me

00:11:14.480 --> 00:12:11.520
You know it's interesting I think a lot of people who are developers get hung up feeling like they have to create their website in the same language or technology that they're an expert in you know if like if you're a python developer you're like well how do i create a website in python for my blog or you know whatever language right but i think there's a lot of value in just saying like it's just a tool i'm just going to pick it and it's going to be great like for for example i had for a long time i had my stuff in wordpress under my own domain for my blog and other things. And I finally decided to move on to Hugo, but Hugo is also not go, it's not Python, it's go. And it's just build static sites. And I think it's really, you know, it's good if you know the technology, but it's certainly not something I think people should get overly hung up on because you can, you lose out on good tools that way, right?

00:12:12.180 --> 00:12:21.280
Yeah, exactly. And I mean, you can learn, like you can learn any language, right? If you know language you can learn you're kind of guessing and all that it's that especially now with ai

00:12:22.540 --> 00:12:58.660
yeah yeah that's such an interesting topic i do think that's actually really changed a lot of things it's like well i could work with this but it's i'll i know i'll get stuck on something and it'll be a pro and now you can just ask an agentic ai like i'm stuck on this okay here you go you know and even if it's not perfect it really really helps sort of handle juggle different types of technology yes exactly yeah super cool so tell me more about this quarto thing this i i didn't intend to talk about this but i find it really interesting do you write in markdown do

00:12:58.660 --> 00:13:16.640
you write html what do you write in and then publish yeah okay so i write in quarto um it is in markdown right so somebody who knows it's in markdown but it's basically really similar to The only difference is you can execute the code.

00:13:17.370 --> 00:13:24.780
So my really favorite stack is in VS Code.

00:13:25.730 --> 00:13:34.160
I have Quartel on the left side and then I open a doc.qmd file.

00:13:34.380 --> 00:13:36.920
People can just imagine it's like a doc.qmd file.

00:13:37.800 --> 00:13:40.500
But you can click the button and you can execute.

00:13:41.220 --> 00:13:45.020
So it's very similar to a notebook, right?

00:13:46.260 --> 00:13:48.700
But I like it.

00:13:48.950 --> 00:13:50.980
I really enjoy writing in Markdown.

00:13:52.139 --> 00:13:54.500
And it's just like a very clean, right?

00:13:54.700 --> 00:13:57.760
Compared to a notebook, it's a big QMD.

00:13:57.890 --> 00:14:03.180
You can think of like a Markdown notebook, just Markdown and you can execute the code.

00:14:07.540 --> 00:14:19.080
After I have the image, I have the code, everything, I create some Python functions to clean it up a bit.

00:14:19.620 --> 00:14:33.240
For example, if there's some cell that I wrote, but I don't want to show it on WordPress, on my website, I will say echo is false, right?

00:14:33.380 --> 00:14:41.140
It's just like a comment, Python comment, on the top of the cell, as you will not show in the website, which is great.

00:14:41.270 --> 00:14:45.700
And then I can just run publish to WordPress, and it's publish to WordPress.

00:14:46.380 --> 00:14:52.700
What is nice about it is, let's say later, some of the content is I want to change.

00:14:53.000 --> 00:15:00.500
Let's say in three articles, I mentioned something, like a link to something, but now it's broken.

00:15:01.220 --> 00:15:14.880
So what I can do is I can just like, you know, click search, buy all the instances of it, update it, and then I run the function sync to WordPress, and then it will sync, right?

00:15:15.080 --> 00:15:18.680
And, hey, I don't need to manually go through each of it.

00:15:19.280 --> 00:15:20.160
Yeah, that's really nice.

00:15:20.320 --> 00:15:22.700
And it'll just fix all the articles that needed to be changed.

00:15:23.620 --> 00:15:24.160
Yeah, okay.

00:15:25.080 --> 00:15:25.520
That's super nice.

00:15:25.700 --> 00:15:28.240
I do think notebooks are awesome.

00:15:28.380 --> 00:15:33.580
And the idea of notebooks are, you know, they really changed the game, I think, a lot.

00:15:34.060 --> 00:15:41.100
But you don't necessarily want to see all of that when your goal is mostly writing, right?

00:15:41.360 --> 00:15:47.340
Like you don't necessarily need to see all the import statements if you're only going to focus on one cell worth of code.

00:15:47.480 --> 00:15:49.260
And it's not about the import, right?

00:15:49.700 --> 00:15:49.860
Right.

00:15:50.200 --> 00:15:55.420
Especially when my goal is to make it as easy as possible for data scientist scheme.

00:15:56.420 --> 00:16:19.140
and you know when you skip it's like a long block of code you're like okay I skip I'm done like I'll read this the next time but my goal is always very small code snippet and highlight the core features of the tool and a lot of time like you need to hide unnecessary code right you know for that to happen yeah

00:16:19.390 --> 00:16:27.300
yeah I totally agree people can get hung up on completeness and it really takes away from the essence of just like skimming it.

00:16:28.820 --> 00:16:40.560
And also I think that this workflow, it sounds like this is one of the things that made it possible for you to do this frequently, like three, four times a week instead of getting overwhelmed, right?

00:16:40.900 --> 00:16:46.620
Yeah, I really need to learn so many tricks in order to, I guess it's a good thing, right?

00:16:46.650 --> 00:16:48.080
It pushed me to be more productive.

00:16:48.330 --> 00:16:54.260
Like I learned a bunch of shortcuts because, you know, Without shortcuts, I cannot get things done quickly.

00:16:55.020 --> 00:16:56.700
So I know a lot of VS Code shortcuts.

00:16:58.460 --> 00:17:00.940
And I use a text expansion tool.

00:17:01.440 --> 00:17:02.880
It's called Expanser.

00:17:03.120 --> 00:17:04.439
And it's game changer.

00:17:04.589 --> 00:17:07.699
I can like, you know, like view the code.

00:17:07.839 --> 00:17:08.680
This article, right?

00:17:08.740 --> 00:17:16.980
If you can just column, doc, something, something, like two words, and then expand the whole text.

00:17:17.490 --> 00:17:19.060
And then you can fill in the blank.

00:17:20.439 --> 00:17:28.640
yeah, I need to learn multiple tricks and also just automate things is how I can get it out.

00:17:29.780 --> 00:17:46.120
But what I still find is by doing that, I can actually focus on the essence of the blog, which is to make it as easy as possible to digest as well as researching, which is very important.

00:17:48.100 --> 00:17:49.380
Yeah, absolutely.

00:17:49.680 --> 00:17:50.980
I love your philosophy here.

00:17:51.100 --> 00:17:55.400
I can see why the site is popular.

00:17:55.840 --> 00:17:59.400
And the show your work, I think that's a great philosophy as well.

00:18:00.440 --> 00:18:04.820
It's like get it out there even if it's messy and get it out there even if it's incomplete, right?

00:18:04.920 --> 00:18:05.440
That's the idea?

00:18:06.480 --> 00:18:07.120
Yes, exactly.

00:18:07.330 --> 00:18:13.260
And I really do recommend it for especially people who try to find a job, right?

00:18:14.220 --> 00:18:21.420
At the time, kind of like another side effect of it is if you show your work, you show people what you know.

00:18:21.640 --> 00:18:27.100
Because so many people, they know a lot, but they don't share.

00:18:28.140 --> 00:18:37.660
And if you expect employers to find you by guessing what you know or look at your resume, it's very hard.

00:18:37.690 --> 00:18:43.160
Because now with AI, everybody has very polished, very nice resume.

00:18:43.380 --> 00:18:46.040
So why should they choose you over another person?

00:18:46.980 --> 00:18:50.280
But by showing your work, by showing like even the messy one, right?

00:18:50.840 --> 00:18:53.840
They will be able to see, okay, this is what they're interested in.

00:18:54.600 --> 00:18:56.320
This is what makes them excited about.

00:18:56.370 --> 00:18:57.580
And this is what they know.

00:18:57.970 --> 00:19:02.320
Then they will be able to imagine how they can use you in their company.

00:19:03.040 --> 00:19:15.320
And that's how, because of me sharing my articles as well as LinkedIn posts early on And when I was in college, I was able to get multiple internships in data science.

00:19:16.920 --> 00:19:17.980
Yeah, super neat.

00:19:18.150 --> 00:19:20.060
And, you know, you're in developer relations.

00:19:20.350 --> 00:19:25.020
And I think there's a strong communication aspect of that as well.

00:19:25.240 --> 00:19:30.780
And this is just another example of like, yeah, look, you want to hire me for this thing.

00:19:30.880 --> 00:19:32.080
I'm already doing it, right?

00:19:32.200 --> 00:19:38.000
Like one of my first important jobs I got, I was doing a lot of speaking at user groups and meetups.

00:19:38.260 --> 00:19:42.780
They weren't called meetups then because meetup.com didn't exist, but they were meetups.

00:19:43.020 --> 00:19:52.180
And I got a message from a company and they said, hey, we saw you talking to this place and that place and you're doing that for free.

00:19:52.320 --> 00:19:54.500
We'd pay you if you want to do this for a job.

00:19:54.580 --> 00:19:55.420
And I'm like, great.

00:19:56.580 --> 00:19:57.380
Where do I sign up?

00:19:57.460 --> 00:19:58.460
I didn't even have to apply.

00:19:58.580 --> 00:19:59.520
They just reached out to me.

00:20:00.360 --> 00:20:04.740
And the timing was perfect because I had quit my longtime job a week before.

00:20:04.960 --> 00:20:07.620
And I'm like, okay, well, I was about to start looking for a new job, but I guess.

00:20:07.900 --> 00:20:08.820
Wow, you're so brave.

00:20:09.500 --> 00:20:11.900
You look for a new job after you quit your job.

00:20:13.800 --> 00:20:14.540
That's very brave.

00:20:14.620 --> 00:20:16.580
Were you intended to take a break or something?

00:20:17.420 --> 00:20:19.660
No, I was not as brave as it sounded.

00:20:21.220 --> 00:20:27.820
My wife got her PhD and finished, and she was getting her first professor job on the other side of the country.

00:20:28.240 --> 00:20:32.700
And so I was like, well, I'll wait until we get there and look for a job.

00:20:33.100 --> 00:20:37.880
because it was, you know, San Diego to New Jersey level of travel.

00:20:37.960 --> 00:20:38.940
It was far, right?

00:20:39.100 --> 00:20:41.640
So I figured I'll find something there.

00:20:42.920 --> 00:20:43.240
I see.

00:20:43.400 --> 00:20:44.360
You got a new job.

00:20:45.280 --> 00:20:54.000
Yeah, I think I'd quit my job, but I was still working for a month, you know, because I knew I was going to be moving in a while.

00:20:54.120 --> 00:20:57.760
And so, like, okay, guys, I'm leaving in a month, six weeks or whatever.

00:20:58.020 --> 00:20:59.460
And about that time, people reached out.

00:20:59.500 --> 00:21:01.060
So it was a perfect, perfect deal.

00:21:02.420 --> 00:21:06.780
But just like you said, it's because of the stuff I was doing out in public, right?

00:21:07.320 --> 00:21:07.500
Right.

00:21:09.680 --> 00:21:09.760
Yeah.

00:21:10.500 --> 00:21:11.620
Okay, so let's dive in.

00:21:12.020 --> 00:21:14.160
Let's dive into CodeCut here.

00:21:15.440 --> 00:21:20.000
And the idea I thought is maybe we could just go through a handful of articles.

00:21:20.539 --> 00:21:21.480
We picked 10.

00:21:21.580 --> 00:21:23.500
I don't know how much time we have to go through all of them.

00:21:23.500 --> 00:21:24.800
We probably can get through all of them.

00:21:26.320 --> 00:21:30.700
But I think this will give people an idea of what they can get from CodeCut.

00:21:30.800 --> 00:21:34.880
but also I just think there's a bunch of interesting data science ideas and tools,

00:21:35.680 --> 00:21:37.240
kind of like that DiffLib that we talked about.

00:21:37.540 --> 00:21:40.620
So I think it'll be a good blend of that type of stuff to talk about.

00:21:42.080 --> 00:21:49.780
So let's start with an article called Goodbye pip and Poetry, Why uv Might Be All That You Need.

00:21:51.150 --> 00:21:54.680
So tell us about this, and then we can dive in a bit.

00:21:55.500 --> 00:22:13.800
Yeah, so I think a lot of people have heard of uv, which is dependency management tool. But let me, for people who don't know about it, just kind of give some quick reason why uv might be something that you want to look into.

00:22:14.660 --> 00:23:25.140
So a lot of data scientists know conda and no peep, right? I think poultry is a little bit less common but for a while poultry is like a modern tool that allows you to manage so many things right like dependency management and virtual environment and you can handle anyway so there's a lot of things in poultry but something that I didn't like about poultry is it's pretty slow for dependency management but when it comes to uv is quick every like it replace many things and even if you are using pip you don't want to learn new tool basically you can just use uv pip install something something and you have a speed boost um and it's yeah so i i grow entire article about uv And I also compare it with the existing tools to give people some motivation on switching it to uv.

00:23:25.500 --> 00:23:27.540
It's so easy to switch, so why not?

00:23:28.980 --> 00:23:30.780
Yeah, I think I am a huge fan of uv.

00:23:31.400 --> 00:23:34.880
I actually just interviewed Charlie Marsh for his next project, PYX,

00:23:36.240 --> 00:23:37.580
two days ago, yeah.

00:23:37.860 --> 00:23:40.400
So uv is going to get even better.

00:23:41.020 --> 00:23:45.200
I just pulled up the performance story for uv.

00:23:45.300 --> 00:23:54.220
compared to poetry and pipsync and yeah it's what is that 20 times faster than poetry and way faster

00:23:54.340 --> 00:24:01.120
than everything else yeah it's that rust because of the rust i think rust and then also they

00:24:01.960 --> 00:24:44.600
they just rethought the caching and other they just it's rust plus a bunch of new ideas that came together to make it work really, really well. And honestly, I feel a little bit, I feel a little bit bad for the other tools. Like I'm a big fan of pip-tools and pip X and you know, those things are really great. And we'll, we'll come back and talk about them a bit, I think as well. But I think those tools laid the foundation for what uv is doing and uv, you know, sort of naturally brought these together but I whenever I think of the contributors and maintainers of those projects I feel a little bit bad because they're not getting as much love as they used to but

00:24:45.140 --> 00:25:04.460
they're still great but uv is definitely making a splash yeah that's a good way to think about I I get excited about new tools very quickly and I don't often think about how the maintainers that the old the tools are less popular think yeah

00:25:06.360 --> 00:25:40.280
it's the natural way of things I think but it's also tough so the speed is important, you know one thing I think is interesting, while I think this is especially interesting for data science and you touched on this already is in the I come more from like the web API side of Python I would say and over there it's been pip all day long, right? It's been pip the whole time. But in the data science side, it's really largely been Conda, Anaconda distributions, that kind of thing, Conda environments.

00:25:41.680 --> 00:26:03.340
There's been kind of this separation. And obviously those are all pulling from the same projects that are all on GitHub and so on. But there has been a little bit of a difference. And and kind of bringing those two worlds back together what do you think yeah i agree i i

00:26:03.460 --> 00:27:30.340
actually have an article a long time ago i think it's probably in cold cut still uh it's called people's conduct was poetry so basically i i was trying to give a very fair comparison i was in favor of poetry but you know i i compared everything and something that i've i to be honest i'm i was not a fan of Conduct and after the comparison I was not even more of a fan of Conduct because I felt like it's very heavy like you can use I think Mini Conduct so it's quicker but at the same time it installed many dependencies that you didn't ask for so it's kind of like a solution where you have a lot of dependencies out the box right but I find that a lot of you didn't ask for some dependencies and install it so you don't really have control over what being installed as well as the way that it solves dependencies or not. I find it is very slow but with so so poetry is worse better because you know it's cleaner you can see like what you put in you can see like all everything in a file like there's a separate file right one for one is PyProject.com and one is a lot, one is the other sub-dependencies.

00:27:31.260 --> 00:27:37.840
And now uv is to me is like that, but to like poetry but better.

00:27:39.160 --> 00:27:42.660
The fact that it can run very fast.

00:27:42.860 --> 00:27:51.980
So one drawback of poetry was sometimes it's think very hard about and take a long time to solve, install new dependencies.

00:27:54.040 --> 00:28:09.500
And also uv replaced with X. It's kind of like an all-in-one-place tool, which is, I think, very necessary, especially for everybody who uses Python.

00:28:09.560 --> 00:28:24.620
but for data scientists, they already have so many things going on and tell them to learn good practices. Let's say they want to upgrade from Python 3.5 to 3.6 to 3.7.

00:28:25.460 --> 00:28:40.920
To use other tools to do it, it seems like a lot of work. But if you can just use one tool and then and you can run it, like upgrading in one command line, then why not?

00:28:42.159 --> 00:28:43.440
Yeah, 100%.

00:28:43.840 --> 00:28:44.620
I think it's great.

00:28:44.620 --> 00:28:50.740
And it has a lot of compatibility with previous workflows.

00:28:50.960 --> 00:28:59.960
For example, you can use UVPIP install instead of using its project management thing, like with add and sync, right?

00:29:01.200 --> 00:29:04.060
so you don't necessarily have to adopt its style.

00:29:04.180 --> 00:29:07.900
You can just say instead of pip install, you can say uv pip install.

00:29:08.880 --> 00:29:18.300
One of the things that used to bother me, and I honestly just haven't looked for a while, about Kondo was coming from a non-data science side.

00:29:19.440 --> 00:29:34.280
Some of the libraries, say, like requests or flask or something like that, pyramid, those were held back quite a bit because they try to make sure there's a compatibility

00:29:34.710 --> 00:29:36.820
between the versions that they ship through Condit,

00:29:37.340 --> 00:29:48.880
which I think that's good for data science or reproducibility, but when it comes to web frameworks, you've got to be super on top of updates in case there's a security vulnerability.

00:29:49.920 --> 00:29:53.080
You want to release that thing the day the vulnerability is announced.

00:29:53.410 --> 00:30:10.340
You want to upgrade your website because as soon as it's announced, people start scanning the internet for any website that could possibly be susceptible to that problem right yeah and so like the web tools were held back a lot so that's it's one of the reasons i never really embraced conda yeah another now that

00:30:10.340 --> 00:31:05.620
you mentioned it another i i also found it is uh one thing i didn't like about conda is you know like there's less data scientists like pandas right if this pandas version is available then a lot of time like sometimes it's not not available on conda that's one thing but another thing is data scientists they collaborate with other engineers right so at some point they need to hand over to the engineers like machine learning engineers data engineers right right use their code and i i think in my previous company like they were like they didn't use conda so for them to like need to install conda or there's a way for you to from conda to peep but then like the dependencies look very messy and it's not like a one-to-one translation sometimes it's it's not you don't get the same environment. Sure interesting yeah.

00:31:05.720 --> 00:31:25.180
Not the trouble for handing over right and that's a reproducible is a big thing when it comes to data science so and dependencies play a big part of it so if you make it hard to reproduce the dependencies then there will be some bugs.

00:31:25.620 --> 00:31:30.380
There will be some errors and even silent errors.

00:31:31.840 --> 00:31:32.640
Very interesting.

00:31:33.000 --> 00:31:34.420
Okay, next article.

00:31:36.160 --> 00:31:39.460
Let's talk about, I think this is a big one.

00:31:40.179 --> 00:31:43.500
Reproducibility, maintainability, that kind of thing.

00:31:44.840 --> 00:31:47.560
What you talked about there was kind of a good lead into it, right?

00:31:47.620 --> 00:31:58.600
It's like the production engineers need to make sure that what they're running runs the same as what the data scientists have tested and come up with.

00:31:58.600 --> 00:32:06.560
And if the situation is different, right, the runtime environment is different, well, maybe it's going to give different answers because of different versions or something.

00:32:09.840 --> 00:32:10.720
Yeah, exactly.

00:32:11.600 --> 00:32:16.100
And dependency is a big thing, but there's also other things that come into it, right?

00:32:16.150 --> 00:32:17.340
And we can talk about it, too.

00:32:17.560 --> 00:32:22.300
Yeah, so what are some of the core ideas of reproducibility?

00:32:23.280 --> 00:32:38.220
Yeah, so reproducibility, I think is, and at the heart of reproducibility is you want to, let's say, especially for data scientists, when they create code, right?

00:32:38.380 --> 00:32:40.500
to create machine learning models.

00:32:40.740 --> 00:32:50.260
They, it depends on some, there's a lot when it packages, dependencies, but also like depends on the parameters that you use.

00:32:51.040 --> 00:32:59.660
And like, you know, even you use everything the same from experiment to experiment, it can produce slightly different accuracy.

00:33:00.820 --> 00:33:06.900
So you want to be able to, let's say one data scientist say, I got a 0.9 accuracy.

00:33:07.880 --> 00:33:11.480
Then they give it, head it over to their teammate to deploy it.

00:33:11.810 --> 00:33:14.940
And then it's degrading the performance.

00:33:15.440 --> 00:33:17.020
It's no longer have a zero accuracy.

00:33:17.400 --> 00:33:20.420
It's probably can be, you know, go down 0.8.

00:33:21.200 --> 00:33:36.740
And so reproducibility is very important in terms of, you know, you want people, if you produce some result, you want other people to be able to reproduce the same results so that your company can profit out of it.

00:33:37.080 --> 00:33:38.620
But another thing is choice, right?

00:33:39.180 --> 00:33:51.740
Let's say if you're a data scientist, you create something that is good, but then you hand it over and it's bad, then it reduces the choice from your coworkers.

00:33:55.920 --> 00:34:05.080
The third thing about it is, let's say, if data scientists, they create some project and then later they want to reuse it, right?

00:34:05.120 --> 00:34:08.840
like for another project, they cannot reproduce the same results.

00:34:09.240 --> 00:34:17.980
They then it's and they need to then then it's kind of like throw it away, creating everything from scratch.

00:34:18.550 --> 00:34:20.280
So it also time consuming.

00:34:22.840 --> 00:34:27.720
And another big thing after publicity, I think go hand in hand is maintainability.

00:34:29.120 --> 00:34:29.919
But yeah, you can go ahead.

00:34:29.919 --> 00:34:31.580
Yeah, no, I totally agree.

00:34:31.860 --> 00:34:35.280
the maintainability part is super important as well.

00:34:37.080 --> 00:34:39.120
So what are some of the pieces that go into that?

00:34:39.240 --> 00:35:00.020
I mean, the first thing that comes to mind for me is pinning your dependencies, either through using something like uv init, uv add, uv sync, or just a requirements.txt file, or pinning your requirements through some other means, like with poetry, but somehow clearly documenting what's used.

00:35:00.180 --> 00:35:09.660
I think it can be easy for data scientists to just import some things in a notebook and then do a magic, well, UVPIP install that right here and let's just keep going.

00:35:09.740 --> 00:35:12.520
But then, like, why won't it run later, you know?

00:35:13.220 --> 00:35:13.400
Yeah.

00:35:13.540 --> 00:35:15.820
Are you talking about maintainability or reproducibility?

00:35:16.940 --> 00:35:18.340
Well, I was thinking maintainability.

00:35:19.140 --> 00:35:20.180
I love it.

00:35:20.240 --> 00:35:20.980
But both, yeah.

00:35:21.280 --> 00:35:21.420
Yeah.

00:35:21.780 --> 00:35:29.460
So maintainability, another thing is, another aspect that comes into maintainability is readability, right?

00:35:30.540 --> 00:35:33.180
And I think this is a big thing for data scientists.

00:35:33.810 --> 00:35:39.700
A lot of data scientists don't write readable code and modular code.

00:35:40.390 --> 00:35:54.280
What you will see is like a big chunk of code with like nested if else or using global variables inside a function or not using function at all.

00:35:54.290 --> 00:35:56.440
And there's a lot of duplicate in the code.

00:35:57.619 --> 00:37:45.680
and I mean that is great for quick experimentation like you want to get something out of it but at the same time it's create a lot of technical debt in terms of uh that's musical thing that really reach you not readable right so read it and I can go deeper I just want to list it out, readability and then reproducibility. Readability, you want your code to be readable because data scientists collaborate with other engineers. And also another problem I saw is data scientists cannot read their old code in a couple months. They forgot. They're really like, what did I write? And they spend quite a bit of time to understand what they write. And if they cannot understand or they don't trust it, right? If you don't understand in a full level, you cannot trust it and you cannot use it for the next project. A lot of times they write things from scratch again. So readability also, if your code is not written well, readability and reproducibility. It's harder to reproduce the same results because, let's say global variables, you use global variables and it affects your code, then it's hard. You might introduce some external factors that make the code different the next time you run. So maintainability is very important and And that comes with, sorry, readable code, version control, dependencies management, configuration management.

00:37:47.640 --> 00:37:52.140
Meaning you don't want to hot code the values into your code.

00:37:53.720 --> 00:37:58.680
Yeah, this is a really great article here because it shows you so many tools and techniques, I think.

00:37:59.620 --> 00:38:00.180
Yeah, thank you.

00:38:00.640 --> 00:38:11.020
And I also, so writing a maintainable data science project has been my passion for a long period of time.

00:38:11.680 --> 00:38:15.440
And it actually has become a book like this, this is the article form.

00:38:15.640 --> 00:38:20.700
But I also recently wrote a book about this, finished a book about this.

00:38:20.730 --> 00:38:22.700
It's called Production Ready Data Science.

00:38:24.540 --> 00:38:25.060
Yeah, congratulations.

00:38:25.680 --> 00:38:26.620
That's amazing.

00:38:26.780 --> 00:38:27.820
When did you finish it?

00:38:27.820 --> 00:38:28.740
When did you publish it?

00:38:29.940 --> 00:38:31.700
two months ago, I think.

00:38:32.240 --> 00:38:33.860
Okay, so really recently, yeah.

00:38:34.420 --> 00:38:35.160
Very recently, yeah.

00:38:35.300 --> 00:38:36.560
It took me quite a while.

00:38:36.780 --> 00:38:39.540
I have all the materials because I've been writing about this.

00:38:40.460 --> 00:38:55.780
So I have so many materials who put it together and also make it less in like the article style, explaining more of the why before the how is also what I focus a lot on this book.

00:38:56.800 --> 00:38:58.280
Yeah, that's a super important part.

00:38:59.000 --> 00:39:29.280
now I you know I am a huge fan of thinking a lot about readability and spending a lot of time on readability and I agree with you I think we're on the same page for sure on that one because if your code is not readable that doesn't mean it can't be read it just means it's harder to read right if your code is not readable it's harder to maintain it, it's harder to see the bug It's harder to read.

00:39:29.370 --> 00:39:30.860
All the things that you've pointed out.

00:39:31.620 --> 00:39:44.760
And I think it's a little bit ironic that the notebook style of development that is meant to communicate, like it's supposed to be more communication compared to regular programming, right?

00:39:44.880 --> 00:39:47.000
It's got the markdown cells.

00:39:47.090 --> 00:39:47.820
It's got the pictures.

00:39:48.320 --> 00:39:51.480
It's got little tables for like df.head, that kind of stuff, right?

00:39:53.080 --> 00:40:00.020
Its natural way of programming it leads to less maintainable reusable code, right?

00:40:00.240 --> 00:40:01.640
Because it does not encourage functions.

00:40:02.480 --> 00:40:10.520
So it's really hard to do reuse if you don't think, oh, maybe I need to write a function in this cell, collapse the cell, and then use the function later, right?

00:40:10.640 --> 00:40:12.960
That happens, but not very much.

00:40:12.980 --> 00:40:22.880
I was doing some research for, or just looking around really, research is a little bit high, Putting it in a high position compared to what it was.

00:40:22.960 --> 00:40:36.900
I was looking around for some examples, and I found this really cool JPL collection of notebooks for studying, I think galaxies, like studying the brightness of galaxies and trying to understand things about them.

00:40:37.080 --> 00:40:45.760
And they had a bunch of cool notebooks in there, and they were like 1,500 lines of code and stuff in there.

00:40:46.480 --> 00:40:46.960
One function.

00:40:49.040 --> 00:40:49.160
One.

00:40:49.860 --> 00:40:50.260
Wow.

00:40:50.280 --> 00:41:15.700
like oh that is probably i mean maybe this is necessary but it's probably not necessary and this is jpl right this is like a polished published thing not just a random notebook i ran across right uh the jet propulsion laboratory in pasadena which is i consider them to be pretty amazing so yeah maybe speak through a little bit about that like this maintainability thing in juxtaposition

00:41:15.720 --> 00:41:45.560
with like notebook style yeah definitely i that's the thing i before i i think five years ago i wrote an article that got very popular but also a lot of controversy is called i think something about like seven reasons why i switched from notebook to python script something but so anyway so the thing about notebook is A lot of people argue, yeah, you can write functions.

00:41:46.040 --> 00:41:47.100
It's just Python, right?

00:41:47.100 --> 00:41:47.820
You can write functions.

00:41:47.910 --> 00:41:52.740
You can write whatever you want, just like a Python script.

00:41:53.380 --> 00:41:58.620
But the interactive style of it discourages you from doing it.

00:41:58.620 --> 00:42:04.700
Like, why should I write a function when I can just see the result and then I build upon it?

00:42:06.340 --> 00:42:47.200
Because what is so great about it is you can see the result and then you can build up upon it in the next cell, next cell, next cell. So people are less likely to build a function which like if you create a function then like it's hidden inside a function, it's not execute the code. So that's one thing. Another thing problematic about notebook is it's encouraged hard coding. You know like a lot of time because if you want to see the Another thing is a very big problem is self execution.

00:42:48.340 --> 00:43:09.800
If you execute self, the fact that it gives you the ability to execute in different orders is nice, but also a disadvantage in a way that if you run it in the wrong order, then And it will, like, you can get some results right now that is different from results that you want to run.

00:43:10.200 --> 00:43:10.460
Right.

00:43:10.550 --> 00:43:15.900
If you forget to run a particular cell, you go back up, run that to refresh it, and then you skip back down.

00:43:16.500 --> 00:43:19.180
Something in the middle was important, and you don't rerun it.

00:43:19.320 --> 00:43:20.640
That's probably not good.

00:43:21.420 --> 00:43:22.020
Yeah, exactly.

00:43:22.070 --> 00:43:29.900
And I remember when I worked in Notebook before, it just gave me a headache because I would run something.

00:43:29.990 --> 00:43:31.820
I said, oh, did I rerun this?

00:43:32.020 --> 00:43:42.600
did i run that store did i not just to make sure i will run it so it's something and and then later when i come back to notebook i was like i'm not gonna reuse this notebook again because i don't

00:43:42.660 --> 00:44:30.700
know what's going on here yeah i don't want to people to think that i'm completely anti notebook i'm not but i do think that there are some techniques and some tips that you can use so when i was riffing on functions one thing i think you could do and you touched on it as well is you could take the parts of your code that you want to reuse and put that in a python script next to your notebook and import it right and then you can use it a lot of times i think there's a bunch of cells in notebooks that don't really have to do with the presentation or the important part they're just there like well i need to load this thing or i need to like clean up that or or something and it has to go before what you actually want to show people if you could put that in a script then you could just import it and then show the important part.

00:44:31.340 --> 00:44:33.120
It's more readable, more reusable.

00:44:33.440 --> 00:44:34.080
It's more modular.

00:44:34.320 --> 00:44:36.280
In all ways, almost, it's better.

00:44:36.800 --> 00:44:37.880
Yes, I agree.

00:44:38.720 --> 00:44:42.040
The thing about, yeah, Sam, like notebook is great.

00:44:42.280 --> 00:44:43.900
It's very good for presentation.

00:44:44.720 --> 00:44:52.580
But I think the problem is a lot of time people use it more than what it's supposed to desire for, which is, to me, it's prototype, right?

00:44:53.040 --> 00:44:55.540
It's to showcase something.

00:44:56.160 --> 00:45:00.340
to showcase it with either non-technical or technical people.

00:45:00.940 --> 00:45:02.760
It's not used for like everything.

00:45:03.140 --> 00:45:04.420
And I think that's a problem.

00:45:04.540 --> 00:45:10.720
Like a lot of data scientists use it for everything, including writing production, writing code.

00:45:11.460 --> 00:45:13.900
And again, that's another argument, right?

00:45:14.040 --> 00:45:17.920
Like can you, should you write production, writing code in notebook?

00:45:18.180 --> 00:45:19.440
And Netflix did that.

00:45:19.560 --> 00:45:22.720
Netflix create production, writing code in notebooks.

00:45:23.220 --> 00:45:23.780
And that's great.

00:45:24.000 --> 00:45:25.240
Paper mill and all that stuff.

00:45:25.400 --> 00:45:25.480
Yeah.

00:45:25.840 --> 00:45:27.940
Yeah, that technology allows you to do it.

00:45:28.680 --> 00:45:31.540
I feel like it's still...

00:45:32.480 --> 00:45:37.440
At the same time, it's a tool that if you use it right, then it will serve you.

00:45:37.900 --> 00:45:40.140
Yeah, it's interesting.

00:45:40.420 --> 00:45:44.940
Speaking of tools, I know you've written about, talked a little bit about Marimo.

00:45:46.000 --> 00:45:46.880
What do you think about that?

00:45:46.960 --> 00:45:48.580
I think this is a really interesting one.

00:45:48.660 --> 00:45:56.080
I just did a course called Just Enough Python and it's software engineering for data scientists.

00:45:56.880 --> 00:45:56.960
Nice.

00:45:56.980 --> 00:45:58.280
And I was trying, thanks, yeah.

00:45:58.320 --> 00:46:04.820
And it's like, okay, a lot of themes that you talk about as well, like you should probably learn Git, you know, and so on.

00:46:05.340 --> 00:46:16.260
But one of the things I really struggled with was I really wanted to use Marimo as the foundation, but, you know, 90% or more data scientists use Jupyter.

00:46:16.980 --> 00:46:32.080
So I ended up using Jupyter, but I think Marimo actually might be a little bit better in terms of software engineering and a little bit better in terms of this order of operations you talked about, like, because Marimo tracks like, hey, this cell depends upon that cell.

00:46:32.220 --> 00:46:34.500
So if you rerun this one, we got to rerun that one first.

00:46:34.700 --> 00:46:35.820
It'll catch those kind of things.

00:46:36.880 --> 00:46:38.880
But you want to maybe talk about this real quick?

00:46:39.020 --> 00:46:40.360
Because I know you wrote about it a little bit.

00:46:40.520 --> 00:46:42.320
Yeah, I really like Marimo.

00:46:42.440 --> 00:46:43.380
I think it's great.

00:46:43.920 --> 00:46:47.340
It has been, so I was actually in the middle of writing the book, right?

00:46:47.500 --> 00:46:54.680
And I know that data scientists love Notebook and I don't want to be like, hey, let's just write Python script.

00:46:55.640 --> 00:47:02.680
But at the same time, I really think that Notebook is really hard to write production radicals.

00:47:02.730 --> 00:47:05.260
And that's, you know, my book is about production radicals.

00:47:05.260 --> 00:47:07.080
So how do you find the middle ground

00:47:07.850 --> 00:47:12.180
between, you know, an interactive version of Notebook and production radicals.

00:47:12.490 --> 00:47:15.540
So Marimo came out and I dig deep into it.

00:47:15.640 --> 00:47:59.680
solve a lot of problems and first is a self-execution order right so the problem in notebook is let's say you sell one, sell two, sell three you change something in cell one for example you all run it but then you change something in cell one if you forgot to rerun cell three then you know the result is not going to reflect what you have changed in cell one but with Marimold it can detect the dependencies and if you change cell 1 and cell 3 depend on cell 1, depend on the variable in cell 1, then it will execute it automatically which is great.

00:48:00.800 --> 00:48:18.660
Another big thing is notebook, not this advantage, notebook is it is javascript right so it's very uh big uh unreadable um hard to if you want to use it for

00:48:19.240 --> 00:48:30.780
hand it over reuse it it's really right it's so common to get a git conflict when you try to pull a new version just because the output has changed and that shouldn't even be taken into account

00:48:31.480 --> 00:48:42.600
and yeah that shouldn't be taken into account and also the output can be big but with Marimo Notebook is just a Python script under the hood.

00:48:42.950 --> 00:48:49.600
So you have a, you have, and what great thing about Python script is that you can reuse it.

00:48:49.600 --> 00:48:54.980
You can like import it in another Python script, but also for CI/CD, right?

00:48:57.560 --> 00:49:06.260
And you can write unit tests, you know, like with unit tests is important, but with in Notebook, you can write unit tests.

00:49:06.440 --> 00:49:09.180
There's a hack around, but it's a hack.

00:49:10.340 --> 00:49:16.820
And a lot of times people need to put their test inside notebook, which is not modular, right?

00:49:16.980 --> 00:49:17.260
It's not.

00:49:17.980 --> 00:49:23.060
It makes it very messy with code and then test inside the same place.

00:49:24.280 --> 00:49:33.020
But if you write notebook that is Python script under the hood, then you can write unit tests and you can run it with pytest.

00:49:34.840 --> 00:49:35.440
Yeah, very cool.

00:49:35.580 --> 00:49:37.280
I think this is a neat one.

00:49:37.530 --> 00:49:44.840
I generally wanted to use it, but I'm like, but at the same time, I probably got to speak the same language of the people doing that.

00:49:44.900 --> 00:49:45.540
Yeah, exactly.

00:49:45.880 --> 00:49:46.680
Yeah, yeah.

00:49:47.030 --> 00:49:54.060
So another thing I want to talk about here, actually this maintainability article, it's just got so much good stuff in it.

00:49:54.780 --> 00:49:59.480
Something I think that might be new to folks is Hydra, right?

00:50:00.200 --> 00:50:05.200
Let's talk about this idea of managing configuration files with Hydra.

00:50:06.240 --> 00:50:16.920
Yeah, I love Hydra. Hydra is developed by Facebook research and I think I use it.

00:50:17.420 --> 00:50:25.140
It has been my two goals. I have some core tools. I go back for every data science project and Hydra is one of them.

00:50:26.540 --> 00:51:03.280
something that so for i guess so if you think about hydra is a configuration management tool you can write your configuration inside a yaml file and then you can you know like call things you can access the variables inside the yaml file inside a python script that is nothing new right people know about Like there's a YAML muting library in Python that allows you to work with YAML.

00:51:03.920 --> 00:51:11.580
But something I like about Hyder a lot is reduce the boilerplate code.

00:51:12.380 --> 00:51:26.820
So you can just add like a decorator to your Python function, and then it will be able to access everything underneath inside the Python function.

00:51:27.300 --> 00:51:39.580
And instead of using a brackets notation, for example, if to access a nested value, you might need to use mutual nested function.

00:51:40.120 --> 00:51:44.100
But instead, you can use dot notation, which is very clean.

00:51:45.400 --> 00:51:53.360
Other things are-- oh, you can-- as your project getting bigger, right?

00:51:53.580 --> 00:52:26.500
mean for a small project maybe a YAML is enough but as your project getting bigger let's say you have you want to be able to use especially in like data science experimentation you want to use different values you want to experiment with different way of processing you want to experiment with different parameters for your models and that can get messy your YAML file become very big So a good way to handle this is you want to break it into smaller configuration.

00:52:28.340 --> 00:52:47.520
But if you want to do that without Hydra, then you need to write Python functions to access it, to composite it, to put the pieces of puzzle together. With Hydra, basically everything is handled for you.

00:52:47.760 --> 00:52:52.480
So you can break it apart and then you can refer to different part of the pieces.

00:52:53.100 --> 00:52:58.340
You can like in one YAML file, you can refer to the other part of the YAML file.

00:52:58.420 --> 00:52:59.640
It's kind of like the import, right?

00:52:59.800 --> 00:53:00.520
Import in Python.

00:53:01.460 --> 00:53:03.140
And you can override it.

00:53:03.680 --> 00:53:08.200
Another thing I realized, you can override the parameter from the command line.

00:53:08.600 --> 00:53:09.820
Yeah, that's a cool feature.

00:53:10.240 --> 00:53:10.460
Yeah.

00:53:10.520 --> 00:53:39.140
So you don't need to go back into the, because a lot of time you want to experiment different parameters or inside the production environment and the development environment you might use different parameters and if you can override from the command line which is used a lot in you know different platforms then that that will be amazing yeah it's super neat basically

00:53:39.360 --> 00:54:11.359
provide a bunch of default values instead of hard coding them and then if you need to override them you could do that through the command line or you could just do it in code or whatever right yeah exactly yeah excellent and you're bringing it all together here in your article uv run process py and then over so you got your hydra you got your uv run coming together all that stuff so you actually have a whole article i originally started talking about it because it was in the maintainability section but you have a whole article called hydra for python configuration

00:54:11.380 --> 00:54:25.080
right? Well, the other article is more like a high level, but then I have smaller articles that talk about each tool. Super. Okay. Well, we're not making very good progress through this,

00:54:25.080 --> 00:54:41.340
but that's okay. Because these are really interesting topics. Another one that you talk a lot about is doing proper logging. And you recommend Log Guru, which I love Log Guru. I

00:54:42.180 --> 00:55:46.420
but then I've been slowly moving towards log guru nice yeah I really like so another thing about you know like a lot of data scientists they use print which nothing wrong with print like in fact you you you shouldn't use I think it's overkill you use print in a notebook right but when it comes to like if you want to write production radical if you have a bunch of print because a lot of time you had debugging prints right and if yeah you can go back and delete them and everything but wouldn't it be great but then like if you go back to development environment then you need to like put it back or if you don't do it at all if you keep all the print inside your code you go into development now you have a bunch of noise when you see the output so With logging, just a simple way of thinking about, I think a big advantage of logging is you can do logging and you can use different modes like debug, info, warning, error.

00:55:46.630 --> 00:56:04.180
So you can set the level based on, you can show, let's say if you're going to your in development environment, you want to show the debug level. If you're going to the production environment, then you might want to do like the info level only.

00:56:05.180 --> 00:56:12.680
But one drawback of logging is I think it's tech a lot, quite a bit of boilerplate code.

00:56:13.760 --> 00:56:28.100
That's the first thing. So it really, even if you can copy and paste, even it's like one barrier, you know like one barrier to use logging why should i do all these code when i can just use print

00:56:28.900 --> 00:56:33.360
right it's got like you got to register handlers and all sorts of funky stuff yeah

00:56:34.120 --> 00:56:54.480
and but what what if you can have the advantage of print like so easy to use and the benefit of logging then that's why i'm such a big fan of blocker rule which have the best of both world and other things that it allows is beautiful out of the box.

00:56:55.140 --> 00:57:00.120
So the login output, it looks colorful.

00:57:00.640 --> 00:57:01.840
It's very easy to see.

00:57:03.120 --> 00:57:07.680
With a standard login, you need to do a lot of, you know, what do you want to show?

00:57:07.960 --> 00:57:18.100
You want to show this, you want to show the lines of code, you want to show the function, whereas the output is coming from all those configurations.

00:57:18.320 --> 00:57:29.060
with Logger. You can just say from Logger.import logger and then logger.info something something and the output is very beautiful.

00:57:30.660 --> 00:57:31.260
Yeah, I really like it.

00:57:31.260 --> 00:57:40.040
You can basically just if you wanted to kind of keep your print style you don't have to you can just import it and use it and it just prints, right?

00:57:40.490 --> 00:57:40.600
Yeah.

00:57:41.120 --> 00:57:54.320
The other thing, like you pointed out this is a super big for people who are primarily data scientists who haven't worked with logging a lot or new programming, instead of just saying logger print, you say logger debug or logger info or logger error.

00:57:54.560 --> 00:57:57.140
And then you can say, production, just show me the errors.

00:57:57.960 --> 00:57:59.100
Or, hey, something's going wrong.

00:57:59.340 --> 00:58:03.120
Actually, show me all the warnings and the info.

00:58:03.780 --> 00:58:06.240
And you can dial it up and down without changing the code.

00:58:06.700 --> 00:58:11.580
So you can leave your effective print statements there and just turn them off with a configuration, maybe with Hydra, who knows?

00:58:12.420 --> 00:58:12.820
Yeah.

00:58:15.760 --> 00:58:16.320
Yeah, really nice.

00:58:16.340 --> 00:58:16.780
And the color.

00:58:17.880 --> 00:58:25.180
the color is very nice as well it's very colorful yeah it's and the color persists through files

00:58:25.680 --> 00:58:31.720
by the way right so if you have log guru log into a file and then you tail the file in your terminal

00:58:32.100 --> 00:58:36.340
you see the color still which is awesome oh wow i didn't know that that's a new thing for me

00:58:36.840 --> 00:58:59.380
yeah yeah because some of my stuff is all logging um with log guru and i tell and the color comes through. And it's so much easier. Like, for example, on the website, one of the things that I'm logging to a separate file is, what are the requests? What is the response time? What is the status code? Is it a 500? Is it 200? Is it a 300? You know, whatever, right? All that.

00:59:00.120 --> 00:59:11.400
And so I'll actually have it change the color based on what happens. So if the message is a 500, it's a different color than if it's a 200. Or if the response time is over 500 milliseconds,

00:59:11.460 --> 00:59:14.820
it changes color to like a warning sign versus if it's under.

00:59:15.540 --> 00:59:18.240
And all that stuff comes through, and it's so nice with Log Guru.

00:59:18.320 --> 00:59:22.380
So nice, yeah, especially when you have a lot of logs, and that is very useful.

00:59:23.060 --> 00:59:23.820
Yeah, absolutely.

00:59:24.120 --> 00:59:24.260
Okay.

00:59:31.120 --> 00:59:33.060
Git, let's talk about source control.

00:59:34.620 --> 00:59:37.400
Yeah, version control, I think, is huge.

00:59:37.480 --> 00:59:44.100
is very useful and it's very important for data scientists but I don't see it's being used enough.

00:59:44.950 --> 01:00:54.380
I was a machine learning engineer in Accenture and working with clients so I was building kind of like a data science environment, data science tool that integrated with say AWS SageMaker and it's funny how many data scientists are not using Git and like their multiple data science team and they want to communicate with each other, you know they want to share their work but then every time they want to share their work it's so hard for them because they don't have a source version control which surprised me you know it's a big client I mean it's a big point why don't they use good and if they do it's not very good practices so That's why I want to educate data scientists more about Git.

01:00:56.120 --> 01:01:01.880
And to me, Git is so important for several reasons.

01:01:03.519 --> 01:01:08.520
First, let's say if you do something, you mess up some code.

01:01:12.620 --> 01:01:20.940
Let me give an example of data scientists. They write a model, There are code that produces a model that works great.

01:01:21.920 --> 01:01:33.660
Then later they want to test the parameters, maybe experiment with different types of processing, see if the model performance can increase.

01:01:34.960 --> 01:01:39.460
And they mess it up as the model decreases in performance.

01:01:40.440 --> 01:01:44.120
And they have added two or three files.

01:01:44.260 --> 01:01:47.640
Now they need to revert it.

01:01:48.220 --> 01:01:58.240
And if you don't already save the last version that was working, you cannot just revert to it.

01:01:58.650 --> 01:02:01.640
But with Git, you can do multiple things.

01:02:01.810 --> 01:02:06.660
If you're just a solo data scientist, then you can revert it to the last working version.

01:02:09.579 --> 01:02:16.280
But if you work with all the data scientists, then you can share, you can also collaborate with them.

01:02:16.580 --> 01:02:22.780
Different data scientists can work on different versions and then all different features.

01:02:23.020 --> 01:02:35.480
And when they're ready for it to be published, then they can merge it together, which is so much better when you do it with Git than manually going life to life.

01:02:37.840 --> 01:02:44.560
I think I agree with you that I think data scientists don't use source control or version control enough.

01:02:47.080 --> 01:02:56.660
And I think that even when people work alone on their own project, they should use Git or something else.

01:02:56.700 --> 01:03:02.860
And honestly, they should just use Git these days because it's the lingua franca of everything that people are doing.

01:03:02.980 --> 01:03:46.400
you know what but it lets you it lets you do exactly what you're talking about and it's not just oh no i have to go back but i think a really important part of people you know speaking to the people who don't really use it that much or they only use it in their professional settings in the team maybe i think it lets you be fearless in exploring new ideas right like all right i'm commit this version and then let me just terrorize my code and like try something crazy and oh my gosh it worked great we'll keep it if it doesn't work nothing lost you can 100 go back and if people don't if they're not i mean that's a good reason even by yourself right yeah yeah exactly and it's

01:03:46.750 --> 01:03:59.800
i feel like it's so easy uh you can do git add commit that i mean um there's a lot of thing you you can do with Git, but I think to just learn some basic, Git, Git, Git, Git, Git, Git, push.

01:04:00.500 --> 01:04:00.740
That's it.

01:04:00.880 --> 01:04:01.080
Yeah.

01:04:01.420 --> 01:04:01.520
Yeah.

01:04:02.300 --> 01:04:03.280
You don't have to learn.

01:04:03.580 --> 01:04:05.700
There's maybe five or six commands you've got to learn.

01:04:06.000 --> 01:04:07.940
Mostly your tools that you're working with.

01:04:09.240 --> 01:04:10.480
You mentioned VS Code.

01:04:10.740 --> 01:04:11.200
It's got awesome.

01:04:11.540 --> 01:04:15.000
Git, Control Iteration, and PyCharm, and others.

01:04:17.740 --> 01:04:18.080
Yeah, absolutely.

01:04:18.300 --> 01:04:19.480
I think that's really, really nice.

01:04:20.780 --> 01:04:23.640
Let me give you two more ideas and see how these land with you, okay?

01:04:24.130 --> 01:04:26.920
For why I think Git is now more important than ever.

01:04:27.840 --> 01:04:27.920
Yeah.

01:04:28.760 --> 01:04:37.580
Number one, if you're doing any agentic coding, here's another reason to use a proper editor instead of a notebook as well, potentially.

01:04:38.940 --> 01:04:50.140
But you can go and say, hey, AI agent, I would like you to change this and add this feature and do this thing, and it'll just go and go for 10, 15 minutes.

01:04:52.580 --> 01:05:05.980
if what i find a lot of times with these agentic coding things is they make great progress you're like wow this is amazing it makes more great project like how is this even possible i live in the future and then the next step is oh no it broke it all you know what i mean you're like

01:05:06.430 --> 01:05:21.100
yeah yeah you have the same experience yes and i love that you go into this topic because that's kind of i think of the mathematics i have been mentioned it's more important than ever now that you have AI, you're working with AI.

01:05:23.260 --> 01:05:25.060
Because two different things, right?

01:05:25.080 --> 01:05:28.920
A lot of time, you wanted to do something, and then it broke.

01:05:29.380 --> 01:05:31.280
So you want to go back to the previous version.

01:05:31.500 --> 01:05:31.960
That's one thing.

01:05:32.340 --> 01:05:37.660
Another thing is if you commit very frequently, then you can see what it changed.

01:05:38.140 --> 01:05:41.540
And you can catch it before you commit it or you push.

01:05:42.040 --> 01:05:48.520
Because so many, I think it's so frequently that I saw it do something that is not optimal.

01:05:48.840 --> 01:05:57.540
For example, multiple nested, like with AI, a lot of time it over complicated solution.

01:05:57.770 --> 01:06:04.900
It make it so many try, exact, accept, and if else, and all that it use is hot code.

01:06:05.010 --> 01:06:06.000
It just bad practices.

01:06:06.670 --> 01:06:17.720
But if you control, you use version control, you can see like the difference, like the last code and the new code, and you can catch it before you commit.

01:06:18.320 --> 01:06:18.660
Yeah.

01:06:19.580 --> 01:06:20.860
Yeah, it's more important than ever.

01:06:21.940 --> 01:06:23.220
Yeah, you're 100% right.

01:06:23.300 --> 01:06:24.080
You're right on it.

01:06:24.700 --> 01:06:31.920
I find that when I'm doing the agentic coding side of things, I actually have the source control tab open in my editor.

01:06:32.900 --> 01:06:34.640
Not the files tab, but the source control.

01:06:34.760 --> 01:06:38.800
And as it's going, I'll see what files are changed, and I'll start looking at the diffs.

01:06:39.540 --> 01:06:41.840
Even while it's still working, I'm like, oh, it's on a good path.

01:06:42.040 --> 01:06:43.800
Oh, no, it shouldn't be doing this.

01:06:43.940 --> 01:06:47.620
And either you ask it to fix it, or you just go, no, I'm reverting it.

01:06:48.060 --> 01:06:50.280
Yeah, I added a feature to the website.

01:06:51.760 --> 01:06:54.940
Not a super big one, but kind of touched a lot of files.

01:06:55.080 --> 01:07:03.200
I think there was 15 commits to achieve that change because every time a major, I'm like, okay, the AI has gotten something right.

01:07:03.480 --> 01:07:08.300
I'm like, save that to get, because it's exactly like you described.

01:07:08.400 --> 01:07:08.640
It's awesome.

01:07:09.400 --> 01:07:11.100
Yeah, I experienced the same.

01:07:11.300 --> 01:08:25.560
I would have so many commits for one feature change because also something that i tell to do is uh you know just let's say if i want to implement like a something i really like to do is go very thoroughly with like planning very very thoroughly in advance before even code to ensure like everything is uh what i expected and then i let it run right um and what i did it depends on what i run i do but recently i try to develop like a workflow to go from you know my code into newsletter so i i want to implement something uh and i want to be i want to be able to walk away and go back and and be able to go back to So I break into phases. Let's say I break into five phases, the easiest phase and the more complicated phase, like the nicer hair feature. Now I want to go back into each phase and see if it breaks. I want to know when it breaks. So I put every phase as it to commit.

01:08:26.520 --> 01:08:38.299
So that if it breaks somewhere, I can go back to the previous version, which is also another thing that you can ask it to commit uh while yeah yeah that's interesting i haven't thought about

01:08:38.560 --> 01:09:41.180
asking it to commit that's cool i'll give you one final reason to use get in the agentic world and then i think we're out of time i'm gonna have to call it but this has been a great conversation i one other thing you talked about like oh it's made good progress and then something didn't work and you can actually tell it you gave your example let me make this more concrete you gave your example of oh I made some changes as forget the AI right I made some changes it turns out that the performance fell apart I edited three files I couldn't quite remember what was wrong you could go to an agentic AI and say please look at my get local get history from this commit forward and try to understand why the performance fell apart and I bet you it will have some really good ideas if not know exactly why. And it can just, it will do what we described for us in reverse. Like it'll just look at the Git history and go, this changed, this changed. Oh, if this changed, I bet it had this effect. And then, right. So you can leverage it in reverse and feed it to the AI to get understanding

01:09:41.310 --> 01:10:24.400
too. Yeah. Yeah. That's such a great use case that you just talk about a lot of time. You're like, okay, use GitDiv, look at the difference and tell me what's wrong. That's another thing that I use very often um also another thing on top of it is let's say it doesn't code the way you like everybody have the old preferred style to do things right so sometimes you can you can edit it and you tell it okay look at the your implementation and my implementation and like just kind of taking note of the difference um so that like the next time it will be able to create similar more similar to the style you're looking for.

01:10:24.880 --> 01:10:25.280
Yeah.

01:10:25.720 --> 01:10:26.400
Yeah, that's a great idea.

01:10:26.860 --> 01:10:30.340
I feel like we honestly could talk about this for hours, but we're out of time.

01:10:30.560 --> 01:10:31.420
We're out of time, Khuyen.

01:10:31.620 --> 01:10:33.660
So thank you for being here.

01:10:33.720 --> 01:10:35.300
I think let's leave it with this.

01:10:35.520 --> 01:10:36.500
Let's leave it with two things.

01:10:36.980 --> 01:10:42.800
First of all, maybe final call to action.

01:10:43.100 --> 01:10:46.320
People are interested in CodeCut AI, all of the stuff you've created.

01:10:47.380 --> 01:10:49.720
How do they get started with all of your resources?

01:10:50.160 --> 01:10:50.420
Yes.

01:10:50.560 --> 01:10:52.040
So just go to my website.

01:10:57.280 --> 01:11:19.940
codecut.ai and then you will see how to sign up for newsletter. There's also a book tab that if you're interested in production, read in data science, you can buy it there. It's currently on sales. It's Labor Day week so 20% off and yeah that's it. If you want to read my blog go to blog.

01:11:20.620 --> 01:11:24.340
If you want to see a sample of my code snippet, go to short post.

01:11:25.600 --> 01:11:29.100
Everything is very easy to navigate. Just go to post.ai.

01:11:29.940 --> 01:11:34.120
Fantastic. All right. Well, thank you so much for being here and sharing all your experience and your work.

01:11:34.820 --> 01:11:38.160
Really, congratulations on CodeCut. It's a cool project.

01:11:38.850 --> 01:11:39.560
Thank you so much.

01:11:40.210 --> 01:11:41.260
You bet. See you later.

01:11:41.900 --> 01:11:42.800
We'll see you. Bye.

