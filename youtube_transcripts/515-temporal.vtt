WEBVTT

00:00:02.200 --> 00:00:03.860
Mason, welcome to Talk Python To Me.

00:00:04.540 --> 00:00:05.240
Fantastic to have you here.

00:00:06.120 --> 00:00:06.780
It's great to be here.

00:00:06.940 --> 00:00:07.440
Long time listener.

00:00:08.200 --> 00:00:08.940
Oh, wonderful.

00:00:09.720 --> 00:00:12.000
Yeah, I'm definitely a fan of stuff

00:00:12.160 --> 00:00:13.500
I've seen you doing online as well.

00:00:13.620 --> 00:00:15.800
And it's super cool to get together here

00:00:16.480 --> 00:00:17.880
and share it with a couple of people.

00:00:19.260 --> 00:00:20.760
Yeah, definitely excited.

00:00:21.480 --> 00:00:21.880
Yeah, cool.

00:00:22.820 --> 00:00:25.920
And Temporal, wow, what a cool topic, durable execution.

00:00:26.640 --> 00:00:30.320
What a neat idea that I've seen in other places,

00:00:30.390 --> 00:00:31.600
but I've seen less of it in Python.

00:00:31.980 --> 00:00:33.580
So I'm real excited to dive into this.

00:00:33.700 --> 00:00:36.500
This is something I learned about recently.

00:00:36.670 --> 00:00:40.460
We'll go into that in a bit, but there's a lot here.

00:00:40.740 --> 00:00:42.660
Let's just leave it like this could be a two-hour show

00:00:42.730 --> 00:00:44.200
and we'd still be going easy.

00:00:45.100 --> 00:00:45.900
Definitely, yeah.

00:00:46.900 --> 00:00:48.480
I spend a lot of my time educating people

00:00:48.680 --> 00:00:49.460
about durable execution.

00:00:49.920 --> 00:00:50.920
That's what my role is.

00:00:50.920 --> 00:00:53.040
I'm one of the developer educators at Temporal.

00:00:54.100 --> 00:00:57.820
And definitely you could spend hours on this and we could be going forever.

00:00:58.140 --> 00:00:58.620
So, yeah.

00:00:59.660 --> 00:01:00.900
Yeah, and we definitely could.

00:01:02.240 --> 00:01:05.339
Well, before we do go on for hours, who are you?

00:01:06.000 --> 00:01:06.420
Who's Mason?

00:01:07.360 --> 00:01:07.680
Well, yeah.

00:01:08.260 --> 00:01:09.160
My name is Mason Egger.

00:01:09.380 --> 00:01:12.120
I am a developer educator at Temporal, as I mentioned.

00:01:12.480 --> 00:01:15.500
And I also help run the PyTexas conference.

00:01:17.240 --> 00:01:23.700
So, PyTexas is one of the oldest, actually the oldest regional Python conference in the world that we know of.

00:01:24.320 --> 00:01:29.180
no one else has come to claim that spot yet we started in the late fall of 2007

00:01:30.280 --> 00:01:35.380
like right after PyCon US would have started we'll be experiencing our 20th year this upcoming year

00:01:35.380 --> 00:01:40.140
which is exciting and I also am the president of the PyTexas Foundation so PyTexas has its own

00:01:41.020 --> 00:01:47.220
501c3 organization that is used to basically act as a sheltering organization for all of the Python

00:01:47.980 --> 00:01:52.379
meetups and events that go on within the state of Texas which is really nice so I was elected

00:01:52.400 --> 00:01:58.480
president of that back in 2002. I've been helping run and build the Python community there ever

00:01:58.510 --> 00:02:02.120
since. And it's a lot of work, but it's a lot of fun. And I really enjoy my community work.

00:02:02.680 --> 00:02:10.320
Yeah, it sounds extremely fun. Although also challenging. You say for the entire state of

00:02:10.440 --> 00:02:15.800
Texas, Texas is a big place. It's like countries as well. If you look at the size of Texas.

00:02:16.780 --> 00:02:18.040
It really is. Texas

00:02:18.040 --> 00:02:23.780
has some unique issues with it when it comes to running community stuff.

00:02:25.960 --> 00:02:31.260
We founded our own virtual meetup for basically anyone in Texas and anyone else can join,

00:02:31.480 --> 00:02:35.820
obviously, too. We don't say, oh, no, no Texans can join it. But we did it because the amount

00:02:35.820 --> 00:02:40.200
of feedback we would get, it's like, oh, I live in, say, the DFW area, the Dallas-Fort Worth area,

00:02:40.760 --> 00:02:45.200
and I would love to go to the meetup, but I live two hours away from the meetup because of how

00:02:45.200 --> 00:02:50.560
large the Texas cities are. Texas cities are sprawling metroplexes. I grew up in the Houston

00:02:50.730 --> 00:02:55.720
area. And the joke when you grew up in Houston is you're always three hours away by car from every

00:02:55.790 --> 00:03:01.160
other part of Houston. And that really is the case. So it does have its own set of unique challenges

00:03:01.840 --> 00:03:08.200
trying to coordinate four major cities across, you know, technically two time zones. If we can,

00:03:08.360 --> 00:03:09.320
if we include El Paso,

00:03:09.970 --> 00:03:11.080
the very,

00:03:11.340 --> 00:03:14.419
very edge, the very west part of Texas is in the mountain time

00:03:14.440 --> 00:03:20.460
zone. So it's an interesting bit of work. And we've been doing a really good job of expanding

00:03:20.560 --> 00:03:24.860
and like adding more and more offerings that we can offer to the community year over year. And it's

00:03:25.500 --> 00:03:28.160
been a lot of fun. And I really enjoy it. It keeps me busy. That's for sure.

00:03:28.720 --> 00:03:34.480
Yeah, I could say. Is that why people drive so fast in Texas? They've got so far to go?

00:03:35.180 --> 00:03:40.140
Exactly. Yes. I mean, the fastest speed limit in the United States is on the highway next to my

00:03:40.260 --> 00:03:44.120
house. It's 85 miles an hour. And it's on the toll road next to my house. Because you're right,

00:03:44.200 --> 00:03:49.880
Like if you're trying to get from Austin to San Antonio, that's I think it's about 100 miles down.

00:03:50.060 --> 00:03:53.660
And like if you're going 55, you'll get there in, you know, two and a half hours.

00:03:53.760 --> 00:03:56.960
But I can make it in an hour and a half hour and 15 minutes if you just let me fly.

00:03:57.820 --> 00:03:58.300
I had no idea.

00:03:58.520 --> 00:03:58.960
Fly by car.

00:04:00.120 --> 00:04:00.440
Exactly.

00:04:00.680 --> 00:04:01.900
I had no idea that the speed of my car.

00:04:02.280 --> 00:04:03.720
I knew they were high, but not that high in Texas.

00:04:04.400 --> 00:04:04.480
Yep.

00:04:05.260 --> 00:04:06.300
Wild, you know.

00:04:07.280 --> 00:04:08.760
You guys in Germany, come on.

00:04:09.180 --> 00:04:10.540
Yeah, it is.

00:04:10.640 --> 00:04:12.480
It is the it is the Southern Autobahn, basically.

00:04:13.960 --> 00:04:20.620
Fantastic. So you've had a bit of a tougher challenge, I suppose, more

00:04:20.799 --> 00:04:25.220
challenges than a lot of people with this whole Pie Texas thing, which I've

00:04:25.220 --> 00:04:29.640
always thought was super cool. I'd love to go sometime. It's far from Oregon,

00:04:29.780 --> 00:04:35.540
but still would be really lovely. That said, you started working on this COVID

00:04:35.800 --> 00:04:40.000
time, right? Which for conferences is the kiss of death. You want to talk us

00:04:40.020 --> 00:04:40.780
through how that went?

00:04:41.500 --> 00:04:45.680
Yeah, I could definitely talk about that for a while. So I got involved

00:04:45.690 --> 00:04:50.960
in conference organizing, as most people do by first speaking at the conference. So I spoke at

00:04:50.960 --> 00:04:58.600
the conference in 2019. I had been a PyCon attendee prior to that. My first PyCon attendance was the

00:04:58.800 --> 00:05:06.440
last Portland one, which I believe was 2017. And then spoke at PyTexas in 2019 and volunteered to

00:05:06.420 --> 00:05:11.240
help for the 2020 conference. And that was really interesting because, you know, we had planned to do

00:05:11.280 --> 00:05:16.200
it in person. I think everybody had planned, was planning in person 2020, you know, because you,

00:05:16.500 --> 00:05:20.560
for those that don't know, when you start planning a conference, you start planning about eight,

00:05:21.260 --> 00:05:25.340
10 months prior. So if you're a spring conference as PyTexas is, we were planning,

00:05:26.080 --> 00:05:30.920
you know, PyTexas 2020 in about summer of 2019. No one knew what was coming.

00:05:32.020 --> 00:05:34.860
We were so innocent then. Yes. We were so innocent.

00:05:35.080 --> 00:05:35.440
We

00:05:35.440 --> 00:05:47.860
really were. So we were planning that. And then, you know, the events that we know of happened and we kept chasing it. We kept pushing it back. I think a lot of conferences at that time kept pushing back thinking, oh, we'll be out of this in two weeks. We'll be out of this in three months.

00:05:48.920 --> 00:05:49.940
We ended up going virtual.

00:05:50.920 --> 00:05:54.260
And then in 2021, we made the conscious decision to just not have a conference.

00:05:54.690 --> 00:05:58.200
The virtual conference for us in 2020 wasn't overly successful.

00:05:59.390 --> 00:06:02.300
And at that time, we were feeling there was just a lot of virtual conference fatigue.

00:06:02.680 --> 00:06:11.560
And we didn't have a really good story on how to make it work and dedicate the time.

00:06:11.660 --> 00:06:15.620
Everybody was also struggling to handle the world at that time.

00:06:15.710 --> 00:06:17.700
So being able to put more resources into it.

00:06:18.720 --> 00:06:23.720
was difficult. So we pushed that off and then we came back in 2022. We made a very conscious

00:06:23.860 --> 00:06:27.160
decision about it. Like we were like, we're going to come back in the safest way possible. PyCon US

00:06:27.290 --> 00:06:31.240
had announced they were coming back. We decided we were going to come back. We have a venue that

00:06:31.500 --> 00:06:36.780
has custom air filtration. We instilled mask mandates and vaccine mandates and all of that

00:06:36.920 --> 00:06:42.040
stuff. And we had 76 people return. But we knew that if we didn't come back, if we let this kind

00:06:42.110 --> 00:06:47.840
of like continue on, that the likelihood of getting the community to come back, that the memory

00:06:48.040 --> 00:06:52.640
is short that if we didn't come back, we might lose it forever. And

00:06:52.640 --> 00:06:53.540
having

00:06:53.540 --> 00:06:54.520
run this for 18 years,

00:06:54.620 --> 00:06:56.240
we were concerned about losing it at that point.

00:06:56.340 --> 00:06:58.020
That's, I think that's totally valid. Like a lot

00:06:58.060 --> 00:07:04.380
of this conference attending is it's habit. You form either you've gone a bunch of times. You

00:07:04.480 --> 00:07:07.540
really enjoy it. Like, yeah, of course I'm going to go. You don't even question like, well, when is

00:07:07.580 --> 00:07:12.040
it? I'm just going to sign up when it comes out. But you know, if

00:07:12.040 --> 00:07:12.720
you stop

00:07:12.720 --> 00:07:13.780
going, then I think that

00:07:13.800 --> 00:07:15.900
does make a big change. So it

00:07:15.900 --> 00:07:19.640
definitely does. So in 22, we, we did it and then we kept coming back.

00:07:19.840 --> 00:07:24.460
And then, you know, every year prior after that, we, we continue to grow. it took us three

00:07:24.620 --> 00:07:30.480
years to get back to above, what, what I would consider pre pandemic normals. and the,

00:07:30.600 --> 00:07:35.240
the fun fact about that is, and the thing that I think that, really kind of helped us out is

00:07:35.260 --> 00:07:40.000
like, we didn't really start seeing the growth back in the conference attendance until us as the

00:07:40.020 --> 00:07:47.280
foundation turned our inwards local or our, sorry, our vision local or our site to start focusing on

00:07:47.320 --> 00:07:52.560
the local meetups because the local meetup scene had not returned. And that was the vast majority

00:07:52.560 --> 00:07:58.220
of our, of our, of our marketing was that we would send out these emails and stuff, or the local

00:07:58.380 --> 00:08:01.920
meetups would promote us. And these are huge meetups. I mean, the Python, the, the, some of

00:08:01.920 --> 00:08:05.860
the Python meetups in Texas are some of the oldest meetups that I, that I know of. I mean, like they,

00:08:05.920 --> 00:08:09.500
they started in the, in the early, in the late aughts in the early teens.

00:08:10.540 --> 00:08:13.480
Yeah. I would say they probably were not even called meetups when they started,

00:08:13.680 --> 00:08:14.220
right? The user

00:08:14.220 --> 00:08:16.260
groups or something. They predate

00:08:16.260 --> 00:08:17.820
meetup, meetup.com and all that.

00:08:18.300 --> 00:08:22.240
Yeah. They're, they're, I think the, the pie Houston meetup group is called like their,

00:08:22.340 --> 00:08:28.120
their tag on meetup.com is Python dash 14. So I'm assuming it was the fourth,

00:08:28.280 --> 00:08:34.300
14th Python meetup when it was created in the world on meetup.com. So, and you know,

00:08:34.380 --> 00:08:39.360
large groups, but these meetups had gone dormant. So what I did as, as foundation president at that

00:08:39.440 --> 00:08:43.599
time was I was like, okay, I'm going to spend all of my effort while my organizers are helping get

00:08:43.599 --> 00:08:47.280
the conference going. I'm going to spend all of my effort finding organizers and rebuilding these

00:08:47.420 --> 00:08:51.820
meetups in these areas. so I would connect with people that I knew in the area. I would reach

00:08:51.820 --> 00:08:57.240
out to friends. I would put out all calls and after time of rebuilding the ecosystem, then we

00:08:57.680 --> 00:09:01.360
basically everything came back to life. And that's kind of where a little, you know, the things that

00:09:01.380 --> 00:09:05.920
have learned is that if your meetup ecosystem is not healthy, then your regional Python conference

00:09:06.160 --> 00:09:09.060
ecosystem will not be healthy because it has to feed up into it.

00:09:10.080 --> 00:09:10.240
Yeah.

00:09:10.740 --> 00:09:10.880
Yeah.

00:09:13.380 --> 00:09:21.340
I think it's such a challenge to run like a conference or a podcast or whatever

00:09:23.200 --> 00:09:28.320
to draw in new people. I mean, you can do all the amazing mailing lists and announcements and

00:09:28.340 --> 00:09:32.800
everything but you're speaking to your existing people that know about you and finding new ones

00:09:33.020 --> 00:09:39.440
it's really interesting and this cultivating like user groups to sort of be the foundation

00:09:39.710 --> 00:09:42.140
it's a very interesting idea definitely

00:09:42.140 --> 00:09:45.420
user groups work i think we also started the pie texas meetup

00:09:45.710 --> 00:09:50.200
um which was a virtual meetup that we do monthly that we allow anyone to join and we cultivated

00:09:50.320 --> 00:09:55.320
amongst our network of friends and social media and word of mouth and then we all know what

00:09:55.140 --> 00:09:59.300
what happened with the social media situation, which really did not help. I mean, there was a

00:09:59.300 --> 00:10:03.040
lot of just a lot of things that have happened with like, like the dissolution of Twitter,

00:10:03.720 --> 00:10:09.280
um, really did not help the conference in the tech ecosystem. Basically we've all fractured

00:10:09.380 --> 00:10:14.400
now we're all in like six different places. Like the move to Mastodon is not complete. blue

00:10:14.580 --> 00:10:18.800
sky had its moment, but I honestly get less engagement on blue sky than anything else.

00:10:19.340 --> 00:10:19.900
LinkedIn has

00:10:19.900 --> 00:10:24.140
surprisingly been my, our most successful, social media platform. Um,

00:10:24.340 --> 00:10:27.160
it seems like a lot of people have moved there for some reason or another.

00:10:27.640 --> 00:10:32.080
so, but not basically it means that you just have to reapply your marketing, 

00:10:33.020 --> 00:10:33.120
strategies.

00:10:33.380 --> 00:10:37.140
And the fun thing that I've had, I've had the benefit of is that I, as my work as a developer

00:10:37.340 --> 00:10:40.640
advocate, all the roles that I have done, they tend to sit in marketing.

00:10:41.260 --> 00:10:44.880
developer advocacy tends to either sit in product or marketing, all the one, the roles

00:10:45.020 --> 00:10:46.140
that I have taken sit in marketing.

00:10:46.860 --> 00:10:51.140
And I've had the benefit of like, whenever this has started going weird or I can ask all

00:10:51.140 --> 00:10:53.880
of my marketing friends, Hey, what would you do in this situation?

00:10:53.940 --> 00:10:54.480
and how would you

00:10:54.480 --> 00:10:55.040
approach this?

00:10:55.630 --> 00:10:57.240
So I've got to learn through osmosis,

00:10:57.400 --> 00:10:58.760
kind of how marketing stuff works

00:10:58.920 --> 00:11:00.040
and being able to apply that

00:11:00.280 --> 00:11:01.940
to conference organizing and meetup organizing

00:11:02.360 --> 00:11:04.980
has actually been substantially beneficial to us.

00:11:05.460 --> 00:11:07.900
Yeah, certainly I think companies

00:11:08.120 --> 00:11:12.220
that are turned on enough to have developer advocates

00:11:13.100 --> 00:11:15.540
have developer intelligent marketing teams

00:11:15.610 --> 00:11:16.340
and that's a real resource.

00:11:17.200 --> 00:11:17.780
Definitely, yeah.

00:11:17.840 --> 00:11:20.520
It's been really useful to be able to get other people's opinions

00:11:20.670 --> 00:11:23.040
and then just ask other conference organizers,

00:11:23.160 --> 00:11:23.580
what are they doing?

00:11:23.760 --> 00:11:28.400
I think that finding out what works and telling other people about it.

00:11:28.460 --> 00:11:32.380
I mean, I haven't had a chance to write this year's blog post yet, unfortunately, for this

00:11:32.460 --> 00:11:32.740
year's conference.

00:11:32.880 --> 00:11:38.460
But whenever I became conference chair and then president, I was like, we're going to

00:11:38.460 --> 00:11:39.480
be as transparent as possible.

00:11:39.720 --> 00:11:42.180
Every misstep we make, we're going to blog about it.

00:11:42.880 --> 00:11:43.820
We talk about our budget.

00:11:43.900 --> 00:11:46.600
I mean, we're also a 501c3, so that's kind of like part of our bylaws.

00:11:47.140 --> 00:11:49.340
But at the same time, it's like, this is everything that we do.

00:11:49.700 --> 00:11:50.840
You can find it on all of our websites.

00:11:52.100 --> 00:11:52.820
And this is what worked.

00:11:52.960 --> 00:12:00.700
This is what didn't because there's so many first time conference organizers who may want to start a conference who don't know how to achieve these goals or whatever they're trying to do.

00:12:02.320 --> 00:12:04.640
And we have 20 years of experience doing it.

00:12:04.920 --> 00:12:09.260
And like it, we need to help each other out and make sure that we distill this, this knowledge outward.

00:12:10.180 --> 00:12:11.220
I don't have 20 years of experience.

00:12:11.420 --> 00:12:14.700
I'm only doing it for four, but you know, institutional knowledge.

00:12:14.820 --> 00:12:18.980
There are, there are Google docs with like years of back data that I can go and look

00:12:19.040 --> 00:12:19.780
at and be like, Oh yeah.

00:12:19.910 --> 00:12:26.120
In 2009, we ordered way too many meals because we, you know, didn't charge enough for, we

00:12:26.200 --> 00:12:27.160
didn't charge anything for tickets.

00:12:27.690 --> 00:12:29.100
Like Pike seconds used to be a free conference.

00:12:29.780 --> 00:12:32.760
And basically when you don't charge anything for tickets, one of the lessons that we learned

00:12:32.800 --> 00:12:35.360
is that people will just sign up for a ticket and then not show up.

00:12:35.360 --> 00:12:37.500
And then your, your catering gets all kind of out of whack.

00:12:37.970 --> 00:12:41.080
So even charging just a little bit of money, like five bucks, I think like we charge like

00:12:41.240 --> 00:12:42.360
$5 for our network event.

00:12:42.620 --> 00:12:43.920
It's not because I need the $5.

00:12:44.060 --> 00:12:47.500
I mean, I've told, I've told my, we spend, I think $30 per person on the food.

00:12:48.040 --> 00:12:51.860
It's like, it's to make sure that you have a little bit of like skin in the game to make

00:12:51.920 --> 00:12:55.400
sure that you show up so I can get an accurate head count for the, for the, for the catering.

00:12:55.700 --> 00:12:55.980
So we

00:12:55.980 --> 00:12:56.480
don't blow

00:12:56.480 --> 00:12:57.560
the budget by $10,000.

00:12:57.960 --> 00:12:58.080
Like

00:12:58.080 --> 00:12:59.400
I'm not envious of that.

00:12:59.520 --> 00:13:02.620
I certainly it's easy to just check a checkbox.

00:13:03.340 --> 00:13:03.440
Yeah.

00:13:03.520 --> 00:13:03.800
I'm interested.

00:13:04.040 --> 00:13:04.440
Why not?

00:13:04.839 --> 00:13:05.160
Yeah.

00:13:05.560 --> 00:13:06.260
If, if I come.

00:13:06.600 --> 00:13:06.660
Yeah,

00:13:07.180 --> 00:13:07.300
exactly.

00:13:08.360 --> 00:13:08.640
Exactly.

00:13:09.300 --> 00:13:09.560
All right.

00:13:10.020 --> 00:13:10.200
Awesome.

00:13:10.360 --> 00:13:12.360
Well, congratulations out in the audience.

00:13:12.880 --> 00:13:15.280
June Army says, yay, Pie Texas Foundation.

00:13:15.580 --> 00:13:16.160
That's pretty awesome.

00:13:16.760 --> 00:13:17.120
Yeah.

00:13:19.180 --> 00:13:19.440
All right.

00:13:19.800 --> 00:13:24.980
Well, let's talk temporal.

00:13:25.520 --> 00:13:28.880
Now, I came across this a few weeks ago from this.

00:13:30.900 --> 00:13:34.340
You know, I think this ironically, I think this might be the blue sky that I came across it on.

00:13:35.220 --> 00:13:35.340
Interesting.

00:13:37.160 --> 00:13:37.360
No.

00:13:37.660 --> 00:13:37.760
Okay.

00:13:37.770 --> 00:13:38.300
It was on X.

00:13:38.720 --> 00:13:40.220
There's still apparently stuff that happens on there.

00:13:42.940 --> 00:13:43.700
I miss Twitter.

00:13:44.480 --> 00:13:45.260
And people

00:13:45.260 --> 00:13:46.600
post weird

00:13:48.220 --> 00:13:48.860
comments on

00:13:49.639 --> 00:13:50.760
reviews on the show like,

00:13:51.520 --> 00:13:52.300
oh, you know,

00:13:52.880 --> 00:13:55.040
they said they don't like Twitter, so they must be

00:13:55.220 --> 00:13:56.060
whatever. No.

00:13:57.300 --> 00:13:58.800
It used to be so active and it's not so

00:13:58.800 --> 00:13:59.100
active.

00:13:59.480 --> 00:14:00.660
Put aside everything else.

00:14:00.660 --> 00:14:01.000
It used

00:14:01.000 --> 00:14:02.160
to be like you could have a

00:14:02.160 --> 00:14:02.900
great conversation and you

00:14:03.060 --> 00:14:04.500
still can, but it's so much less than it used

00:14:04.500 --> 00:14:04.700
to be.

00:14:04.860 --> 00:14:06.500
It's an easy explanation.

00:14:06.780 --> 00:14:08.940
The signal to noise ratio is completely messed up

00:14:09.040 --> 00:14:09.100
now.

00:14:09.620 --> 00:14:10.020
It

00:14:10.020 --> 00:14:10.940
used to be such a

00:14:10.960 --> 00:14:14.480
much better place because everybody was posting there and there wasn't as much noise. And now

00:14:14.560 --> 00:14:18.200
the signal to noise ratio makes it almost unintelligible to be able to find anything of any

00:14:18.380 --> 00:14:20.700
use. And that's the number one problem with it. And

00:14:20.700 --> 00:14:22.540
you pay for attention. And there's six other

00:14:22.720 --> 00:14:23.300
places, like you said. So

00:14:23.300 --> 00:14:23.960
anyway, so I

00:14:23.960 --> 00:14:24.320
found this

00:14:24.320 --> 00:14:29.320
post from we'll work it backwards from Pietro

00:14:29.580 --> 00:14:35.080
says people aren't talking enough about how most of open AI's tech stack runs on Python,

00:14:35.760 --> 00:14:38.000
which I thought was a super cool post.

00:14:38.040 --> 00:14:41.780
It comes from the Pragmatic Engineer newsletter,

00:14:42.760 --> 00:14:46.320
and it talks about how most of the product's code is written in Python,

00:14:47.399 --> 00:14:50.060
uses FastAPI, C for certain parts.

00:14:50.140 --> 00:14:51.460
And then, so all that stuff made sense.

00:14:51.460 --> 00:14:52.180
I'm like, yep, yep.

00:14:53.100 --> 00:14:55.040
Then Temporal, used for asynchronous workflows.

00:14:55.300 --> 00:14:56.940
I'm like, what is Temporal?

00:14:57.000 --> 00:14:58.760
And then I think you sent me a message and said,

00:14:58.880 --> 00:15:00.780
hey, I would love to talk to you about Temporal.

00:15:00.980 --> 00:15:03.300
And I looked at him and I'm like, yeah, this is super cool.

00:15:03.540 --> 00:15:08.780
So that's how I learned about you guys, which I thought was pretty neat.

00:15:09.300 --> 00:15:12.260
And yeah, let's talk about it.

00:15:14.820 --> 00:15:16.200
What is Temporal?

00:15:16.520 --> 00:15:16.880
Yeah.

00:15:17.400 --> 00:15:21.860
So Temporal is essentially what we call a durable execution platform.

00:15:23.360 --> 00:15:29.860
And it's durable execution is kind of a new term or a new like field within the zeitgeist,

00:15:29.940 --> 00:15:30.580
as you would call it.

00:15:31.200 --> 00:15:31.740
And we're

00:15:31.740 --> 00:15:33.860
kind of going with like what we're calling crash proof execution.

00:15:35.880 --> 00:15:41.160
And the way that we kind of talk about it now is like, essentially, it handles the failure

00:15:41.320 --> 00:15:46.440
state of your of your applications and ensures that your code will continue execution regardless

00:15:46.520 --> 00:15:48.900
of the failures that it encounters.

00:15:49.620 --> 00:15:55.360
So say, for example, you have a application that's making a couple calls out to a microservice.

00:15:55.700 --> 00:15:58.240
OK, and that microservice goes temporarily down.

00:15:58.980 --> 00:16:04.240
you as the developer would have to traditionally write a whole bunch of logic around handling that

00:16:04.440 --> 00:16:08.480
failure. Okay. So we have to detect that the failure has happened. what type of error

00:16:08.530 --> 00:16:13.460
did we receive now? Now, what do we do? Do we back off and retry? Do we, do we decide that this

00:16:13.550 --> 00:16:17.300
failure is non-retriable and we just don't do it? Like the difference between we're not authenticated

00:16:17.480 --> 00:16:22.960
versus a 404, those are completely different failure handling modes. and then, so there's

00:16:23.180 --> 00:16:27.639
all of this kind of logic that you have to build into handle failure. temporal basically

00:16:27.900 --> 00:16:31.860
abstracts this away from you. So whenever you have a function call or a method call in Python

00:16:32.530 --> 00:16:38.520
when implemented with Temporal, you automatically get retries, for example, by default. So you get

00:16:38.660 --> 00:16:43.260
this declarative policy that happens. There's a default policy, and it will automatically retry

00:16:43.260 --> 00:16:48.280
your application or your call until eventually it comes back online. Because let's be honest,

00:16:48.450 --> 00:16:52.800
in most distributed systems like this, those are most of the time intermittent failures.

00:16:53.300 --> 00:16:56.140
Like a microservice going offline, are you being rate limited?

00:16:56.740 --> 00:17:00.960
Those are usually fixable with a little bit of time and some retries.

00:17:01.330 --> 00:17:02.240
Now, there are other

00:17:02.240 --> 00:17:02.720
cases where

00:17:02.720 --> 00:17:04.319
they're not, but that's like the default policy.

00:17:04.520 --> 00:17:08.620
That's the default use case or the default like for retries alone.

00:17:09.209 --> 00:17:10.459
And then there's a lot of other cases.

00:17:10.550 --> 00:17:16.600
So Temporal maintains the application state of your application.

00:17:16.980 --> 00:17:22.339
And so say you have like a Python application that has 10 steps in it and you get through

00:17:22.319 --> 00:17:27.640
step five and then the python application were to crash for some reason out of memory uh maybe your

00:17:27.880 --> 00:17:31.880
kubernetes pod got descheduled something like this and production happens happens all the time this

00:17:31.980 --> 00:17:35.480
is as a former sre this was this was the life that i

00:17:35.480 --> 00:17:35.940
lived

00:17:35.940 --> 00:17:36.480
for years

00:17:36.480 --> 00:17:39.820
um yeah even hey there's a

00:17:39.900 --> 00:17:42.120
security patch for the Linux server that's the

00:17:42.120 --> 00:17:43.400
yeah running

00:17:43.400 --> 00:17:45.160
this and we got to restart it and like uh

00:17:45.960 --> 00:17:49.400
we have to reboot yeah and now yes it's not long but like

00:17:49.400 --> 00:17:51.220
stuff is going on exactly

00:17:51.220 --> 00:17:52.280
so now you have

00:17:52.300 --> 00:17:55.080
when you have to deal with that, you're like, okay, so do we let everything get through and

00:17:55.320 --> 00:17:59.680
risk the attack surface? Or do we like, or then you have to make the calculus. Do we just

00:18:00.620 --> 00:18:06.280
kill all the processes and then wait for, and then restart them? And what's the cost on the

00:18:06.620 --> 00:18:10.400
restart? And then redoing all of that logic. Did they make any rights to the database? Do we have

00:18:10.400 --> 00:18:14.620
to worry about like cleaning all that? There's all of this conversation. So since Temporal

00:18:14.820 --> 00:18:20.320
maintains that application state, that becomes a lot simpler because as we, I think we kind of

00:18:20.260 --> 00:18:25.180
alluded to it, but I'll state it outright. When that application crashes, and in a typical

00:18:25.780 --> 00:18:30.380
application, you have to start back over from the beginning, and you have to replay, you basically

00:18:30.700 --> 00:18:35.840
re-execute everything you did, unless you have some advanced event sourcing style model where

00:18:35.890 --> 00:18:37.620
you are keeping track of it. Temporal does

00:18:37.620 --> 00:18:37.960
this by

00:18:37.960 --> 00:18:40.320
default. So it maintains the event history,

00:18:40.420 --> 00:18:45.360
what's called an event history, of your application. And what that does is every time a,

00:18:46.120 --> 00:18:50.200
basically it creates checkpoints. Every time a function executes, it stores the result of it,

00:18:50.240 --> 00:18:54.740
it. And if that application were to crash, it will reschedule it onto another worker. That's what

00:18:54.820 --> 00:18:59.620
they're called in temporal. And we'll get into that in a minute within your fleet, re reconstruct

00:18:59.940 --> 00:19:04.180
the state of that application up into that point of failure, and then continue onward as if the

00:19:04.290 --> 00:19:08.880
failure had never happened. And more often than not, this happens without the developer even being

00:19:09.030 --> 00:19:13.920
aware of it. Like no, no alarms will go off unless you personally do them because this is the design

00:19:14.040 --> 00:19:18.720
of the system. It's to ensure that in spite of failure, your application will continue executing.

00:19:19.360 --> 00:19:45.480
Yeah, that's awesome. And there's a bunch of neat ways in which that happens, which we'll talk about. But I think one mental model people should maybe think about when they consider these is it centralizes a lot of the error handling and the retry code and all of that stuff. So a lot of your application becomes simpler, not more complex.

00:19:46.760 --> 00:19:50.440
Exactly. Yes. That's actually one of the main feedback things that we get from people is,

00:19:51.480 --> 00:19:56.660
you know, all of this, there's so many mechanisms. There's so many actually like patterns that we

00:19:56.660 --> 00:20:02.520
have now built to handle all of these kinds of things. Event sourcing, event-driven architecture,

00:20:02.680 --> 00:20:06.620
saga pattern, all of these different like CQRS, like all of these different distributed systems

00:20:06.740 --> 00:20:12.860
patterns that exist to handle all of these things. And Temporal basically abstracts away a lot of them

00:20:13.360 --> 00:20:15.820
And you get them basically for free out of the box with the project.

00:20:16.600 --> 00:20:18.340
And it does make your code a lot simpler.

00:20:18.520 --> 00:20:20.760
It makes it a lot more contained.

00:20:21.260 --> 00:20:23.040
So you can walk through it straight down.

00:20:24.120 --> 00:20:25.900
Basically, almost as like it's a workflow.

00:20:26.540 --> 00:20:28.360
You know, the core primitive of temporal is called a workflow.

00:20:28.500 --> 00:20:30.800
We don't tend to like to refer to ourself as a workflow engine.

00:20:31.260 --> 00:20:32.560
But some people will say that.

00:20:32.660 --> 00:20:34.520
I typically don't correct them on it.

00:20:35.220 --> 00:20:38.240
If that's what it takes for people to understand that's what it is, fine.

00:20:38.280 --> 00:20:40.060
But durable execution is the actual phrase.

00:20:41.500 --> 00:20:42.560
It's a meaty topic.

00:20:42.840 --> 00:20:45.620
it's kind of hard for people to like kind of wrap their heads around it.

00:20:45.680 --> 00:20:47.940
So I'm like, let's get you to understanding it.

00:20:47.980 --> 00:20:50.520
And then we'll correct the little tidbits here and there.

00:20:51.560 --> 00:20:52.040
Yeah, excellent.

00:20:52.480 --> 00:20:59.380
So, you know, people are probably familiar with NX stamina or with tenacity,

00:20:59.960 --> 00:21:04.960
which is interesting where you might put a decorator onto a function and say,

00:21:05.100 --> 00:21:05.180
hey,

00:21:05.200 --> 00:21:09.560
if this fails, instead of just crashing, try it again.

00:21:10.660 --> 00:21:10.740
Yeah.

00:21:11.000 --> 00:21:13.740
maybe a few times, maybe with exponential back off.

00:21:14.720 --> 00:21:21.800
And this is kind of a single thread of execution type of form of durability a little bit, right?

00:21:22.080 --> 00:21:29.500
Where it's like this function now becomes somewhat more reliable based on like maybe the service comes back

00:21:30.500 --> 00:21:34.740
or maybe your network comes back or whatever it happened to be that caused this particular example.

00:21:35.380 --> 00:21:39.180
But with temporal, it's a lot broader, right?

00:21:39.280 --> 00:21:45.940
Like every step, it saves the state.

00:21:46.580 --> 00:21:50.200
If something goes wrong, it can basically resume.

00:21:50.300 --> 00:21:52.740
I guess maybe this resumable idea is

00:21:52.740 --> 00:21:53.220
like one

00:21:53.220 --> 00:21:54.140
of the big difference, right?

00:21:54.320 --> 00:21:58.620
It's like let's take our reboot the server example.

00:21:59.100 --> 00:21:59.560
Let's suppose

00:21:59.560 --> 00:22:02.960
we got some service that we work on that our app depends upon.

00:22:03.280 --> 00:22:04.060
We had to reboot it.

00:22:05.580 --> 00:22:05.860
Now what?

00:22:06.240 --> 00:22:06.700
It happens.

00:22:07.640 --> 00:22:07.720
Yeah.

00:22:07.960 --> 00:22:10.780
So, I mean, yeah, you have a service that our app depends on.

00:22:10.830 --> 00:22:11.380
We had to reboot it.

00:22:11.390 --> 00:22:16.100
So if the service, so we're assuming our service is on an external

00:22:16.100 --> 00:22:17.680
machine and

00:22:17.680 --> 00:22:17.960
it's

00:22:17.960 --> 00:22:18.360
calling out.

00:22:18.360 --> 00:22:18.920
Yeah, for some reason.

00:22:19.500 --> 00:22:23.200
Yeah, or maybe it's a Docker container and we rebuilt the Docker container.

00:22:23.250 --> 00:22:24.380
It takes five seconds to start.

00:22:24.520 --> 00:22:24.920
Something like that.

00:22:24.940 --> 00:22:25.040
Yeah.

00:22:25.270 --> 00:22:27.040
So our service is calling out to it.

00:22:27.040 --> 00:22:29.160
It will basically retry until that comes back online.

00:22:29.430 --> 00:22:35.140
Now, if we were to reboot our service, say our service was running and we rebooted the container that contained it,

00:22:36.180 --> 00:22:44.440
It would basically, you know, if we're in a Kubernetes system, the Kubernetes scheduler would probably reschedule it onto another, you know, node within the pod.

00:22:45.500 --> 00:22:47.040
And then it would reconstruct.

00:22:47.300 --> 00:22:56.200
And what happens is there's actually a sort of the temporal exists as a kind of kind of an orchestrator executor model, like a service worker model.

00:22:56.970 --> 00:22:58.520
So the service maintains the history.

00:22:58.920 --> 00:23:05.980
So what will happen is whenever that new service comes online or whenever the new execution comes online, you know, we've rebooted it.

00:23:06.030 --> 00:23:06.800
It got rescheduled.

00:23:06.800 --> 00:23:07.240
It comes online.

00:23:07.330 --> 00:23:13.420
It will stream the old history from the service and then reconstruct it, basically going step by step through it.

00:23:13.820 --> 00:23:21.100
And so like the function, you know, function A that was executed, the input and output values are stored in that event history.

00:23:21.540 --> 00:23:28.640
So the output value, it's like, oh, we successfully completed execution of function A, store that in variable foo, and then continue onward.

00:23:28.640 --> 00:23:36.200
And then we can continue reconstructing that service up until it gets to the point where it's like, okay, we have no more events in the history about what happened.

00:23:36.620 --> 00:23:39.840
So now we know we have reconstructed successfully.

00:23:40.280 --> 00:23:44.020
Now we continue forward and execute as if nothing had happened.

00:23:45.280 --> 00:23:45.600
Yeah.

00:23:46.640 --> 00:23:55.920
So in your non-durable execution code, you might have try, accept, do something else.

00:23:56.320 --> 00:24:02.020
You might have stuff like stamina or tenacity where you're like, okay, we're going to try this again.

00:24:03.040 --> 00:24:05.260
There's a lot of that kind of code that you write.

00:24:05.840 --> 00:24:06.500
And in this

00:24:06.500 --> 00:24:12.200
world, you could just say like top to bottom, write the happy path, which is great.

00:24:12.320 --> 00:24:15.900
And then what happens is Temporal says, okay, I tried to run this.

00:24:15.950 --> 00:24:16.400
It failed.

00:24:16.530 --> 00:24:21.780
So we'll reschedule it with a back off or something along those lines.

00:24:21.870 --> 00:24:21.980
Right.

00:24:22.540 --> 00:24:27.280
So you can, you can basically not deal with a lot of this and get visibility into the

00:24:27.460 --> 00:24:29.020
errors and the state of flow by

00:24:29.020 --> 00:24:29.800
letting the

00:24:29.800 --> 00:24:30.980
orchestrator manage that.

00:24:31.060 --> 00:24:31.120
Right.

00:24:31.820 --> 00:24:32.000
Yes.

00:24:32.120 --> 00:24:32.600
And there are there.

00:24:32.740 --> 00:24:37.160
I'm, I'm, I'm covering like the top 10% of all the different features.

00:24:37.320 --> 00:24:42.720
There are so many interesting other features that Temporal provides as an ecosystem.

00:24:43.300 --> 00:24:48.940
So one of the other really neat ones is that we provide a really simple way for things to do a human-in-the-loop interaction.

00:24:49.520 --> 00:24:51.720
So you can very easily send in what's called a signal.

00:24:52.130 --> 00:24:57.240
So basically sending in data into a running execution and then basically doing some processing on it.

00:24:57.360 --> 00:25:01.500
So you're waiting on a confirmed signal from someone.

00:25:01.700 --> 00:25:02.940
Your application is doing something.

00:25:03.020 --> 00:25:03.660
You're waiting on a confirm.

00:25:04.160 --> 00:25:06.420
You can send that in directly into the workflow.

00:25:07.060 --> 00:25:11.300
And then that will basically be, that's persisted again, within the events, within the event

00:25:11.720 --> 00:25:11.860
history.

00:25:12.280 --> 00:25:16.940
So if it crashes after that confirmation, that confirmation is stored as well.

00:25:17.740 --> 00:25:20.460
So you have that, you have the ability to do long running schedules.

00:25:21.260 --> 00:25:24.520
So there's like, there's some cron syntax, like what's what are called schedules in temporal.

00:25:24.840 --> 00:25:27.600
There's the ability to do,

00:25:28.600 --> 00:25:30.620
what are they called?

00:25:30.660 --> 00:25:31.680
I forgot off the top of my head.

00:25:34.500 --> 00:25:35.340
Oh no, they left.

00:25:35.980 --> 00:25:43.500
There's so many different features in Temporal that are that are just really neat and can solve a lot of the problems that you're trying to do.

00:25:44.740 --> 00:25:46.340
And scaling becomes super easy as well.

00:25:46.340 --> 00:25:48.820
So like you want to scale, just add more workers to the fleet.

00:25:49.360 --> 00:25:56.600
That's that's the easiest thing you can do is just add more of these workers and they basically can be executed across all of your different fleets.

00:25:56.610 --> 00:25:59.720
So the scaling story is super awesome as well.

00:26:00.880 --> 00:26:02.060
Yeah, there's we'll get into it.

00:26:02.140 --> 00:26:03.920
There's definitely some examples of.

00:26:04.600 --> 00:26:04.680
Yeah.

00:26:05.680 --> 00:26:10.360
large scale use cases, you know, high, high frequency use cases of these things.

00:26:11.460 --> 00:26:17.300
But going back to the timing, you know, what if your user onboarding looks more

00:26:17.500 --> 00:26:19.440
like, I guess you could be real simple.

00:26:19.440 --> 00:26:24.840
You could say in order to create a user account, I have to first have them create

00:26:24.900 --> 00:26:28.160
an, you know, enter their username and email or their email and their password.

00:26:29.240 --> 00:26:33.080
And then I'm going to send them an email and they got to take an action based on

00:26:33.160 --> 00:26:33.580
that, right?

00:26:33.700 --> 00:26:38.120
That would be pretty common, like a long running type of thing you could consider.

00:26:38.290 --> 00:26:44.120
But for some of these systems, it's like, and prove who you are and upload a document.

00:26:45.580 --> 00:26:49.140
That's a picture of your ID and somebody will look at it and go, yeah, that looks real enough.

00:26:49.740 --> 00:26:54.440
And they check a box or, you know, those kinds of much longer onboarding things.

00:26:54.690 --> 00:26:57.200
Something like that could be modeled with temporal pretty easily, it sounds like.

00:26:57.440 --> 00:26:57.700
Yeah.

00:26:57.870 --> 00:27:01.560
So long running workflows are the other, that was the feature I couldn't remember, which was timers.

00:27:01.630 --> 00:27:02.900
And I have no idea why that left my mind.

00:27:03.040 --> 00:27:03.860
It's one of my favorite features.

00:27:04.650 --> 00:27:08.680
Long running workflows are one of the like amazing use cases of Temporal.

00:27:08.730 --> 00:27:13.960
So because everything is maintained in this, in that state and basically crashing doesn't

00:27:14.140 --> 00:27:16.220
really matter because we can just reconstruct the state.

00:27:16.220 --> 00:27:21.880
You can have workflows or you can have your executions that can last for days, weeks,

00:27:22.460 --> 00:27:22.640
years.

00:27:23.700 --> 00:27:24.560
This is kind of what we know at work.

00:27:24.750 --> 00:27:26.620
We kind of known as the entity workflow pattern.

00:27:26.860 --> 00:27:30.900
So essentially like a user who's going through an onboarding process, you know, like you just

00:27:30.860 --> 00:27:35.820
And I think the identity workflow process is actually one of our exact sample applications.

00:27:36.500 --> 00:27:40.040
So, you know, like you're right, they lay sign up and they have to upload some forms of ID.

00:27:40.320 --> 00:27:41.240
Someone has to check it.

00:27:41.360 --> 00:27:43.800
It has to go through maybe a background check process and all of that.

00:27:45.000 --> 00:27:46.260
That's a long running workflow.

00:27:46.280 --> 00:27:47.200
That could take days.

00:27:47.280 --> 00:27:50.100
That could take weeks, depending on what kind of background check you're getting done.

00:27:51.120 --> 00:27:58.260
Temporal can suspend its state for however long it wants, you know, and we can guarantee that it will come back online.

00:27:58.460 --> 00:28:13.620
So the interesting thing, and whenever you ever, if you ever see Temporal at a booth at a conference, we were at PyCon this year, for example, our code sample on our booth has a really interesting statement that always catches people's eye, and it's a little mini workflow, and it's sending emails.

00:28:13.870 --> 00:28:15.800
And what it does is it says sleep for 30 days.

00:28:16.580 --> 00:28:22.860
And nobody in their right mind would actually write a sleep for 30 days in code and expect it to actually function.

00:28:23.480 --> 00:28:27.840
100% works exactly the way you would expect it to in Temporal, and we can guarantee that it works.

00:28:28.300 --> 00:28:30.120
because of the way that Temporal is architected,

00:28:30.200 --> 00:28:32.920
those timers basically exist on the servers,

00:28:33.080 --> 00:28:34.520
on the Temporal service side,

00:28:34.860 --> 00:28:35.500
and they just get,

00:28:35.880 --> 00:28:37.840
basically your workflow just gets scheduled to resume

00:28:38.600 --> 00:28:39.680
after the timer has fired.

00:28:40.300 --> 00:28:40.380
So

00:28:40.380 --> 00:28:40.800
you can

00:28:40.800 --> 00:28:42.280
guarantee that long running workflows

00:28:42.720 --> 00:28:45.040
will complete exactly the way that you expect them to.

00:28:46.000 --> 00:28:46.900
So yeah, long running workflows,

00:28:47.320 --> 00:28:48.600
amazing use case for Temporal.

00:28:49.040 --> 00:28:49.960
Yeah, it sounds incredible.

00:28:50.560 --> 00:28:51.760
Now, I do want to dive actually,

00:28:51.960 --> 00:28:52.780
and it's super interesting

00:28:52.960 --> 00:28:55.000
how y'all made this happen in Python,

00:28:55.100 --> 00:28:57.240
but I do want to just maybe talk about,

00:28:59.260 --> 00:29:05.340
the scale, like if I were to run temporal, now you guys have a cloud. So I guess stepping just

00:29:05.460 --> 00:29:14.260
a bit back, this is MIT license, but you also have pricing. Yes. Before we go into what I was

00:29:14.260 --> 00:29:18.240
going to talk about, like, let's talk about that, that difference there, that contrast.

00:29:18.290 --> 00:29:19.080
Yeah. What's the story?

00:29:19.460 --> 00:29:23.000
So temporal is a hundred percent open source, MIT license. So there's

00:29:23.020 --> 00:29:28.360
the temporal service and then there's the temporal SDKs. Every single one of our temporal SDKs are,

00:29:29.040 --> 00:29:35.600
and the service and everything is MIT licensed forever and always. Our founders are big,

00:29:35.680 --> 00:29:41.420
big fans of that. The only SDK that is not is the Java SDK, which is Apache 2. And if you know

00:29:41.560 --> 00:29:46.220
anything about open source licensing, there is basically a dependency further up the tree that

00:29:46.220 --> 00:29:51.699
was Apache 2. And you're not allowed to downgrade licensing if you ever make a derivative. So that's

00:29:51.720 --> 00:29:56.440
the only reason that one is, but every one of our other licenses is MIT licensed. So you could run

00:29:56.620 --> 00:30:02.720
Temporal open source and be fine. The thing that we have found is that at scale, the service itself

00:30:03.140 --> 00:30:10.280
is challenging and requires large SRE teams to run. Because essentially what we're doing is we're

00:30:10.400 --> 00:30:15.320
offering distributed systems as a service. We're offering reliability as a service. Just because

00:30:15.410 --> 00:30:20.159
we have abstracted these problems away from someone does not mean that the price does not

00:30:20.140 --> 00:30:23.260
stuff to be paid by someone. And I'm talking about the metaphorical price, not the dollar price.

00:30:24.620 --> 00:30:29.860
Someone still has to ensure that that database stays up essentially, and that your things are

00:30:29.890 --> 00:30:35.660
still getting scheduled and that the network is up and all of these. So it's super complex to do

00:30:35.800 --> 00:30:40.060
that. And you can run it. So you can run the temporal service locally. You can run the temporal

00:30:40.220 --> 00:30:45.019
workers locally. Everything you run is still local. The pricing model for temporal is just the temporal

00:30:45.020 --> 00:30:50.580
service part, which is run in temporal cloud. So there's a, there's a weird misnomer around cloud,

00:30:51.100 --> 00:30:54.340
which is like cloud always assumes that we run everything for you. Temporal cloud is different.

00:30:54.880 --> 00:31:00.520
Temporal cloud only runs the temporal service, your workers, where your code executes is always

00:31:00.880 --> 00:31:05.360
run at least by for now until who knows if another product will ever come out. I don't know.

00:31:06.380 --> 00:31:11.220
Is run by you on you in your data center, on your machines. So your code, your execution run by you,

00:31:11.860 --> 00:31:16.040
that that service that brain the orchestrator that's the part you could pay temporal cloud for

00:31:16.740 --> 00:31:20.380
um right that's the part that does the orchestration the part that handles the

00:31:20.840 --> 00:31:24.240
failure and retries and that kind of stuff right yeah well

00:31:24.240 --> 00:31:25.940
ted it's the part that actually the

00:31:25.980 --> 00:31:29.420
failure retries is handled by the state machines that are built in the sdk it's the part that

00:31:29.560 --> 00:31:35.700
basically maintains the event history it maintains the communication mechanisms and it um it is the

00:31:35.740 --> 00:31:38.300
orchestrator yeah so uh but so if we use the

00:31:38.300 --> 00:31:41.279
cloud i could like reboot my my local data center machine

00:31:41.280 --> 00:31:43.580
or even my local data center,

00:31:43.700 --> 00:31:45.020
I mean my version of the cloud,

00:31:46.340 --> 00:31:48.540
you know, wherever DigitalOcean or whatever.

00:31:49.070 --> 00:31:49.780
And when it comes back,

00:31:50.280 --> 00:31:51.740
it'll sort of resume along.

00:31:52.700 --> 00:31:54.380
Like you guys will see that it's back

00:31:55.080 --> 00:31:57.040
and then start running work on something like that.

00:31:57.140 --> 00:31:58.200
That's what I was getting at.

00:31:58.760 --> 00:31:59.580
Technically, yes.

00:31:59.790 --> 00:32:01.600
So fun fact about it.

00:32:02.580 --> 00:32:04.880
Again, the architecture of this is so brilliant

00:32:04.950 --> 00:32:06.400
and we could get so touched in the weeds about it.

00:32:06.480 --> 00:32:08.420
The Temporal Service does not actually know

00:32:08.580 --> 00:32:09.900
about any of the workers that are running.

00:32:10.200 --> 00:32:11.540
It's always a call out model.

00:32:12.110 --> 00:32:14.400
So your machines would come back online,

00:32:15.120 --> 00:32:16.540
know that they have things they need to do.

00:32:16.630 --> 00:32:18.240
They would basically start listening back.

00:32:18.540 --> 00:32:19.700
Everything that happens at Temporal

00:32:19.790 --> 00:32:20.860
listens across task queues.

00:32:21.320 --> 00:32:22.460
So they would all come back online.

00:32:22.760 --> 00:32:23.760
They would start listening again.

00:32:24.310 --> 00:32:25.680
And then they would see that there's still work

00:32:25.800 --> 00:32:27.340
in the task queues, which the service maintains.

00:32:27.630 --> 00:32:28.960
But all the service does, it goes,

00:32:29.400 --> 00:32:31.360
oh, someone requested that I do something.

00:32:31.470 --> 00:32:32.640
And then it puts it on the task queue

00:32:32.650 --> 00:32:33.740
and then the workers handle it.

00:32:34.200 --> 00:32:37.460
The true magic of Temporal lies within the state machines

00:32:37.700 --> 00:32:39.160
that are built within the SDKs,

00:32:39.240 --> 00:32:41.540
but they cannot function without that orchestrator service.

00:32:42.340 --> 00:32:46.480
I remember when I first started working on the courses.

00:32:46.560 --> 00:32:50.620
So like my primary role is writing courses for Temporal.

00:32:50.620 --> 00:32:52.520
And if you go on to our Temporal Learn site,

00:32:52.620 --> 00:32:54.540
you can find a lot of our,

00:32:55.540 --> 00:32:56.940
I think it's learn.temporal.io.

00:32:57.440 --> 00:32:58.520
You can find a lot of our courses.

00:32:59.860 --> 00:33:01.200
I wrote the Java and the Python ones.

00:33:02.960 --> 00:33:04.420
I remember when I was first writing them,

00:33:04.440 --> 00:33:05.940
I kept asking the SDK engineers like,

00:33:05.940 --> 00:33:07.020
well, how does the server do this?

00:33:07.100 --> 00:33:07.760
How does the server do this?

00:33:07.760 --> 00:33:08.760
And one of the engineers was like,

00:33:08.840 --> 00:33:10.240
Mason, you're giving the server too much credit.

00:33:10.400 --> 00:33:11.060
It's not that smart.

00:33:12.500 --> 00:33:15.060
It's really the state machines within the workers

00:33:15.680 --> 00:33:16.760
that are doing all the heavy lifting

00:33:16.860 --> 00:33:18.060
and the service just maintains it.

00:33:18.220 --> 00:33:20.480
But with the long way around,

00:33:20.620 --> 00:33:22.520
what the cloud service does is it maintains that database.

00:33:23.000 --> 00:33:23.780
So the history.

00:33:24.260 --> 00:33:26.480
Without that event history, that is the magic piece.

00:33:27.300 --> 00:33:28.900
The event history is the single source of truth

00:33:28.980 --> 00:33:30.080
of all things that have happened

00:33:30.320 --> 00:33:32.220
and that's what the service provides and maintains.

00:33:32.620 --> 00:33:34.440
So whether you use the cloud version of that

00:33:34.580 --> 00:33:36.780
or you self-host that, that is up to you.

00:33:36.880 --> 00:33:37.860
Now, again, if you self-host it,

00:33:38.020 --> 00:33:39.480
You are now responsible for maintaining it.

00:33:39.840 --> 00:33:42.940
You are now responsible for upgrading it, security patches, all of that.

00:33:44.440 --> 00:33:45.880
And there are multiple case studies.

00:33:45.980 --> 00:33:50.420
There are multiple YouTube videos on our channel of people who have gone the self-hosted route

00:33:50.460 --> 00:33:54.560
and have found that the cloud route is easier once they've reached a certain scale.

00:33:55.900 --> 00:33:57.060
So, yeah, it's pretty neat.

00:33:57.640 --> 00:33:57.860
Yeah.

00:33:58.160 --> 00:33:58.540
Yeah, cool.

00:34:00.100 --> 00:34:05.660
You know, more and more, that's the business side of what works for open source, right?

00:34:06.340 --> 00:34:06.440
Yeah.

00:34:07.780 --> 00:34:19.000
There's something that you want to do. And then there's another requirement that you're probably not good at. And you guys would be really good at right like for example, making sure that temporal itself is reliable and

00:34:19.000 --> 00:34:21.179
fast and keeps

00:34:21.179 --> 00:34:23.220
running and that kind of thing right like exactly

00:34:23.220 --> 00:34:37.200
yes and I think it does also come down to and this is one of the interesting lessons that I've that I've learned throughout my career is that like, what is your core business is your core business to run and maintain a temporal service is your core business to provide a service to your customers.

00:34:37.879 --> 00:34:41.460
And whenever the price of running your own services outweighs what you could have just

00:34:41.620 --> 00:34:45.919
paid someone else to do it for, then at that point, you have to take a look at something

00:34:46.040 --> 00:34:50.300
and go, maybe I should just pay the provider who has the expertise, who literally all they

00:34:50.320 --> 00:34:50.860
do all day long.

00:34:51.520 --> 00:34:55.800
Because usually someone's SRE team doesn't full-time dedicate to learning the ins and

00:34:55.899 --> 00:34:56.700
outs of a single product.

00:34:57.100 --> 00:34:57.960
Like I was an SRE.

00:34:58.120 --> 00:35:02.620
I managed a cloud platform for VRBO, for Vrbo.

00:35:03.540 --> 00:35:06.020
I knew there was like 12 different applications in that stack.

00:35:06.160 --> 00:35:08.960
And the way that I learned about each one was the one that went down that day.

00:35:09.460 --> 00:35:13.020
So you're, you're constantly like figuring out what, like you're learning about it as

00:35:13.100 --> 00:35:13.580
it's on fire.

00:35:13.700 --> 00:35:14.540
It's a terrible way to learn.

00:35:15.220 --> 00:35:19.740
and that's, that's just not a great way to run it to, to like live your life.

00:35:20.220 --> 00:35:20.540
I found

00:35:20.540 --> 00:35:20.960
that's why I

00:35:20.960 --> 00:35:22.300
moved into developer education.

00:35:23.120 --> 00:35:23.900
exactly.

00:35:24.220 --> 00:35:27.220
There's, there's fewer, midnight calls in developer education.

00:35:28.440 --> 00:35:30.060
That is the

00:35:30.060 --> 00:35:34.760
primary reason why I do this now is I, I, I, like there is a point when the,

00:35:34.840 --> 00:35:39.000
when pager duty goes off like one too many times and you become a developer advocate and i'm living

00:35:39.180 --> 00:35:39.520
proof of that

00:35:39.520 --> 00:35:44.940
you just know yeah you take it off a space style you just take it out put on some uh

00:35:45.220 --> 00:35:45.640
gangster music

00:35:45.640 --> 00:35:51.980
just exactly right exactly if you don't know the reference you

00:35:51.980 --> 00:35:52.400
need to make

00:35:52.540 --> 00:35:54.940
sure you put watching office space yeah the

00:35:54.940 --> 00:35:57.820
movie right i've driven by the list i've driven by the

00:35:57.860 --> 00:36:00.580
area where it was filmed it was filmed out here in austin where i live was

00:36:00.580 --> 00:36:00.700
it

00:36:00.700 --> 00:36:01.379
incredible yes

00:36:02.340 --> 00:36:06.160
Incredible. Okay, so why did I sort of start in that path? What I want to talk about is what is,

00:36:06.680 --> 00:36:10.280
so you guys have a cloud version, which obviously does stuff in massive scale.

00:36:10.980 --> 00:36:13.380
You talk about a fleet of these things. And by the way,

00:36:13.540 --> 00:36:13.820
at the

00:36:13.820 --> 00:36:16.200
execution level, we're probably

00:36:16.660 --> 00:36:24.100
mostly talking Go and Rust, just so people know, it's kind of like fast innards. But Rakesh asks,

00:36:24.280 --> 00:36:28.539
like, it seems to be resourced and sensitive. Is there a lightweight option? Like, what is a

00:36:29.540 --> 00:36:31.840
what is a minimal temporal rather than a,

00:36:32.440 --> 00:36:32.600
you know,

00:36:33.520 --> 00:36:36.940
what Uber does or what, you know,

00:36:37.100 --> 00:36:40.840
ChatGPT does. Cause those things, you just can't compare them. Right. It's like, you're not

00:36:41.060 --> 00:36:45.560
Microsoft. You're not Google. You're not LinkedIn. You're not Netflix. Don't try to be them most.

00:36:46.920 --> 00:36:47.240
Yeah.

00:36:47.240 --> 00:36:50.340
It depends on what you're trying to accomplish. So, I mean, like, I think when it

00:36:50.360 --> 00:36:53.560
comes to, so there's, there's always, there's the service and then there's the worker fleet. So

00:36:53.660 --> 00:36:56.579
let's talk, I'll talk about the service first and then we'll talk about the workers. So the service

00:36:56.600 --> 00:37:03.660
comes in a handful of different flavored offerings. There's a local development binary that is meant

00:37:03.660 --> 00:37:09.520
to be used for development. And that's what I use on my local laptop all the time. It's also more

00:37:09.700 --> 00:37:12.820
than suitable for home lab stuff. So if you're wanting to play with this in your home lab,

00:37:13.660 --> 00:37:18.800
use that single binary. It's got an in-memory data store, but you can have it persist to a

00:37:19.000 --> 00:37:25.160
SQLite database. We'll get you very, very far on home lab stuff. Non-prod use cases, totally fine.

00:37:25.780 --> 00:37:27.840
SQLite is underappreciated.

00:37:28.540 --> 00:37:29.100
People see it

00:37:29.100 --> 00:37:33.120
as like a toy thing or like I can use this while I'm developing like a sample.

00:37:33.330 --> 00:37:36.960
But then I don't really like you can put millions of records in SQLite.

00:37:36.970 --> 00:37:38.360
You can go a very long way.

00:37:38.720 --> 00:37:39.040
Oh, yeah.

00:37:39.320 --> 00:37:40.060
Yeah, it is.

00:37:40.780 --> 00:37:42.020
Yeah, it is an amazing tool.

00:37:42.120 --> 00:37:42.980
It's one of my favorite tools.

00:37:44.200 --> 00:37:44.660
And then there.

00:37:44.800 --> 00:37:48.540
So in reality, what the way that the temporal service is actually built is it's actually just a single binary.

00:37:49.500 --> 00:37:52.500
But the thing is, there are the temporal service is a conglomerate.

00:37:52.600 --> 00:37:54.800
When I say the service, I'm like all of the things together.

00:37:55.240 --> 00:37:59.440
It's a conglomerate of multiple microservices that when you put them together, they connect

00:37:59.620 --> 00:38:00.540
with, they interact with each other.

00:38:00.630 --> 00:38:04.860
And there's like four backend services, no, three services and a frontend service.

00:38:05.370 --> 00:38:07.500
Then there's like a web UI and that's the service.

00:38:07.610 --> 00:38:10.960
But then you also have to build in a data storage.

00:38:11.380 --> 00:38:14.980
So for when you get to that point, that's when you either need MySQL, Postgres, or Cassandra.

00:38:15.230 --> 00:38:18.180
You could probably get away with SQLite on that one, but I've never actually tried it.

00:38:19.660 --> 00:38:22.440
But we recommend MySQL, Postgres, or Cassandra.

00:38:22.880 --> 00:38:26.580
And then you can add in other things like elastic for visibility.

00:38:26.640 --> 00:38:28.980
You can add Prometheus and Grafana for being able to see.

00:38:29.340 --> 00:38:30.380
But this is when you're starting to scale up.

00:38:30.420 --> 00:38:34.740
So like if you were doing this on, you know, like small itty bitty scale,

00:38:34.980 --> 00:38:38.860
you could probably deploy it onto say a DigitalOcean droplet and be fine with a single binary.

00:38:39.060 --> 00:38:41.440
We have tutorials on our learn site on exactly how to do this.

00:38:42.780 --> 00:38:43.420
And then it scales.

00:38:43.660 --> 00:38:45.300
So like there's a Docker compose file.

00:38:45.360 --> 00:38:49.380
So like once you want to see what all these microservices are doing, like in multiple areas,

00:38:49.780 --> 00:38:52.220
like you can see how we've deployed all of them and you can play it.

00:38:52.340 --> 00:38:56.620
There's multiple different Docker compose files to be like, oh, I want it with this database

00:38:56.860 --> 00:38:57.400
and these options.

00:38:57.560 --> 00:39:00.800
And that allows you to kind of like tune it and tweak it to your liking.

00:39:01.400 --> 00:39:05.940
And then once you get to prod scale, we have Helm charts that we support and you can deploy

00:39:05.940 --> 00:39:06.760
it directly into Kubernetes.

00:39:07.160 --> 00:39:11.360
Now, if you're self-hosting in production, Kubernetes tends to be what we see in the

00:39:11.620 --> 00:39:13.980
wild as the most popular deployment.

00:39:14.300 --> 00:39:15.740
Now, again, these are single binaries.

00:39:16.120 --> 00:39:17.300
You can deploy it however you want.

00:39:17.580 --> 00:39:20.040
So it has a from development to prod.

00:39:20.040 --> 00:39:21.800
It has a very nice scaling story.

00:39:22.940 --> 00:39:24.880
or the other option is just go to Temporal Cloud.

00:39:25.760 --> 00:39:29.900
The thing is Temporal Cloud has a minimum pricing structure for it,

00:39:29.980 --> 00:39:31.260
which we're constantly updating.

00:39:33.400 --> 00:39:37.120
And that's really useful once you get to actual production use cases

00:39:37.200 --> 00:39:38.340
and you have people paying you

00:39:38.340 --> 00:39:40.280
and you can use that money to pay for the Temporal Cloud.

00:39:40.580 --> 00:39:41.120
It's not a lot.

00:39:41.220 --> 00:39:42.940
The Temporal Cloud pricing is super...

00:39:44.880 --> 00:39:47.220
I think it's really super interestingly well done

00:39:47.560 --> 00:39:48.840
because it's based on what we call actions.

00:39:49.400 --> 00:39:55.140
So like anything that basically causes a right to that durable database, you get billed on like fractions of a penny.

00:39:55.460 --> 00:39:56.340
So it's consumption based.

00:39:58.080 --> 00:40:00.420
The main thing is making sure you have enough traffic to cover.

00:40:00.780 --> 00:40:05.680
Basically, there's a minimum support cost that you have to pay for like a minimum bill requirement.

00:40:05.840 --> 00:40:10.200
And then you get billed on the actions and making sure you have enough traffic and workload to handle that.

00:40:11.140 --> 00:40:11.540
I know.

00:40:11.640 --> 00:40:14.260
And then you get a lot of other cool features in cloud that.

00:40:16.220 --> 00:40:22.140
that, I have to make sure I say this carefully, that you don't get on the open source version,

00:40:22.230 --> 00:40:27.660
but those are all deployment options. So when it comes to feature to feature option, as right now,

00:40:28.260 --> 00:40:32.860
it's a one-to-one comparison. What runs in open source is what is deployed in cloud.

00:40:33.150 --> 00:40:38.680
Like if I build all of my stuff on the open source stuff, I deployed to cloud on occasion to test it,

00:40:38.930 --> 00:40:42.360
but I'm constantly building on the open source version and all of my stuff runs in cloud.

00:40:42.740 --> 00:40:45.560
What you get when you go to cloud is you get those production features.

00:40:45.990 --> 00:40:51.340
You get single sign on, you get role-based access control, you get more advanced metrics

00:40:51.820 --> 00:40:52.700
and things of that nature.

00:40:52.730 --> 00:40:56.440
You get all of these like things that really matter at a large scale production, things

00:40:56.540 --> 00:40:57.960
that large enterprises care about.

00:40:58.940 --> 00:40:59.020
Yeah.

00:40:59.640 --> 00:41:03.320
And there are ways you can get those in the open source as well.

00:41:03.870 --> 00:41:07.120
But they're like, they come like first as first class citizens in the cloud problem.

00:41:07.580 --> 00:41:12.460
Maybe you got to write your own, run your own single sign on identity server or something

00:41:13.000 --> 00:41:13.320
Yeah.

00:41:14.160 --> 00:41:27.480
Yeah. So over here, if I go to the temporal GitHub repo, there's Docker, which has got a Docker

00:41:27.600 --> 00:41:29.820
compose, I think something.

00:41:30.820 --> 00:41:30.920
Yeah.

00:41:33.320 --> 00:41:33.640
Yeah.

00:41:34.360 --> 00:41:35.700
Is there? Okay. So I could even,

00:41:35.800 --> 00:41:36.360
I think it would be like

00:41:36.480 --> 00:41:40.020
temporal and then doc, like I was in the search, I would just search or in the org, I would search

00:41:40.040 --> 00:41:40.900
for Docker Compose.

00:41:41.480 --> 00:41:41.840
Yeah.

00:41:42.280 --> 00:41:43.340
It might be there somewhere.

00:41:46.400 --> 00:41:46.960
There we go.

00:41:47.140 --> 00:41:47.360
Are you ready?

00:41:47.400 --> 00:41:47.460
Yeah.

00:41:47.880 --> 00:41:49.280
I'll put that in the links as well.

00:41:50.100 --> 00:41:51.420
I'm a huge fan of Docker Compose.

00:41:51.430 --> 00:41:53.700
I think it opens up a bunch of great options.

00:41:54.100 --> 00:41:58.900
And if you go in here, you can see that there's like the Docker Compose MySQL to Docker Compose

00:41:59.359 --> 00:41:59.720
Postgres,

00:42:00.080 --> 00:42:00.420
and

00:42:00.420 --> 00:42:02.540
then just a bare bones one.

00:42:03.510 --> 00:42:03.620
Right.

00:42:03.920 --> 00:42:08.040
So if you wanted to self-host it, is this a pretty good way to go?

00:42:08.800 --> 00:42:09.880
Yeah, I think it's a great place to start.

00:42:09.960 --> 00:42:11.160
I think it always depends on your scale.

00:42:12.160 --> 00:42:14.240
Like if you are good at Docker Compose

00:42:14.420 --> 00:42:18.000
and you think like the thing with Docker Compose

00:42:18.000 --> 00:42:19.760
is like, and I believe this is all gonna deploy it

00:42:19.800 --> 00:42:21.740
on a single service or a single server.

00:42:22.300 --> 00:42:23.840
So like we always talk about like,

00:42:24.540 --> 00:42:26.860
depends on the level of reliability you need of the service

00:42:27.080 --> 00:42:29.260
because if the database of the service goes away,

00:42:29.360 --> 00:42:30.560
then your reliability goes away.

00:42:31.760 --> 00:42:33.780
Like, that's kind of like the truth here

00:42:33.800 --> 00:42:35.800
is with that database being the single source of truth,

00:42:36.280 --> 00:42:37.880
if that database magically disappears,

00:42:39.200 --> 00:42:39.540
you don't

00:42:39.540 --> 00:42:39.780
have it.

00:42:39.860 --> 00:42:44.320
Now you could do like an RDS or like a digital ocean managed database and connect

00:42:44.320 --> 00:42:44.760
that in

00:42:44.830 --> 00:42:45.080
to this.

00:42:45.700 --> 00:42:49.340
Yeah, run just basically set a off server database connection

00:42:49.340 --> 00:42:49.520
string.

00:42:49.580 --> 00:42:50.360
Yeah, exactly.

00:42:50.560 --> 00:42:51.640
Right, of any form.

00:42:52.920 --> 00:42:55.740
Then it's matching the reliability of that database, yeah.

00:42:55.980 --> 00:42:56.580
Exactly, yeah.

00:42:57.260 --> 00:42:57.440
Yeah.

00:42:58.720 --> 00:43:03.680
So another thing, whenever I hear durable, and actually I see a bit about this in the

00:43:03.840 --> 00:43:04.580
show notes as well.

00:43:06.560 --> 00:43:08.840
And you say retry, like if something goes wrong, we should retry it.

00:43:08.900 --> 00:43:09.480
And it probably resume.

00:43:09.680 --> 00:43:10.680
Like sometimes it won't.

00:43:10.820 --> 00:43:10.960
Sometimes

00:43:10.960 --> 00:43:11.600
there's a

00:43:11.600 --> 00:43:13.540
poison, what's called a poison message.

00:43:13.690 --> 00:43:16.700
Like it's cursed to always fail for

00:43:16.700 --> 00:43:17.420
whatever reason.

00:43:17.620 --> 00:43:19.460
Like it's trying to get to a service.

00:43:19.590 --> 00:43:22.260
The domain is gone or it's not coming back.

00:43:22.450 --> 00:43:22.580
Right.

00:43:23.120 --> 00:43:23.240
Yep.

00:43:23.340 --> 00:43:24.300
One of those sorts of things.

00:43:25.620 --> 00:43:26.800
Three months ago, it was there.

00:43:27.010 --> 00:43:30.800
Then you said sleep for three months and it woke up and said, wait, it's like

00:43:31.010 --> 00:43:31.640
planet of the apes.

00:43:31.640 --> 00:43:33.800
You're like, yeah, what have they done?

00:43:33.910 --> 00:43:34.380
You wake up.

00:43:34.480 --> 00:43:35.720
You're like, the world is not what I thought.

00:43:35.810 --> 00:43:35.900
Right.

00:43:38.280 --> 00:43:39.480
How do you deal with that kind of stuff?

00:43:40.400 --> 00:43:42.040
Yeah, so in the retry policy,

00:43:42.860 --> 00:43:43.960
so the default retry policy,

00:43:45.970 --> 00:43:49.780
its default is just retry on a specific time limit

00:43:50.100 --> 00:43:52.120
forever until it's either canceled or it succeeds.

00:43:52.580 --> 00:43:54.820
Now, if you expect that something could happen like that,

00:43:56.640 --> 00:43:58.440
essentially what you would do is there's something

00:43:58.600 --> 00:43:59.980
what's under non-retriable error types.

00:44:00.550 --> 00:44:02.620
So certain HTTP error codes,

00:44:03.800 --> 00:44:04.960
you might would be like,

00:44:05.060 --> 00:44:07.340
hey, this is just not gonna come back.

00:44:07.980 --> 00:44:12.240
500 is fine but maybe 404 is like 404 might never come back but

00:44:12.240 --> 00:44:13.340
500 very

00:44:13.340 --> 00:44:14.060
likely could

00:44:14.060 --> 00:44:14.780
or

00:44:15.180 --> 00:44:17.900
cannot connect i don't know is that 404 i don't think so i think

00:44:17.900 --> 00:44:20.420
i don't remember yeah i remember

00:44:20.430 --> 00:44:20.580
but

00:44:20.580 --> 00:44:23.680
there's probably a code that like i i can't connect to the server versus

00:44:23.680 --> 00:44:24.540
like i got

00:44:24.540 --> 00:44:24.900
there and

00:44:24.900 --> 00:44:26.460
it said not here yeah

00:44:26.460 --> 00:44:29.280
so there's non-retriable error codes and i mean like what we do with the

00:44:29.440 --> 00:44:33.760
the courts and pearl primitives is more of like um i often tell people it's like yeah like things

00:44:33.780 --> 00:44:39.040
that can retry, let them retry. But like, say I do a divide by zero error. No amount of retries is

00:44:39.090 --> 00:44:43.600
going to change the laws of physics. You know, it's like holding your breath until something

00:44:43.780 --> 00:44:47.320
changes. You're just going to pass out. Same thing with these retries. So you have to have what are

00:44:47.400 --> 00:44:50.540
called non-retriable errors. And you essentially say, hey, whenever you experience this error,

00:44:50.880 --> 00:44:54.340
you should just fail. And basically you would bubble it up and then you have to let the next

00:44:54.520 --> 00:44:57.560
layer of execution handle it. So yeah, totally a good story for that.

00:44:58.280 --> 00:44:59.900
Okay. Yeah. But you kind of

00:44:59.860 --> 00:45:01.420
got to think a little bit about it, right? Just,

00:45:01.660 --> 00:45:04.120
yes. Yes. You still have to think it doesn't take

00:45:04.130 --> 00:45:09.900
away all the thinking for when it comes to like what potentially could go wrong, but at least like

00:45:09.910 --> 00:45:13.860
with all of like the weird, like, you know, okay, this service might go down DNS, someone messed

00:45:13.860 --> 00:45:15.680
with DNS. It's always DNS. I had,

00:45:15.720 --> 00:45:16.460
I had an, it's always

00:45:16.460 --> 00:45:18.360
DNS moment the other day. And I'm like,

00:45:18.980 --> 00:45:21.780
I need a sticker for my laptop that says this because it got me again.

00:45:22.520 --> 00:45:27.119
I can't remember what took me. I, I suffered something with that as well. And it wasn't even

00:45:27.120 --> 00:45:33.580
directly me, but it was something that I was subjected to. Yeah. It is always DNS.

00:45:33.900 --> 00:45:34.540
It's always

00:45:34.760 --> 00:45:34.860
DNS.

00:45:35.360 --> 00:45:40.980
Except for when it's the database. Yeah. Or except for when you accidentally deploy the

00:45:41.220 --> 00:45:46.800
Walrus operator on Python 3.7 on the server. That also is not good. And it's not, which I took down

00:45:46.800 --> 00:45:51.840
and talked Python for 20 minutes. I'm like, what, why won't it run? It was running perfect. Oh,

00:45:52.160 --> 00:45:53.500
this was like, you know, years ago when that,

00:45:53.600 --> 00:45:54.140
those things were

00:45:54.140 --> 00:45:54.840
like new, right?

00:45:55.080 --> 00:45:56.260
Yeah. Oh my

00:45:56.280 --> 00:45:56.460
goodness.

00:45:58.100 --> 00:46:02.320
So one thing I want to talk about here, let me get back to the right spot.

00:46:03.380 --> 00:46:06.820
Let's talk about the programming execution model.

00:46:07.460 --> 00:46:09.520
Let's see, is there a quick start?

00:46:09.720 --> 00:46:11.760
Let's maybe let's talk to the quick start.

00:46:11.880 --> 00:46:18.180
And I think there's just some super interesting modern Python ideas that

00:46:18.180 --> 00:46:18.640
you got here.

00:46:19.000 --> 00:46:19.120
Right?

00:46:19.300 --> 00:46:23.900
So maybe talk us through, like, how do we, how do we get started bringing

00:46:23.930 --> 00:46:24.240
this in?

00:46:24.300 --> 00:46:33.700
And does it have to be a from scratch or can I take some part of my application, like a particular API endpoint and go, this thing needs some help.

00:46:34.260 --> 00:46:35.080
Temporal can help it.

00:46:35.620 --> 00:46:37.120
Let's just plug it in on this one bit.

00:46:37.500 --> 00:46:44.780
That's actually how we recommend a lot of people get started with Temporal is like we don't we never tell people like do like a whole ground up rewrite of like everything you have.

00:46:44.840 --> 00:46:53.340
we i've often told people find something that um like find find a service that annoys you that

00:46:53.480 --> 00:46:58.180
pages you because it's constantly going down because it's unreliable and maybe do a like it's

00:46:58.180 --> 00:47:03.000
a small service and do a small rewrite of that in temporal and just see how your life makes uh

00:47:03.820 --> 00:47:06.840
makes a difference so the way that you do it with temporal is like you have to use the temporal

00:47:07.080 --> 00:47:10.980
sdks so the way that you build temporal applications is you build them using sdks

00:47:11.600 --> 00:47:16.820
um typically with other workflow-esque engines or other durable execution engines um some of the

00:47:16.820 --> 00:47:20.380
more modern durable execution engines have kind of followed suit with us but some of the earlier

00:47:20.560 --> 00:47:26.600
ones didn't we're code-based um we're not dag based we're not yaml based we don't have our own

00:47:26.860 --> 00:47:30.620
structured dsl we are 100 code-based and there's a lot of advantages to that

00:47:30.620 --> 00:47:32.380
and not xml based

00:47:32.380 --> 00:47:33.200
no

00:47:33.220 --> 00:47:33.620
No,

00:47:33.800 --> 00:47:35.140
no

00:47:35.140 --> 00:47:42.960
XML. So yeah, so we build, you build basically what's called a workflow. Workflow is,

00:47:43.000 --> 00:47:47.120
you can kind of think of a workflow as like your application. It's the blueprint of your entire

00:47:47.320 --> 00:47:51.920
application. And what we'd say about workflows is that they have to be deterministic. Like the code

00:47:51.960 --> 00:47:56.880
within a workflow must be deterministic and you execute it line by line going down. And then

00:47:57.280 --> 00:48:01.960
anything within your workflow that potentially could be non-deterministic or could potentially

00:48:01.980 --> 00:48:07.580
fail. So calling out to a microservice is both of those. It's non-deterministic because you don't

00:48:07.580 --> 00:48:10.840
know what you're going to get back. And it's potentially going to fail because the service

00:48:10.900 --> 00:48:14.360
could be down. That goes in what's called an activity. An activity is that thing that

00:48:14.640 --> 00:48:20.400
automatically gets the retries. Now you implement activities as functions or as methods in Python.

00:48:20.740 --> 00:48:28.260
You can actually do them as both. And as you were saying in the readme, yeah, we use a lot of modern

00:48:28.280 --> 00:48:32.760
Python tooling. So that's actually something that I think that our SDK engineers, we have an entire

00:48:32.980 --> 00:48:37.720
team whose entire job is to build and maintain our SDKs. They're super proud of. It's one of the

00:48:37.740 --> 00:48:44.020
things I love talking about. Temporal is not built off of what you would say like an open API spec

00:48:45.200 --> 00:48:49.940
for a good reason. So it's built basically, I mean, Temporal itself is built in Go. So as you

00:48:50.000 --> 00:48:54.660
can imagine, everything's built in protobuffs. There is a spec on what we build off of, but

00:48:54.520 --> 00:49:00.100
open API specs generate stuck stub client libraries. And I've worked with a handful of them.

00:49:00.200 --> 00:49:03.520
They don't, they're not very idiomatic to the language. Like it kind of looks like someone

00:49:03.740 --> 00:49:09.440
bolted a C library on top of Python. Like it works, but it doesn't feel like Python. Our SDK

00:49:09.740 --> 00:49:15.260
engineers spend months studying the programming language, learning out what is idiomatic of the

00:49:15.360 --> 00:49:20.520
language, what actually makes sense. And then they build into it. So the interesting thing about this

00:49:20.540 --> 00:49:25.420
You can see here when we define our workflows, we define them by decorating classes.

00:49:25.660 --> 00:49:29.240
And then we decorate the entry point by decorating it with an at workflow.run.

00:49:29.260 --> 00:49:30.800
So that's how we know where the entry point is.

00:49:32.440 --> 00:49:35.640
We're using async.io inside of this to do it.

00:49:35.960 --> 00:49:38.700
Our activities, when you want to turn a method into an activity,

00:49:39.240 --> 00:49:42.760
you are a function in an activity, you just decorate it at activity.defin.

00:49:43.040 --> 00:49:46.000
And now you have an activity.

00:49:47.480 --> 00:49:48.640
We've done a lot of those kind of things.

00:49:48.720 --> 00:49:55.620
we're using context managers very, very a lot or, you know, rigorously within the code base.

00:49:56.940 --> 00:50:00.680
The really interesting thing is, and I can only talk a teensy bit about this because it's super

00:50:01.020 --> 00:50:05.480
complex, but there's a really great talk track from it at the PyTexas conference from this year.

00:50:06.180 --> 00:50:10.920
We built a custom async event loop for this. This runs in a durable asynchronous event loop.

00:50:11.760 --> 00:50:16.020
And the SDK engineer who built it gave a talk at PyTexas this year, and it's on the PyTexas

00:50:16.040 --> 00:50:22.600
2025 website and I can provide a link to that later. and it's really neat because essentially

00:50:23.380 --> 00:50:28.300
we had to build a custom event loop to handle all of the way, the way that we expect temporal to

00:50:28.500 --> 00:50:32.360
work. and I don't think that building a custom event loop is a very common thing for people to

00:50:33.030 --> 00:50:33.500
do. Um,

00:50:33.660 --> 00:50:34.120
so there's a lot

00:50:34.120 --> 00:50:35.460
of lessons learned there. Um,

00:50:35.560 --> 00:50:36.880
I think there should be more of it though.

00:50:36.890 --> 00:50:40.180
I think that's a really interesting story. yeah,

00:50:40.240 --> 00:50:40.540
I'll put

00:50:40.540 --> 00:50:41.400
this in the show notes.

00:50:42.160 --> 00:50:43.480
Yeah, that's Chad's talk.

00:50:43.640 --> 00:50:44.220
It's amazing.

00:50:44.290 --> 00:50:46.220
So like he talks about all the things that he had to do

00:50:46.340 --> 00:50:49.140
when he was building out a custom event loop

00:50:49.450 --> 00:50:52.820
for asyncio or for Temporal's asyncio event loop.

00:50:53.430 --> 00:50:53.920
Yeah, so for

00:50:53.920 --> 00:50:57.020
people for whom this is super new, this idea,

00:50:58.220 --> 00:51:00.500
you need places in your code to execute to say,

00:51:00.590 --> 00:51:02.800
okay, we can stop, maybe save some state.

00:51:03.130 --> 00:51:05.000
And then you talked about like replaying

00:51:05.000 --> 00:51:05.880
behaviors

00:51:05.880 --> 00:51:06.540
and so on.

00:51:06.590 --> 00:51:09.800
So you can write code like await sleep a day,

00:51:10.700 --> 00:51:11.100
async

00:51:11.100 --> 00:51:17.820
io dot sleep one day and that goes into this as you said durable async io execution

00:51:18.940 --> 00:51:24.020
so instead of just saying well we're gonna let the thread do other stuff it's like no save it

00:51:24.370 --> 00:51:25.300
and then resume it

00:51:25.300 --> 00:51:26.460
right that's

00:51:26.460 --> 00:51:27.720
pretty wild it's

00:51:27.720 --> 00:51:29.680
pretty great actually yeah and i mean those those

00:51:29.880 --> 00:51:33.420
those and that's one of the great things about the workflows and like that those you'd have to

00:51:33.480 --> 00:51:39.400
definitely write as workflows but yeah and it takes up no no energy or it doesn't jam up a cpu thread

00:51:39.420 --> 00:51:42.260
by sleeping. Like it's usually if you sleep something, that thread is kind of sitting there

00:51:42.260 --> 00:51:43.360
and it's stuck. Um,

00:51:43.580 --> 00:51:44.260
this a

00:51:44.260 --> 00:51:47.460
hundred percent because it's all event sourced under the hood, essentially.

00:51:47.980 --> 00:51:53.320
the event, basically the timer started event gets recorded into the service and then it gets

00:51:53.460 --> 00:51:57.040
descheduled. And then that worker, that, that executor can continue performing other tasks.

00:51:57.170 --> 00:52:02.080
And then once that timer fires, the next task for it to continue execution gets put on the task queue.

00:52:02.390 --> 00:52:08.240
The worker consumes it knows, Oh, I need to resume and it resumes. And that can happen whenever that

00:52:08.260 --> 00:52:11.280
can happen you know a day from now three days from now three months from now it doesn't matter

00:52:11.460 --> 00:52:13.660
eventually gets put on the queue and it gets executed as if nothing happened

00:52:13.660 --> 00:52:15.100
yeah that's wild

00:52:17.080 --> 00:52:22.440
so interesting question out the audience of if people went with your cloud option

00:52:22.440 --> 00:52:23.140
where

00:52:23.140 --> 00:52:23.380
does

00:52:23.380 --> 00:52:25.900
that run is that aws is that digital ocean

00:52:25.900 --> 00:52:31.820
currently it's in uh aws and gcp okay so those are the two

00:52:31.820 --> 00:52:32.440
you can pick different

00:52:32.440 --> 00:52:34.260
availability zones like if i

00:52:34.260 --> 00:52:34.620
were in

00:52:34.620 --> 00:52:35.140
virginia

00:52:35.140 --> 00:52:36.300
us east

00:52:36.300 --> 00:52:37.200
one or whatever i could

00:52:37.180 --> 00:52:38.460
say I want to use that one.

00:52:39.060 --> 00:52:39.160
Exactly.

00:52:39.480 --> 00:52:40.480
There's different availability zones

00:52:40.500 --> 00:52:42.020
and we even have multi-region failover.

00:52:42.920 --> 00:52:44.540
So if you needed multi-region availability

00:52:44.840 --> 00:52:46.040
for super, super high availability,

00:52:47.100 --> 00:52:49.020
which we do have definitely have large customers

00:52:49.100 --> 00:52:50.360
who need that level of availability.

00:52:51.220 --> 00:52:52.680
And you can totally do that.

00:52:53.960 --> 00:52:54.120
Cool.

00:52:54.740 --> 00:52:56.160
And that doesn't mean you got to be in AWS.

00:52:56.840 --> 00:52:57.300
No, no.

00:52:57.340 --> 00:52:59.660
We have people who are running on their own private,

00:52:59.800 --> 00:53:01.100
they were running on their own infrastructure

00:53:01.320 --> 00:53:03.500
on their on-prem and they're calling into it.

00:53:03.520 --> 00:53:07.140
So that's the niftiest thing about Temporal Cloud

00:53:07.160 --> 00:53:12.780
The security model is super simple because temporal cloud or the temporal service, it doesn't have to be temporal cloud.

00:53:12.880 --> 00:53:15.460
It's the service, whether you self-host it or whether it's on the cloud.

00:53:16.000 --> 00:53:17.440
It never connects to you.

00:53:17.810 --> 00:53:21.100
The workers always do an outbound connection into the temporal service.

00:53:21.780 --> 00:53:27.560
So if you're using temporal cloud, the only firewall rule you have to allow is a single outbound connection off of a single port.

00:53:28.460 --> 00:53:28.680
That's it.

00:53:29.700 --> 00:53:29.940
So it's

00:53:29.940 --> 00:53:30.360
really awesome.

00:53:33.140 --> 00:53:34.900
Yeah, I'm impressed with a lot of this.

00:53:35.140 --> 00:53:37.240
So let's sort of, we're kind of getting to the end.

00:53:37.240 --> 00:53:38.800
I want to maybe close out with two topics,

00:53:40.100 --> 00:53:41.820
testing and what's next,

00:53:42.160 --> 00:53:45.620
or like sort of also maybe multi-language stuff

00:53:45.700 --> 00:53:46.680
we should touch on as well.

00:53:46.780 --> 00:53:48.660
But let's talk testing first.

00:53:49.520 --> 00:53:52.120
So there's a couple of interesting challenges here.

00:53:52.360 --> 00:53:54.880
Like first, if I write code like this

00:53:54.880 --> 00:53:56.020
and I want to have a unit test,

00:53:56.840 --> 00:53:59.040
no longer am I like, well, this is complicated.

00:53:59.100 --> 00:54:00.720
I just have to use pytest asyncio.

00:54:00.940 --> 00:54:02.260
It's like more than that, right?

00:54:02.960 --> 00:54:04.300
So what's the testing story?

00:54:05.060 --> 00:54:09.720
Yeah. So the cool thing about the testing story with this is, is it is technically still pytest

00:54:09.900 --> 00:54:14.400
Async IO. Because we're code-based, this is one of the things that I always have to harp

00:54:14.980 --> 00:54:19.840
to remind people on my courses and everyone's always like, oh, that's so cool. Because we're

00:54:19.980 --> 00:54:24.040
code, you have to give up none of your tooling. You don't have to get like, how do you like to

00:54:24.220 --> 00:54:28.380
package it? Are you a poetry person? Are you a B person? Are you a Pippin person? Whatever you

00:54:28.460 --> 00:54:33.660
want to use, use it. For your testing, do you want to use Poe the Poet? Are you a pytest person?

00:54:33.860 --> 00:54:37.560
like, what are you using? Use it. It doesn't matter. Temporal does provide, obviously,

00:54:37.720 --> 00:54:41.300
because these are more complex workflows and stuff, they require a little bit. Every single

00:54:41.920 --> 00:54:49.260
temporal SDK does provide a testing framework that is built into it. And these integrate natively

00:54:49.290 --> 00:54:53.820
with all of your testing frameworks. So you can use, you use pytest. I use pytest. Now you could

00:54:53.850 --> 00:54:59.540
use something else, but I, all of our courses, I think the Temporal 102 course. Yeah. I wrote that

00:54:59.560 --> 00:55:04.580
one has a whole chapter on testing temporal workflows and activities and mocking activities

00:55:04.800 --> 00:55:07.600
because you have to be able to call them independently because you otherwise that's an

00:55:07.700 --> 00:55:08.900
integration test it's not a unit test

00:55:08.900 --> 00:55:11.260
it is important i always feel bad about mocking the

00:55:11.380 --> 00:55:13.460
code it doesn't seem nice but you got to yeah it's

00:55:13.460 --> 00:55:16.800
super easy it's so nice uh the you you basically

00:55:17.040 --> 00:55:20.820
just re you basically redefine the activity and you're like just put it in then the mocking story

00:55:20.840 --> 00:55:26.240
in python is so nice um but you you just use our testing framework and what that does is it basically

00:55:26.260 --> 00:55:30.120
the testing framework will automatically spin up a temporal service and a worker for you. So,

00:55:30.260 --> 00:55:33.780
because as you can imagine, like the execution part of this is like, you have to have a service

00:55:33.940 --> 00:55:37.540
running, you have to have a worker, and then you have to send, like basically use a client to send

00:55:37.540 --> 00:55:42.460
a request to execute the workflow and it will be executed. The temporal testing service does all of

00:55:42.460 --> 00:55:47.360
that for you. And it also has basically time skipping. So what you can do is, you know,

00:55:47.550 --> 00:55:50.760
if I have to test, if I have to test something that sleeps for 30 days, I would actually prefer

00:55:50.940 --> 00:55:53.620
it to not actually sleep for 30 days. So I can test it.

00:55:53.900 --> 00:55:55.260
Well, I see. I take so long.

00:55:55.650 --> 00:55:55.780
Yeah.

00:55:56.160 --> 00:55:57.660
So time skipping is in there.

00:55:57.680 --> 00:55:59.360
And there's a lot of other really neat features in the testing.

00:55:59.540 --> 00:56:02.220
So every single temporal Python, or sorry,

00:56:02.280 --> 00:56:06.300
every single temporal SDK has a testing framework built into it

00:56:06.440 --> 00:56:09.580
that really well enables testing.

00:56:09.800 --> 00:56:13.120
And it all works natively with the tools that you are already used to using

00:56:13.240 --> 00:56:15.060
as a developer of whatever language you're already using.

00:56:15.680 --> 00:56:16.760
Yeah, that sounds great.

00:56:16.820 --> 00:56:22.140
And you can say things like, run this and wait for a week.

00:56:22.700 --> 00:56:23.260
And then resume.

00:56:23.300 --> 00:56:25.040
And you can just say, and now a week is for Zoom.

00:56:25.220 --> 00:56:26.220
A week has passed.

00:56:26.770 --> 00:56:27.160
Now I see

00:56:27.160 --> 00:56:27.740
what's happened, right?

00:56:27.860 --> 00:56:29.020
Like it'll just zip

00:56:29.020 --> 00:56:29.420
right ahead.

00:56:29.840 --> 00:56:32.020
Yep, skips right ahead, doesn't even worry about it.

00:56:32.180 --> 00:56:33.960
That's always a fun testing trick.

00:56:35.000 --> 00:56:41.440
So the other one I want to talk about is when I'm over here on the GitHub repo,

00:56:41.690 --> 00:56:42.460
I can scroll down.

00:56:42.550 --> 00:56:50.120
If I look at the repositories, it's Java SDK, Python SDK, Go SDK,.NET SDK, Ruby SDK, etc., etc.

00:56:51.840 --> 00:56:53.840
There's a bunch of interesting things here.

00:56:54.000 --> 00:56:56.300
Like I can write part of my app in Java,

00:56:56.860 --> 00:56:57.140
part of

00:56:57.140 --> 00:56:57.860
the workflow in

00:56:57.860 --> 00:56:58.180
Java

00:56:58.380 --> 00:57:02.100
or the workflow items in Java, the queues.

00:57:02.600 --> 00:57:05.000
And I can do part of it in Python or.NET.

00:57:05.180 --> 00:57:06.280
And the other part I think is interesting

00:57:06.500 --> 00:57:08.640
is Python,.NET, Ruby, et cetera,

00:57:09.180 --> 00:57:11.360
all share a common Rust base.

00:57:11.470 --> 00:57:13.580
And so it's kind of like they all go in lockstep.

00:57:14.880 --> 00:57:18.300
Yeah, so yeah, two great topics there.

00:57:18.350 --> 00:57:19.800
So the first one I'll start off with

00:57:19.940 --> 00:57:21.040
is the polyglot stuff

00:57:21.090 --> 00:57:22.619
because I think it's one of my favorite things

00:57:22.640 --> 00:57:25.040
and I don't ever get to talk about it enough,

00:57:25.200 --> 00:57:25.920
so I'm glad you asked.

00:57:27.320 --> 00:57:28.100
Underneath the hood,

00:57:28.200 --> 00:57:30.040
the way that all of this communication happens

00:57:30.220 --> 00:57:32.760
is it's happening via essentially protobuffs

00:57:32.900 --> 00:57:35.840
across task cubes to the temporal service back and forth.

00:57:36.480 --> 00:57:37.620
One of the things that you'll find

00:57:37.680 --> 00:57:38.540
if you dig into temporal

00:57:38.640 --> 00:57:40.640
is that we require the inputs and outputs

00:57:41.100 --> 00:57:44.320
of your functions to be serializable

00:57:44.840 --> 00:57:45.960
to basically protobuffs.

00:57:46.140 --> 00:57:48.540
Now, if you have something that's not serializable,

00:57:48.840 --> 00:57:50.300
we obviously, because it's code,

00:57:50.420 --> 00:57:54.460
we provide you the way to extend the serializer.

00:57:54.940 --> 00:57:57.500
So as long as you can serialize it, again, it's code.

00:57:57.500 --> 00:57:58.520
You can do whatever you want with it.

00:58:00.240 --> 00:58:02.820
But because of that, because everything speaks protobuf,

00:58:03.900 --> 00:58:05.800
all of these languages can natively speak to each other.

00:58:05.960 --> 00:58:06.660
So you're right.

00:58:06.680 --> 00:58:09.200
I can write workflows written in Python

00:58:09.760 --> 00:58:11.840
and call and have three different activities

00:58:12.040 --> 00:58:13.520
in that workflow, one written in TypeScript,

00:58:13.760 --> 00:58:15.540
one written in Java, and one written in.NET.

00:58:15.860 --> 00:58:17.000
And I can call them seamlessly,

00:58:17.380 --> 00:58:19.580
like basically just by calling execute activity,

00:58:19.760 --> 00:58:20.920
giving it the name of the function.

00:58:21.290 --> 00:58:23.820
And then I could actually still then pass in a data class

00:58:24.020 --> 00:58:26.160
of the data that I have as that parameter

00:58:26.290 --> 00:58:27.820
because it's still getting serialized down

00:58:27.910 --> 00:58:28.620
into a protobuf.

00:58:28.830 --> 00:58:30.840
It will get deserialized into the other language,

00:58:31.280 --> 00:58:33.820
execute it and pass back data that I can resume.

00:58:34.130 --> 00:58:35.520
And then I could call it technically

00:58:36.000 --> 00:58:37.200
from a client that's written in Go.

00:58:37.660 --> 00:58:42.500
So this enables polyglot across all of these languages.

00:58:42.870 --> 00:58:43.560
And it's amazing.

00:58:43.630 --> 00:58:44.680
So if you have legacy systems

00:58:44.800 --> 00:58:46.280
or you have stuff where like you really need something

00:58:46.290 --> 00:58:49.460
to be written in a whole bunch of different languages,

00:58:49.520 --> 00:58:52.000
it just gives you this out of the box for free.

00:58:52.960 --> 00:58:54.700
And I think it's one of the neatest features.

00:58:54.810 --> 00:58:56.000
And one of the other part

00:58:56.100 --> 00:58:57.660
that it really does need about this

00:58:57.880 --> 00:59:01.560
is it's not just like the fact that it can call it,

00:59:01.610 --> 00:59:03.900
but it also preserves the stack traces as well.

00:59:04.340 --> 00:59:06.380
So one of the other courses that I developed

00:59:06.500 --> 00:59:08.020
are crafting the error handling strategy course.

00:59:09.200 --> 00:59:11.100
There's a demo in there

00:59:11.700 --> 00:59:13.980
where I am showing like basically that exact workflow,

00:59:14.220 --> 00:59:17.160
a Go client that's calling a Java workflow

00:59:17.280 --> 00:59:18.580
that's calling a Python activity.

00:59:18.980 --> 00:59:19.760
So three different languages.

00:59:19.850 --> 00:59:22.860
And then I intentionally throw an error in the Python activity.

00:59:23.140 --> 00:59:25.440
And I tell it, do not handle it.

00:59:25.450 --> 00:59:26.240
Do not retry it.

00:59:26.290 --> 00:59:26.980
Let it bubble up.

00:59:27.340 --> 00:59:31.100
And when I get back to the Go client, I can see the different stack traces in the different

00:59:31.460 --> 00:59:32.380
languages all the way through.

00:59:32.670 --> 00:59:38.700
So I get a Go, basically panic, that contains a Java stack trace that contains a Python stack

00:59:38.900 --> 00:59:39.060
trace.

00:59:39.370 --> 00:59:39.560
And I

00:59:39.560 --> 00:59:40.480
can

00:59:40.480 --> 00:59:41.900
see all of this across the line.

00:59:42.060 --> 00:59:46.659
So and also the thing, and just to do it for fun, because I like showing off, I have all

00:59:46.680 --> 00:59:52.280
of these workers running on different machines. So I am, I am running on different, I am crossing

00:59:52.620 --> 00:59:57.480
process boundaries. I'm crossing literally across the network IP boundaries, and then I'm crossing

00:59:57.660 --> 01:00:00.640
language boundaries and it happens seamlessly and you'd never know that it happened.

01:00:01.240 --> 01:00:02.220
So the

01:00:02.380 --> 01:00:07.120
orchestration layer is, is the wildest thing ever. and then you asked about the rust SDK.

01:00:07.880 --> 01:00:12.539
That's a fun one. So that kind of goes back into the history a little bit of how temporal was built

01:00:13.280 --> 01:00:17.740
and for a crash course in this within two minutes or less.

01:00:18.720 --> 01:00:21.560
Essentially, our founders started at AWS together

01:00:21.920 --> 01:00:23.160
and built out what would become,

01:00:25.400 --> 01:00:27.440
they built the foundations for SQS

01:00:27.560 --> 01:00:29.060
and what would become simple workflow service.

01:00:29.520 --> 01:00:30.700
Then one of the founders left,

01:00:30.880 --> 01:00:32.560
went to Azure and helped build

01:00:32.580 --> 01:00:34.220
the Azure Durable Task Framework at Microsoft.

01:00:34.760 --> 01:00:37.580
They met up back together at Uber and built Uber's Cadence.

01:00:38.600 --> 01:00:41.340
Cadence was then basically like battle tested for four years,

01:00:41.680 --> 01:00:43.660
open sourced, and then they got permission to fork it

01:00:44.160 --> 01:00:44.960
and build Temporal.

01:00:45.030 --> 01:00:47.140
So Temporal, the company is six years old,

01:00:47.410 --> 01:00:49.200
but it was a four-year-old open source project prior.

01:00:49.530 --> 01:00:51.500
So it's a 10-year-old open source project, essentially.

01:00:53.159 --> 01:00:55.540
But because of that, what happened at Cadence was,

01:00:55.550 --> 01:00:57.540
I think they wrote the Go and the Java SDKs there.

01:00:57.630 --> 01:00:59.060
So those are very uniquely themselves

01:00:59.370 --> 01:01:00.280
because they were written independently.

01:01:00.790 --> 01:01:03.280
When they, and then the PHP SDK is its own story.

01:01:04.100 --> 01:01:05.140
Someone wrote that in the community

01:01:05.290 --> 01:01:06.200
because they really wanted it,

01:01:06.420 --> 01:01:07.960
and it kind of follows its own rules.

01:01:08.580 --> 01:01:10.880
But when they started building the Temporal SDKs,

01:01:12.220 --> 01:01:13.680
TypeScript was the first one and then Python,

01:01:15.340 --> 01:01:15.920
if I remember correctly.

01:01:16.520 --> 01:01:17.540
They wanted a common core,

01:01:17.760 --> 01:01:19.140
like basically re-implementing this

01:01:19.180 --> 01:01:20.140
because in these SDKs,

01:01:20.140 --> 01:01:21.200
there are very complex state machines

01:01:21.580 --> 01:01:25.540
that maintain all of this state of what's going on.

01:01:26.500 --> 01:01:28.100
And they did not want to keep re-implementing this

01:01:28.220 --> 01:01:28.800
every single time.

01:01:29.000 --> 01:01:31.560
So they built a Rust core SDK,

01:01:31.860 --> 01:01:32.580
or it's not even an SDK.

01:01:32.780 --> 01:01:33.300
It's not an SDK.

01:01:33.840 --> 01:01:34.640
It's just the core.

01:01:34.860 --> 01:01:35.720
And all of these,

01:01:35.940 --> 01:01:37.080
so the TypeScript, the.NET,

01:01:37.360 --> 01:01:38.980
the Python and the Ruby SDKs

01:01:39.160 --> 01:01:41.360
all have a upper level SDK

01:01:41.600 --> 01:01:44.880
that wraps this core Rust SDK and call into it.

01:01:45.040 --> 01:01:46.400
So they share a common theme.

01:01:46.820 --> 01:01:48.480
So there definitely will sometimes be features

01:01:48.720 --> 01:01:50.780
or like things that happen in the Go or the Java SDK

01:01:50.920 --> 01:01:52.260
that you're like, that's a little different

01:01:52.700 --> 01:01:54.560
because those are not based on Rust core.

01:01:55.700 --> 01:01:56.960
But yeah, that's how they all call in.

01:01:56.960 --> 01:01:59.540
So like PIO3 is basically being used here.

01:01:59.620 --> 01:02:01.880
We're calling with PIO3 into a Rust binding.

01:02:02.860 --> 01:02:05.220
Much like Pydantic and others, yeah.

01:02:05.580 --> 01:02:06.320
Exactly, yeah.

01:02:06.420 --> 01:02:08.840
So, and it's really cool.

01:02:09.080 --> 01:02:12.000
And that makes adding new SDKs a lot easier

01:02:12.090 --> 01:02:13.240
because really and truly the hardest part

01:02:13.240 --> 01:02:15.700
of building the SDKs was like those state machines

01:02:15.790 --> 01:02:16.500
used to take a long time.

01:02:16.530 --> 01:02:18.480
And once they got it figured out on the Rust core side,

01:02:18.880 --> 01:02:20.500
it made adding new languages easier.

01:02:21.240 --> 01:02:23.080
The Ruby SDK is in public preview

01:02:23.150 --> 01:02:25.800
and will be going generally available here soon.

01:02:26.780 --> 01:02:28.700
And there may be one or two more SDKs coming out

01:02:30.230 --> 01:02:30.660
within the future.

01:02:31.500 --> 01:02:31.660
If you

01:02:31.660 --> 01:02:32.440
guessed really hard,

01:02:32.550 --> 01:02:33.700
you could figure out what it is.

01:02:33.860 --> 01:02:36.000
There's a core that doesn't have an SDK.

01:02:39.859 --> 01:02:41.580
there's no secret there's no

01:02:41.580 --> 01:02:42.680
there's no secret about that

01:02:42.680 --> 01:02:44.380
like yeah of course people

01:02:44.380 --> 01:02:44.580
have been

01:02:44.700 --> 01:02:47.620
begging for that for years and it's obvious so yeah

01:02:47.620 --> 01:02:51.800
may involve crates okay so what's what is the

01:02:52.200 --> 01:02:59.540
what's the future like anything that's worth uh giving a shout out that's coming or that kind of

01:02:59.660 --> 01:03:00.760
stuff yeah

01:03:00.760 --> 01:03:04.779
i mean i think that like a lot of times people often ask me like what is temporal

01:03:04.780 --> 01:03:09.920
used for. And I would say Temporal is used for anything that you don't want your code to fail.

01:03:12.120 --> 01:03:18.240
It's really interesting to help educate people and work on a product that really does

01:03:19.240 --> 01:03:24.020
affect nearly every single part of the software development lifecycle and every single part of

01:03:25.230 --> 01:03:30.280
the industry. I was used to working on other products that like, yeah, I worked at a synthetic

01:03:30.390 --> 01:03:33.920
data company for a little bit and then at a very niche area. And then I worked at DigitalOcean,

01:03:34.080 --> 01:03:36.000
which was cloud products, which is still awesome,

01:03:36.150 --> 01:03:37.520
but like doesn't affect everything.

01:03:38.000 --> 01:03:40.860
Temporal really does like, are you doing finance?

01:03:41.480 --> 01:03:43.680
Temporal is great for long running transactions.

01:03:43.860 --> 01:03:45.260
Are you doing food delivery?

01:03:45.710 --> 01:03:47.080
Like, are you a fast food industry?

01:03:47.210 --> 01:03:48.060
Are you doing groceries?

01:03:48.310 --> 01:03:49.780
Are you doing, what are you doing?

01:03:50.220 --> 01:03:51.500
Temporal can benefit from it.

01:03:51.620 --> 01:03:53.260
So there's a lot of really cool things.

01:03:53.760 --> 01:03:54.480
You can use it for anything.

01:03:54.590 --> 01:03:57.140
And what we're seeing right now specifically,

01:03:57.440 --> 01:03:59.780
and this kind of alludes back to your open AI thing earlier,

01:04:00.680 --> 01:04:02.700
is that we're seeing a lot of AI companies

01:04:02.770 --> 01:04:03.960
get a lot of value out of this.

01:04:04.000 --> 01:04:08.460
because when it becomes time to take your agents to production,

01:04:10.280 --> 01:04:12.620
there's a handful of decent production stories out there,

01:04:12.780 --> 01:04:15.860
but it turns out these are AI agents in production.

01:04:16.760 --> 01:04:19.820
This is microservices in production with a fancy label on top of it.

01:04:19.900 --> 01:04:20.960
These are just distributed systems.

01:04:21.220 --> 01:04:23.000
Not only are they microservices,

01:04:23.440 --> 01:04:25.220
they're very slow, long-running

01:04:25.220 --> 01:04:25.900
microservices.

01:04:25.940 --> 01:04:26.100
Exactly.

01:04:26.470 --> 01:04:26.780
Which make

01:04:26.780 --> 01:04:27.420
it harder, yeah.

01:04:27.900 --> 01:04:30.380
Yeah, that's exactly what Temporal's model is.

01:04:30.720 --> 01:04:33.100
Do you have a slow-running microservice that can sometimes fail?

01:04:33.600 --> 01:04:33.880
Great.

01:04:33.940 --> 01:04:36.140
We have a product that makes all those problems go away.

01:04:36.580 --> 01:04:41.100
So, you know, like I'm working on a lot of content right now around showing the benefit

01:04:41.130 --> 01:04:42.020
of Temporal in AI.

01:04:43.040 --> 01:04:50.400
And we have a handful of customers who I can't talk about that are using us for lots of different

01:04:50.600 --> 01:04:51.540
AI related things.

01:04:51.950 --> 01:04:53.720
But I mean, you can look on our blog or anything.

01:04:53.750 --> 01:04:55.260
You can see tons of people that are using it.

01:04:56.460 --> 01:04:57.180
And it's a really cool thing.

01:04:57.180 --> 01:05:00.960
So I would definitely say like if you're trying to take AI to production, you should be looking

01:05:01.070 --> 01:05:01.640
into Temporal.

01:05:02.540 --> 01:05:03.640
It's not an AI tool.

01:05:03.840 --> 01:05:12.000
You know, like we're not we're not going to like we're not going to do the thing that every company did is we're not going to suddenly pivot and become an AI tool because we're not.

01:05:12.000 --> 01:05:12.120
We

01:05:12.120 --> 01:05:14.820
just we solve everything.

01:05:15.010 --> 01:05:15.160
And

01:05:15.160 --> 01:05:15.860
AI is one of the

01:05:15.860 --> 01:05:16.660
great things we solve.

01:05:17.020 --> 01:05:17.120
So.

01:05:18.800 --> 01:05:19.160
That's awesome.

01:05:19.960 --> 01:05:20.080
Yeah.

01:05:20.680 --> 01:05:22.740
You're not going to vibe code with temporal.

01:05:22.880 --> 01:05:25.420
Maybe you vibe code temporal code, but not with temporal.

01:05:26.140 --> 01:05:29.640
No, I've I've I've actually vibe coded a handful of temporal things.

01:05:29.740 --> 01:05:34.920
And it's interesting because like, I'm super picky about what, what people's temporal code

01:05:35.040 --> 01:05:37.860
looks like as, because I've been teaching people best practices for three years, almost

01:05:37.950 --> 01:05:38.320
three years now.

01:05:38.940 --> 01:05:40.500
And I I'm like, no vibe coding.

01:05:40.640 --> 01:05:41.200
That's no Claude.

01:05:41.300 --> 01:05:41.800
That's wrong.

01:05:41.960 --> 01:05:43.540
Like no, no, no cursor.

01:05:43.760 --> 01:05:44.120
That's wrong.

01:05:44.220 --> 01:05:45.300
Like you can't do that.

01:05:45.350 --> 01:05:48.420
So, and the interesting thing about that is the way that I'm looking at, it's like, oh,

01:05:48.860 --> 01:05:50.400
I need to make more content about this

01:05:50.400 --> 01:05:52.000
because, because the

01:05:52.000 --> 01:05:53.760
LLMs are not like, it's actually

01:05:53.980 --> 01:05:56.220
funny every now and then the LLMs spit out some of my content.

01:05:56.920 --> 01:06:01.180
And I can tell when it's my content because I know I write comments in a very particular way.

01:06:02.860 --> 01:06:04.360
And I'm like, oh, okay.

01:06:04.600 --> 01:06:11.480
So what that ends up telling me is, oh, I need to make more content around this because we're still not vibe coding at 100% capacity.

01:06:12.240 --> 01:06:12.380
Yeah.

01:06:13.120 --> 01:06:13.480
Yeah.

01:06:14.060 --> 01:06:14.460
Yeah.

01:06:15.200 --> 01:06:17.420
That's a whole discussion we could go down.

01:06:17.820 --> 01:06:18.140
Oh, yeah.

01:06:19.100 --> 01:06:20.700
I was totally wrong when we started.

01:06:20.780 --> 01:06:22.120
I said we could talk for two hours.

01:06:22.140 --> 01:06:23.120
I think it's three or four.

01:06:23.680 --> 01:06:23.980
Yeah.

01:06:24.220 --> 01:06:25.480
We got so much more we could talk about.

01:06:25.880 --> 01:06:30.520
But there's only so much time we can dedicate to each episode.

01:06:30.820 --> 01:06:33.460
So let's go ahead and call it.

01:06:33.460 --> 01:06:35.520
I say, thanks for being here.

01:06:35.760 --> 01:06:38.200
The more I looked into this, this is a super interesting product.

01:06:38.380 --> 01:06:41.160
And there's a lot of neat Python integrations,

01:06:41.320 --> 01:06:49.220
like you program it with async and await rather than some funky SDK bolt-on thing.

01:06:50.260 --> 01:06:51.580
So people should definitely check it out.

01:06:52.160 --> 01:06:52.740
Final call to action.

01:06:52.800 --> 01:06:53.240
They're interested.

01:06:53.920 --> 01:06:54.380
What do you tell them?

01:06:55.620 --> 01:07:00.700
Check out, just check out the website. Check out temporal.io or the learn site, learn.temporal.io.

01:07:00.840 --> 01:07:05.000
It's a great place to get started. You can install temporal by just running brew install

01:07:05.200 --> 01:07:10.000
temporal on your Mac, or there's commands for windows and Linux as well. Curl commands for that.

01:07:10.740 --> 01:07:12.000
Or Docker compose up. Or

01:07:12.000 --> 01:07:14.740
Docker compose up. If you want to do that, totally can do that.

01:07:15.320 --> 01:07:18.800
Just try it out, build a workflow. And then what I tell people is try to break it.

01:07:19.280 --> 01:07:23.680
Like start a workflow, kill the worker, bring it back online. Like I think you, it's,

01:07:23.840 --> 01:07:29.200
It's really magical when you first actually try to like actually break the software and stuff.

01:07:29.960 --> 01:07:34.160
We've had multiple people that have taken jobs here who have said, I started playing with it.

01:07:34.170 --> 01:07:34.960
I tried to break it.

01:07:34.970 --> 01:07:36.960
And when I couldn't, I decided to apply for a job here.

01:07:38.320 --> 01:07:39.520
So try to break it.

01:07:39.610 --> 01:07:40.640
See what you see, what you can do.

01:07:41.339 --> 01:07:43.040
And you'll be amazed by it.

01:07:43.630 --> 01:07:44.960
Like just a personal anecdote.

01:07:45.030 --> 01:07:53.380
I remember when I applied here, I was reading through their docs and I told myself, I was like, if they can do half of the things they claim they can do in the docs, this is a, this is revolutionary.

01:07:53.420 --> 01:07:54.680
I've never seen anything like this.

01:07:54.740 --> 01:07:56.480
And it turns out we do all the things we say in our docs.

01:07:57.920 --> 01:08:00.040
It's probably the most interesting tech product

01:08:00.200 --> 01:08:01.140
I've ever worked with in my career.

01:08:02.080 --> 01:08:03.760
And I know that I will be working with it

01:08:03.900 --> 01:08:04.840
probably for the rest of my career.

01:08:05.080 --> 01:08:08.020
It fascinates me and I love playing with it.

01:08:08.160 --> 01:08:10.160
Like I build temporal applications at home for fun

01:08:10.800 --> 01:08:12.100
just because it's like, oh, look,

01:08:12.100 --> 01:08:14.420
I don't have to worry about someone's API going down anymore.

01:08:14.760 --> 01:08:14.900
Yay.

01:08:16.180 --> 01:08:16.700
It's awesome.

01:08:16.960 --> 01:08:17.040
So

01:08:17.040 --> 01:08:18.680
I hope you enjoy it as much as I do.

01:08:19.540 --> 01:08:20.279
I'm pretty impressed.

01:08:20.980 --> 01:08:22.500
All right, well, thanks for being on the show.

01:08:22.980 --> 01:08:23.880
Thanks for coming on and sharing everything.

01:08:25.580 --> 01:08:26.200
Yeah, it was great.

01:08:26.850 --> 01:08:27.359
Great to talk with you.

01:08:28.080 --> 01:08:28.500
Yeah, you as well.

01:08:28.750 --> 01:08:28.920
Bye-bye.

