WEBVTT

00:00:00.760 --> 00:00:03.580
Kyle, Danny, and Abby, welcome to Talk Python To Me.

00:00:04.500 --> 00:00:06.620
Hello. Thank you for having us.

00:00:07.230 --> 00:00:13.820
Hello, hello. I don't know what type of podcast this is going to be. I imagine, you know, when talking about Python types, it's going to be amazing.

00:00:14.640 --> 00:00:28.400
So thank you all for being here. And I feel there's a new generation of Python type tools and appreciation. And you all have built a really cool one that we're going to dive into.

00:00:28.480 --> 00:00:30.560
So super excited about that.

00:00:31.110 --> 00:00:37.800
Before we get into everything, though, let's just get a quick introduction about who you are and things like that.

00:00:38.000 --> 00:00:41.260
So Kyle, we'll go around the squares here.

00:00:41.330 --> 00:00:41.680
How are you doing?

00:00:42.220 --> 00:00:43.100
Sure. I'm doing great.

00:00:43.960 --> 00:00:51.620
I've been working at Meta for three years on static analysis tooling, originally the PyreType checker, which I actually have engraved on my cup right here.

00:00:52.160 --> 00:00:52.920
We did that at the office.

00:00:53.770 --> 00:00:55.520
And then more recently working on Pyrefly.

00:00:55.980 --> 00:00:58.460
so I'm really excited to be here to talk to you guys about that.

00:00:59.080 --> 00:01:01.500
Yeah, and is your background in Python or what's the background?

00:01:02.460 --> 00:01:05.199
I guess technically I haven't worked in too much Python.

00:01:05.500 --> 00:01:06.620
Pyre was written in OCaml.

00:01:07.420 --> 00:01:10.120
I've worked in TypeScript and then Rust for Pyrefly.

00:01:10.620 --> 00:01:12.300
So I do personal projects in Python.

00:01:12.640 --> 00:01:17.500
Do you feel that TypeScript prepared you well for Python typing or is it like really different?

00:01:17.570 --> 00:01:26.380
I know more than say C#, C++, other languages like TypeScript and Python typing kind of share a philosophy.

00:01:27.440 --> 00:01:28.360
- Yeah, I think they're similar.

00:01:29.210 --> 00:01:30.520
It definitely gave me some background.

00:01:33.119 --> 00:01:39.420
I think Python typing is its own beast and there's so much about it that isn't so similar to TypeScript.

00:01:39.470 --> 00:01:41.500
So it really is pretty different.

00:01:42.020 --> 00:01:42.440
- Okay.

00:01:43.070 --> 00:01:43.480
Hey, Danny.

00:01:44.759 --> 00:01:45.680
- Hey, yeah.

00:01:45.900 --> 00:01:54.120
So I've been at Meta for just over five years And I currently work on Python type checking.

00:01:54.900 --> 00:01:57.720
So I support Powerfly mostly from the type checking side of things.

00:01:58.340 --> 00:02:03.120
Before this, I was on WhatsApp working on developer tooling for them.

00:02:03.780 --> 00:02:08.440
And before that, I was working on server and client infrastructure for Messenger.

00:02:09.679 --> 00:02:10.759
Yeah, very fun.

00:02:11.200 --> 00:02:12.660
All right, Abby, welcome.

00:02:13.580 --> 00:02:13.740
Hi.

00:02:14.900 --> 00:02:20.000
I'm the newest joiner, I guess, of this trio to Meta.

00:02:20.180 --> 00:02:23.720
I joined earlier this year and I'm a developer advocate.

00:02:24.520 --> 00:02:33.380
I started off doing more JavaScript sort of web development work and then became more of a Python person and moved into developer relations.

00:02:34.280 --> 00:02:35.940
And yeah, now I'm here.

00:02:37.840 --> 00:02:39.100
How do you find developer relations?

00:02:40.340 --> 00:02:41.000
I love it.

00:02:41.040 --> 00:02:51.940
I think I learned very early on that I enjoyed talking about code and being nerdy with people about code as much as I did actually sitting and writing code.

00:02:52.540 --> 00:02:56.000
So this job is kind of like the best of both worlds.

00:02:56.340 --> 00:02:56.820
Yeah, it's awesome.

00:02:56.870 --> 00:02:58.860
I always kind of thought that would be a super fun role.

00:02:59.460 --> 00:03:03.400
That's something I might want to do at some point, but I guess in a sense.

00:03:03.510 --> 00:03:04.300
We basically do it.

00:03:04.620 --> 00:03:05.040
Yeah, exactly.

00:03:05.540 --> 00:03:11.500
I just, I have no allegiances or no particular thing that I'm really, you know.

00:03:12.120 --> 00:03:12.900
Back of old trades.

00:03:13.620 --> 00:03:14.080
Yeah, exactly.

00:03:14.550 --> 00:03:16.240
Just whatever is curious, we'll talk about it.

00:03:16.320 --> 00:03:16.640
Like types.

00:03:17.160 --> 00:03:18.880
So super cool.

00:03:19.300 --> 00:03:21.960
Let's start with, excuse me.

00:03:22.100 --> 00:03:24.980
Let's start with what is Pyrefly?

00:03:27.160 --> 00:03:27.420
Yes.

00:03:27.770 --> 00:03:34.100
So Pyrefly is a Python type checker and language server that has very powerful IDE features.

00:03:34.660 --> 00:03:35.700
It's written in Rust.

00:03:36.160 --> 00:03:37.960
You can use it as a command line tool.

00:03:38.040 --> 00:03:40.420
You can use it as a VS Code extension.

00:03:40.500 --> 00:03:44.520
You can use it as a language server connected to your favorite editor.

00:03:44.840 --> 00:03:57.280
And it provides both IDE things like hover, go to definition, things like that, as well as just very fast type checking that infers a lot of types, even when your code base is not annotated.

00:03:58.820 --> 00:04:02.060
We should also mention that it's in alpha right now.

00:04:02.180 --> 00:04:12.260
So a lot of like changes getting shipped every week, you know, lots of sort of exciting new things happening.

00:04:12.510 --> 00:04:15.280
So, but just, you know, try it out with a pinch of salt.

00:04:15.880 --> 00:04:17.260
Sure. No, that's a really good point.

00:04:19.299 --> 00:04:34.760
I was just logging into GitHub for a completely different reason this morning and right in my activity feed, the very top item was Pyrefly's latest release with I think 18 contributors and 70 changes or something like that.

00:04:34.940 --> 00:04:35.940
Quite a big deal.

00:04:37.380 --> 00:04:40.160
Yeah, it's a huge sort of community effort.

00:04:40.340 --> 00:04:42.680
I know because I do the release notes every week.

00:04:42.920 --> 00:04:46.660
So I'm looking through everyone that's been pushing stuff.

00:04:46.700 --> 00:04:49.060
And we do releases currently every week.

00:04:49.620 --> 00:05:03.960
So every week it's some of the same faces showing up, quite a lot of the meta team, but also quite a few non-meta folks as well, contributing or just opening bug reports or feature requests as well.

00:05:04.880 --> 00:05:08.300
Yeah, so pretty, it's a hive of activity at the moment.

00:05:09.400 --> 00:05:10.980
Yeah, so you said you're doing the release notes.

00:05:12.480 --> 00:05:23.720
This project you're working on as a proper open source project rather than what you might call source open, like you can see the source, but we're working on it, everything.

00:05:26.160 --> 00:05:58.240
Yeah, so I think one of the things that, and I think Kyle and Danny can also speak to this, they've been with the project since its inception, you know, really started from the get-go as an open source initiative. This wasn't something that we built internally and then just threw over the fence. You know, we're working in public and we're trying to bring in the community and work alongside them to make something that is a great tool for everyone, not just for Meta.

00:05:58.640 --> 00:06:15.520
Obviously, the original motivation for the project was probably because of some specific needs we had internally, but there's a lot of effort that gets put into making sure that we're prioritizing features that are useful for the entire community as well.

00:06:16.180 --> 00:06:20.440
Yeah. And just out from the audience there, Tushar says, Firefly is incredible.

00:06:20.640 --> 00:06:23.620
Really looking forward to using it as a base tool for many, many dev tools.

00:06:23.880 --> 00:06:28.180
So even though it's an alpha, you already have some fans, which is cool.

00:06:29.640 --> 00:06:30.180
That's awesome.

00:06:30.820 --> 00:06:32.480
Yeah, and that's part of the open source thing, right?

00:06:33.700 --> 00:06:44.220
Like, Kyle or Danny, you want to talk a bit as well about just why you all decided to open source it or, you know, build it primarily as an open source thing?

00:06:45.220 --> 00:06:45.320
Sure.

00:06:45.700 --> 00:06:53.640
Yeah, I think the more open source contributors we have, actually, the more help we get in contributions, bug reports.

00:06:55.020 --> 00:06:56.440
Meta has a lot of Python code.

00:06:56.780 --> 00:07:00.660
If Python as an ecosystem gets better, Meta's code gets better.

00:07:01.800 --> 00:07:07.700
So we love to see when we work on something and the community can improve because of it.

00:07:10.699 --> 00:07:23.600
Yeah, and I guess another sort of motivation that we had was that Pyre was very tailored to how Meta's code bases are structured, like Meta's build systems and things like that.

00:07:24.160 --> 00:07:34.740
And what that meant was that we actually had trouble sort of when we pulled in dependencies from the wider ecosystem, Pyre had some trouble understanding them.

00:07:34.930 --> 00:08:07.400
So sort of being able to understand all the code and not just like the flavor of Python that Meta writes important for us. And we also identified a gap in the current tooling that's available. And we thought that we could help bring forward and elevate the state of typing in Python by providing tools that make it easier to add types to your code and things like that and add type checking.

00:08:11.060 --> 00:08:13.380
I think, you know, maybe an interesting analogy here.

00:08:13.400 --> 00:08:35.599
I don't know how much you all are even really aware or looked at it, but I think Cinder is another thing that came from you all that got open sourced, but it was like so specifically for meta and sort of internally that it had all these cool features, but they had to kind of be backported or crossported.

00:08:35.599 --> 00:08:36.520
I don't know whatever you call it.

00:08:36.620 --> 00:08:41.400
when it goes over to the real Python to sort of add some of these features.

00:08:41.760 --> 00:08:43.620
And some of them are making big impacts, right?

00:08:43.800 --> 00:08:53.660
Like we've got with 3.14, the proper adoption of-- I don't know, was it PEP 703 or something-- where the gill-less, the free-threaded Python stuff.

00:08:53.960 --> 00:08:58.920
And like a lot of the faster C-Python things were either taken from or inspired from Cinder.

00:08:59.020 --> 00:09:00.000
So it was really impactful.

00:09:01.000 --> 00:09:11.260
But I think maybe that's kind of a contrast to Powerfly where that was done, as far as I could tell, like really internally, and then like started to be shown off outside.

00:09:12.720 --> 00:09:35.700
- Yeah, so with, I guess with CPython, I think like, I don't think Cinder's goal was necessarily to just create an alternative like runtime implementation of Python that everyone uses, but like to upstream the improvements to the, you know, the reference or like the official implementation of Python.

00:09:36.290 --> 00:09:39.280
Whereas I think in the typing space, things are a bit more fragmented.

00:09:39.680 --> 00:09:45.640
Like there isn't really a like official, you know, type checker for Python.

00:09:45.850 --> 00:09:48.240
Like my PI is the reference implementation.

00:09:48.590 --> 00:09:53.760
Yes, but it also like, you know, was built not as a language server.

00:09:54.000 --> 00:09:57.880
And I think like, like architecturally and like, there's a lot of different

00:09:58.080 --> 00:09:58.860
choices out there, right?

00:09:59.220 --> 00:10:02.920
Pyright is very popular, PyLance, and things like that.

00:10:03.060 --> 00:10:14.760
So it's less sort of-- I think contributing to the typing ecosystem doesn't necessarily have to come in the form of upstreaming changes to mypy.

00:10:15.440 --> 00:10:15.880
Whereas--

00:10:15.880 --> 00:10:16.820
Yeah, that's a good--

00:10:17.140 --> 00:10:17.880
That's a really good point.

00:10:18.540 --> 00:10:19.940
Kyle, did you want to add something as well?

00:10:19.960 --> 00:10:20.720
You were going to say something.

00:10:21.400 --> 00:10:21.820
Yeah.

00:10:23.360 --> 00:10:23.980
I don't exactly remember.

00:10:23.990 --> 00:10:25.440
I think Danny could as well.

00:10:26.000 --> 00:10:26.540
All right.

00:10:26.680 --> 00:10:27.280
It's all good.

00:10:27.900 --> 00:10:28.660
It's all good.

00:10:30.260 --> 00:10:32.180
I do think it's different as well, right?

00:10:32.340 --> 00:10:36.400
Like in practice, there really can only be one CPython.

00:10:37.240 --> 00:10:38.260
I know we have PyPy.

00:10:38.460 --> 00:10:39.740
I know we had IronPython.

00:10:40.660 --> 00:10:41.420
We had Jython.

00:10:41.600 --> 00:10:42.420
There's a lot of variations.

00:10:42.600 --> 00:10:47.480
But in practice of what people use, it's really CPython or Bust.

00:10:47.760 --> 00:10:48.240
You know what I mean?

00:10:48.460 --> 00:10:54.580
And so you kind of got to upstream those things if they're going to really make it back in.

00:10:55.460 --> 00:10:56.660
Whereas I agree with mypy.

00:10:56.840 --> 00:11:02.620
I know I always felt like mypy was the official type checker, but that its adoption wasn't all that high.

00:11:03.820 --> 00:11:07.940
I mean, it's very, it has a lot of users.

00:11:08.700 --> 00:11:17.900
So I think it's maybe adoption, I would say is pretty high, but I'd say maybe it's not as widespread.

00:11:18.130 --> 00:11:25.160
Like there's definitely a lot of people that have strong feelings about mypy and how it doesn't work for them.

00:11:25.780 --> 00:11:51.760
And I think a lot of the design choices that were made in Pyrefly and some of the other type checkers that you're seeing sort of coming on the scene this year were deliberately to solve some of those issues for people out there that wanted to use typed Python and wanted to, you know, have a type checker that wasn't, that didn't suffer from some of the same frustrations they had with mypy.

00:11:53.580 --> 00:11:53.680
Sure.

00:11:54.390 --> 00:11:54.540
Okay.

00:11:54.790 --> 00:11:54.960
Yeah.

00:11:55.140 --> 00:12:00.020
Your stuff is still pretty popular already for being in alpha, almost 4,000 GitHub stars.

00:12:00.400 --> 00:12:03.860
And yeah, that's a sign that there's a lot of interest.

00:12:03.940 --> 00:12:04.600
It's just me bringing in the method.

00:12:07.240 --> 00:12:09.620
Every day, get my coffee, start my project.

00:12:13.180 --> 00:12:24.260
So one of the goals, as you can tell from the H2, a fast Python type checker, maybe hints at some of the reasons that you all built it.

00:12:24.980 --> 00:12:29.760
So some of its really important attributes.

00:12:31.060 --> 00:12:34.580
I know people in the Python space often harp on fast.

00:12:35.100 --> 00:12:36.600
Usually the word rust is involved.

00:12:37.680 --> 00:12:37.780
Check.

00:12:39.500 --> 00:12:44.400
So but it's not always that fast is necessarily that important, right?

00:12:44.660 --> 00:12:51.300
Like sometimes it can take half a second or it can take a tenth of a second, and it's effectively fine.

00:12:52.300 --> 00:12:57.380
But with these, especially, it's not even just the type checker.

00:12:57.770 --> 00:13:02.640
And Danny, I think this is how we originally got connected, is I said, oh, this is the type checker.

00:13:02.640 --> 00:13:10.120
And I was talking about something else and said, well, that's a LSP, like a language server protocol, later language server.

00:13:13.040 --> 00:13:14.380
And you're like, no, ours does too.

00:13:14.540 --> 00:13:15.820
I'm like, oh, okay, interesting.

00:13:16.860 --> 00:13:19.620
And there it starts to matter quite a bit, right?

00:13:19.820 --> 00:13:25.360
like the speed actually facilitates a different sort of interaction, right?

00:13:28.320 --> 00:13:28.760
Yeah.

00:13:28.870 --> 00:13:34.320
So I would say like, if you ask like, is Pyrefly a type checker or is it a language server?

00:13:34.510 --> 00:13:37.780
I think the answer would be yes, it is.

00:13:38.180 --> 00:13:41.780
So both of those things and those things do rely on each other.

00:13:43.320 --> 00:13:47.200
Actually, maybe Kyle, you have some good insights to share here.

00:13:47.300 --> 00:13:50.240
you've done a lot of the language server specific work.

00:13:51.420 --> 00:13:54.160
Yeah, we've been thinking about this problem for a while.

00:13:55.460 --> 00:14:01.300
I think when you run something on the command line, if it's running in CI, you might not actually be sitting there waiting for it.

00:14:02.240 --> 00:14:03.300
It would still be fast.

00:14:03.620 --> 00:14:17.620
It would be nice to be fast running on continuous integration, but definitely as you're typing, if you can see these type errors appear, but also have IDE language services working for you, That's a huge thing for it to be fast.

00:14:18.540 --> 00:14:23.480
I think one example that we've seen is the Instagram codebase is a large Python codebase.

00:14:24.260 --> 00:14:29.580
Pyre, our old type checker, was originally written because nothing could scale the Instagram level.

00:14:30.600 --> 00:14:42.180
From moving from Pyright for our language services to Pyrefly, we've actually seen a 90% increase in speed for GoToDefinition across our Instagram users, Instagram developers.

00:14:43.900 --> 00:14:50.460
So I think a difference like that from seconds to milliseconds can be really, really huge when it comes to developer productivity.

00:14:52.120 --> 00:14:58.540
Yeah, I don't know about you, but I'll open up a thing and a quick command click on something.

00:14:58.780 --> 00:15:01.260
I'm just, you're jumping around like, oh, here, no, actually over there.

00:15:01.660 --> 00:15:05.700
And I can see that, why is it not, oh, now it's working, right?

00:15:05.860 --> 00:15:07.400
Like that would be really frustrating.

00:15:08.100 --> 00:15:19.780
It's the difference between wondering, is your IDE just frozen versus just not even noticing it at all and it just blending into the background of your development environment.

00:15:20.120 --> 00:15:26.800
And it's actually not easy to make that happen, especially when you have these massive code bases.

00:15:28.380 --> 00:15:37.580
And so building with speed in mind does have a very tangible difference, even though it may not be the first thing that you as an end user are thinking about.

00:15:38.720 --> 00:16:09.660
can you all give any sense if you're not allowed to or whatever it's fine but give me a sense of how much when you say a big code base what do you mean I was just fiddling around trying to get a sense of how big is this versus that versus that Django I think Flask is 30,000 lines of Python Django is 300 VS Code is 2 million Linux is 30 million And like, where are we talking on that spectrum?

00:16:10.920 --> 00:16:11.940
What's a large code base?

00:16:12.840 --> 00:16:16.340
Instagram is the biggest, I think, Django deployment in the world.

00:16:16.760 --> 00:16:21.480
And I think the code base size is an order of magnitude bigger than VS Code.

00:16:21.900 --> 00:16:22.760
So, I don't know.

00:16:22.800 --> 00:16:23.160
Wow, okay.

00:16:23.590 --> 00:16:23.720
Yeah.

00:16:24.160 --> 00:16:27.060
Isn't the official number 20 million lines?

00:16:27.420 --> 00:16:28.360
20 something million, yeah.

00:16:30.040 --> 00:16:33.540
So somewhere between, what did you say, Linux and...

00:16:34.140 --> 00:16:35.660
Yeah, between VS Code and Linux.

00:16:35.780 --> 00:16:42.080
It sounds like on the par of like Firefox or something, which is a mega, mega project.

00:16:42.400 --> 00:16:43.140
Yeah, that's awesome.

00:16:43.340 --> 00:16:43.520
Yeah.

00:16:43.980 --> 00:16:51.800
And to give like a point of reference, like Pyre took 15 whole minutes to check the Instagram code base.

00:16:52.150 --> 00:16:56.100
Like mypy and PyRite just couldn't do it and fell over.

00:16:56.760 --> 00:16:58.780
And Pyrefly now takes 15 seconds.

00:16:59.300 --> 00:17:00.420
So it's a huge difference.

00:17:01.540 --> 00:17:01.980
Yeah, wow.

00:17:02.820 --> 00:17:04.000
Yeah, that is a huge difference.

00:17:04.660 --> 00:17:16.020
And I think for language services too, like we talk about the size of the code base, but if it's a very shallow dependency graph with many, many files, that code base might still be fast with existing tools.

00:17:16.600 --> 00:17:24.980
I think where we start to see slowdowns is when you have this big bundle of dependencies that's very, very, very deep.

00:17:25.860 --> 00:17:28.700
And that's, I think, where the existing tools didn't work for us.

00:17:29.120 --> 00:17:39.020
I see. So if you were to create a dependency graph, the problem is more like how many edges are there and how much interconnectivity.

00:17:39.450 --> 00:17:42.660
The more it is computationally, that just gets way worse, right?

00:17:44.059 --> 00:17:46.240
Okay. Yeah, that makes a lot of sense.

00:17:48.360 --> 00:17:52.240
So what lessons did you all take from Pyre, the OCaml version?

00:17:53.600 --> 00:18:00.620
Coming over, you created this somewhat internal tool and then you redid it, right?

00:18:00.780 --> 00:18:02.280
So what was the story?

00:18:02.780 --> 00:18:09.220
So, yeah, Pyre we started a while ago as, at first, static analysis for type checking and security.

00:18:09.900 --> 00:18:12.880
And then actually a few years ago, we did try porting it to an LSP.

00:18:13.980 --> 00:18:17.040
Like we said, Instagram is very, very slow with existing tools.

00:18:17.860 --> 00:18:19.080
Pyre did work for Instagram.

00:18:20.320 --> 00:18:27.000
It would take a while to type check, but if you can type check incrementally, Pyre actually did a pretty good job of that.

00:18:28.240 --> 00:18:38.600
So with that, we tried taking our type checker, turning it into a language server for the squiggles in the editor, but also like the command clicks and all of that.

00:18:40.160 --> 00:18:42.620
I think it didn't work for a lot of reasons.

00:18:44.560 --> 00:18:53.280
And I guess maybe the biggest lesson was we kind of have to be thinking about this language server from the beginning when we make this design of a system like this.

00:18:53.920 --> 00:18:56.240
Did Pyre start out as originally just a type checker?

00:18:57.400 --> 00:19:00.580
I wasn't there when it was started, but it was a type checker.

00:19:00.610 --> 00:19:05.300
And there's a query interface that lets you ask questions, basically, about the types.

00:19:06.540 --> 00:19:11.320
It's used for a few things, but static analysis in general is its goal.

00:19:12.180 --> 00:19:15.560
Yeah, I can give a little bit more context on that.

00:19:16.380 --> 00:19:29.640
So I think the core of how Pyre started was a security tool that analyzed data flow through programs and prevents, for example, unsanitized user input from being directly executed.

00:19:29.900 --> 00:19:36.580
And I think that type of static analysis tooling is only designed to run in continuous integration.

00:19:37.400 --> 00:19:47.460
And the internal representations it used for the code were simplified, and you lose some things that are not relevant for static analysis.

00:19:48.080 --> 00:20:04.040
And then turning that into a type checker with Pyre, there were already some issues with Pyre's internal representation losing some of the syntactic components that were required for type checking.

00:20:04.320 --> 00:20:06.900
So we spent a lot of time compensating for that.

00:20:07.320 --> 00:20:12.140
And then turning that into a language server was another big jump.

00:20:12.180 --> 00:20:22.680
And it just felt like we were taking a tool that wasn't designed to be a language server and trying to turn it into a language server and getting sort of mediocre results.

00:20:22.900 --> 00:20:27.920
So the lesson is like, you know, designing it as a language server from the ground up was very important.

00:20:28.960 --> 00:20:33.840
You know, a language server can be used as a type checker more easily than a type checker can be used as a language server.

00:20:34.540 --> 00:20:39.760
And I guess the idea of incremental checking is, you know, I think that's a good idea and it works.

00:20:40.100 --> 00:20:45.080
And, you know, we were also prioritized incrementality when we designed Pyrefly.

00:20:46.600 --> 00:20:46.780
Okay.

00:20:48.100 --> 00:20:48.760
And why Rust?

00:20:49.520 --> 00:20:57.720
I mean, I know it's the way that Python gets sped up these days, but you could have picked anything.

00:20:57.910 --> 00:20:59.020
And it was OCaml before.

00:20:59.170 --> 00:21:07.160
And I feel like going from, you know, functional type language, right, to another one is a really big change as well.

00:21:07.660 --> 00:21:09.760
So how'd that come about?

00:21:12.120 --> 00:21:17.960
Well, I think also like partly like what you said isn't like about it.

00:21:18.300 --> 00:21:20.680
It's the way now that people do Python and Rust.

00:21:20.880 --> 00:21:23.260
Like that's not actually too far from the truth.

00:21:24.040 --> 00:21:42.380
Like if you're creating an open source project, if you genuinely want contributions from the community, there is some sense in writing it in a language that the community is, has the skills for and is excited about like Rust, as opposed to something like OCaml.

00:21:43.800 --> 00:21:53.580
No offense to any OCaml fans out there, but our potential community of contributors definitely was larger with Rust.

00:21:53.940 --> 00:22:01.260
So I can speak to that point a bit, but I think there's also some more sort of like specific technical reasons as well that Danny could probably elaborate on.

00:22:01.280 --> 00:22:04.000
Yeah, I think that's absolutely worth considering though.

00:22:04.000 --> 00:22:11.080
If you want contributors, you want to work in a language that people at least know ideally want to play with, right?

00:22:11.160 --> 00:22:13.820
So that's a really, it's non-trivial.

00:22:14.300 --> 00:22:15.180
I mean, it matters.

00:22:16.120 --> 00:22:18.540
Yeah, getting contributors for OCaml was difficult.

00:22:18.760 --> 00:22:24.060
Although I will say one of the reasons why I joined the Pyre team was so I could get paid to write OCaml.

00:22:24.240 --> 00:22:25.640
So, you know.

00:22:28.180 --> 00:22:29.340
But it's okay.

00:22:29.820 --> 00:22:31.500
I enjoy writing Rust as well.

00:22:31.680 --> 00:22:35.220
So I really, you know, it's been a great journey.

00:22:35.640 --> 00:22:44.260
And I mean, I think when writing a tool for Python, maybe the first most obvious choice would just be to write it in Python directly.

00:22:44.490 --> 00:22:50.760
So tools like, you know, FlakeA, mypy are written in Python, and that really helps get new contributors.

00:22:51.600 --> 00:22:58.560
But I think we felt like with our, like, very aggressive performance goals that writing it directly in Python wouldn't be fast enough.

00:22:59.080 --> 00:23:08.140
So we wanted to pick, you know, a fairly fast language that compiled to native code worked on Windows, which was very important because Pyre did not work on Windows.

00:23:10.360 --> 00:23:15.560
And so that left us with only a few options, really.

00:23:15.660 --> 00:23:21.720
And I think in the end, when we were doing the prototyping, it was between Rust and Go.

00:23:22.280 --> 00:23:40.380
And I think the team had more experience in Rust and one of the leads for the project sort of had experience with a successful rewrite of our buck build system into Rust and had good results from that. So we were more confident in moving forward with writing it in Rust.

00:23:41.080 --> 00:23:45.300
But didn't the TypeScript team is rewriting their compiler in Go, right? So...

00:23:45.340 --> 00:23:47.400
Yeah, they are. That's actually a really big deal. Yeah.

00:23:47.780 --> 00:23:50.680
So yeah, we were also picking between those two languages.

00:23:52.160 --> 00:24:01.880
I do think that Rust is a little more compatible with Python people and tooling and expectations than Go.

00:24:02.620 --> 00:24:08.980
Nothing's wrong with Go necessarily, but it's more focused on concurrency than others.

00:24:09.100 --> 00:24:15.780
And I don't think, I mean, I guess that there's probably some parallels and that's really interesting here, but you can do that in Rust as well.

00:24:16.180 --> 00:24:17.500
But it's just Rust is,

00:24:17.540 --> 00:24:24.160
I just see Rust being used as if you've got to go to something native, it's almost always Rust if it's a new project these days.

00:24:26.900 --> 00:24:27.040
Yeah.

00:24:27.240 --> 00:24:31.940
And I mean, Rust also lets us have very good control over our memory.

00:24:32.580 --> 00:24:49.020
And one of the concerns when checking extremely large code bases is the memory overhead, both total and also the peak, and having control over how memory is allocated when to evict certain things was important for us.

00:24:49.860 --> 00:24:50.100
Yeah.

00:24:51.190 --> 00:24:52.700
So you talked about having it work on Windows.

00:24:56.419 --> 00:24:59.580
What's the OS breakdown at Meta?

00:25:00.260 --> 00:25:02.360
Like, do people get to pick whatever they want?

00:25:02.760 --> 00:25:03.680
Is it all Macs?

00:25:03.840 --> 00:25:05.280
Can you do Linux on the desktop?

00:25:05.980 --> 00:25:07.060
What's the story there?

00:25:07.660 --> 00:25:14.640
- Well, I'm the most recent joiner out of this team, and I definitely got a choice of device when I joined.

00:25:16.620 --> 00:25:19.440
But yeah, I'd say, yeah, I don't know.

00:25:19.610 --> 00:25:22.500
I think it probably really depends on what team you're in.

00:25:22.920 --> 00:25:39.580
And I think we do when we're creating open source projects, not all of the, not every user in the world is someone who sits in Silicon Valley and is using like the latest version of their Mac device.

00:25:40.540 --> 00:25:47.140
So it's super important to make sure we're, thinking about all the different, at least well within reason.

00:25:47.320 --> 00:25:48.180
- Yeah, yeah, yeah.

00:25:48.500 --> 00:25:51.380
I mean, you don't need it to run on a Raspberry Pi necessarily.

00:25:51.380 --> 00:25:51.860
- Well, yes.

00:25:52.640 --> 00:25:57.800
But if you look at the latest survey results, like these are always the PSF survey results.

00:25:57.820 --> 00:26:02.000
These are always a year behind because they get collected at the end of that year.

00:26:02.020 --> 00:26:04.540
And then, so this is the latest one, even though it's 2024.

00:26:05.220 --> 00:26:10.480
If you look at Windows, I mean, what operating system people write Python code on?

00:26:11.640 --> 00:26:16.580
It is, I think it's actually Windows is the most.

00:26:16.900 --> 00:26:19.240
It's 58% compared to Linux, which is 59.

00:26:20.160 --> 00:26:24.880
But I think that means a lot of people write on Windows and deploy to Linux and check both boxes.

00:26:25.620 --> 00:26:26.060
You know what I mean?

00:26:26.500 --> 00:26:29.640
And people write on Mac and Linux and they check that box.

00:26:29.710 --> 00:26:37.100
And so I think Linux, while it's 59 versus 58, I think it gets double counted a lot.

00:26:37.280 --> 00:26:40.080
Kind of like CSS is one of the most popular languages.

00:26:40.520 --> 00:26:41.900
Well, sort of.

00:26:42.720 --> 00:26:45.020
No matter what language you're using, it gets that box checked.

00:26:45.030 --> 00:26:45.440
You know what I mean?

00:26:45.940 --> 00:26:52.380
It would probably also be interesting to look at this data when you kind of cross section it by regions of the world as well.

00:26:53.000 --> 00:27:00.220
Yes. Probably if you're looking at North America, the Mac proportion would be significantly higher than it is there.

00:27:00.600 --> 00:27:14.300
But, you know, Python is such a globally adopted language and there are huge emerging, you know, tech economies in certain areas of like India, Southeast Asia.

00:27:15.520 --> 00:27:22.220
South America where, you know, Windows systems that are much more dominant as well.

00:27:22.800 --> 00:27:23.720
Yeah, that's a good point, Abby.

00:27:24.680 --> 00:27:32.200
Yeah, I don't really think it's table stakes to support all the operating systems people use, especially if we expect people to use our project.

00:27:33.200 --> 00:27:33.300
Yeah.

00:27:33.760 --> 00:27:48.580
The sort of main area why, like, Pyre not working on Windows, I think, hurt mostly the AR VR developers at meta who had to develop in a windows environment, I think, cause they were writing like C#. So.

00:27:49.060 --> 00:27:51.600
Right. Right. Or maybe using direct X or something like that. Yeah.

00:27:52.980 --> 00:27:55.500
Okay. Now, very interesting.

00:27:58.860 --> 00:28:06.180
The other thing I think is interesting. If you look over here is see how many years of professional coding experience do you have?

00:28:08.000 --> 00:28:10.300
50% say two years or less.

00:28:11.260 --> 00:28:12.900
30% say less than one year.

00:28:14.420 --> 00:28:24.500
So what do you think about typing for new people coming in versus those who've been around for a long time and like, yeah, I worked on a project without typing and eventually it got out of control.

00:28:26.920 --> 00:28:31.560
How do you see Pyrefly fitting in with new folks versus people who've been around for a long time?

00:28:33.600 --> 00:28:48.860
It's really interesting because Python, I mean, I would argue is so much of the success of Python as a language is because it is very well designed for newcomers to programming in general.

00:28:49.400 --> 00:28:56.740
So I think there is a reason why you see like a lot of Python developers skew towards maybe more of the sort of the early learners.

00:28:57.260 --> 00:28:57.720
I agree.

00:28:58.540 --> 00:29:27.900
And then I think you certainly get, and again, this is more anecdotal, you know, my anecdotal take, but you sort of you get to a point, you know, after you've, you know, sort of you've got the basics of the language, you've got those sort of fundamental skills locked down, and you're starting to actually develop production level code, when you realize that, like, oh, maybe I can't, maybe I shouldn't be playing as fast and loose with the types.

00:29:28.180 --> 00:29:42.420
And, you know, maybe it would actually be helpful if I was, you know, thinking a little bit more proactively about the types that I'm passing around as my project scales more and more.

00:29:43.780 --> 00:29:57.760
I think the goals of Pyrefly specifically are to support people that really value type safety and bug-free code.

00:29:59.150 --> 00:30:07.660
So maybe if you are a super new user, maybe adding a type checker isn't really on the cards for you right now.

00:30:08.020 --> 00:30:19.340
But there is a significant proportion of the Python community that are in this stage where they're not early professionals anymore and they're trying to build production level code.

00:30:19.460 --> 00:30:26.600
And now they need tools to support them and help them get through, make type safe code.

00:30:26.620 --> 00:30:33.740
And that's where a tool like TypeShepica, a tool like Pyrefly, I think really provides value.

00:30:35.380 --> 00:30:49.080
But I will say that even if you don't want type checking in your code and you don't want to write any types at all, you can still use Pyrefly in VS Code and it will try to understand as many types as it can and power your go to death.

00:30:49.620 --> 00:30:55.860
And it will work better than if you were doing it without understanding any of the types.

00:30:56.560 --> 00:30:56.820
I see.

00:30:56.970 --> 00:31:03.560
So maybe I can tell you this thing, like I can find references on this thing and show you the three places it's used or go to its definition.

00:31:03.600 --> 00:31:05.940
I just can't tell you that it returns a list of integers.

00:31:08.820 --> 00:31:10.360
Well, it does have some inference.

00:31:10.560 --> 00:31:12.320
It depends on you as a user, right?

00:31:12.360 --> 00:31:17.880
Like if you want to use Pyrefly as a language server, you can do that and you definitely should.

00:31:18.440 --> 00:31:27.840
So if you're maybe an early user who's not interested in types, maybe you just want to use Pyrefly as your IDE extension because it's really fast and helps you navigate your code base.

00:31:28.340 --> 00:31:36.200
If you then want to make that jump to being a bit more type conscious, you can still use Pyrefly.

00:31:36.340 --> 00:31:42.440
You just have to decide that now I also want Pyrefly to help me check the types as well.

00:31:42.480 --> 00:31:45.680
And that is a toggle that you can switch as a user.

00:31:46.900 --> 00:32:34.900
And I guess two sort of key things that I think is, or three key things that I think are very important for sort of early and intermediate stage developers is like, one is like things should work pretty well out of the box. Like I don't think they necessarily, people necessarily want to go fiddle with a bunch of settings to get things working if they're just working on like a small script or something. And the second is like good error messages. I think like not just saying like these types don't match, but like explaining why and maybe explaining how to fix it. And that's something that we're, we're working on. And the Third is something that we provide in the IDE called inlay hints, where we put the inferred types in this grayed-out text next to the variable.

00:32:35.410 --> 00:32:48.380
So even if you didn't know what the type was or didn't understand the type, how the types work, you can still see the type of the variable next to it without you actually having to write any types.

00:32:48.510 --> 00:32:56.340
And if you want to eventually start adding types to your code base, It's as simple as like you can double click that type and it will just add it to your code.

00:32:56.760 --> 00:32:57.340
Oh, really?

00:32:57.480 --> 00:33:06.320
I was going to ask if there's any kind of tools that take that inference and turn it into concrete code.

00:33:07.020 --> 00:33:07.340
Yeah.

00:33:07.720 --> 00:33:18.040
So in addition to clicking in the UI, we also have a subcommand in Pyrofly called Pyrofly Infer that just takes all of the inferred types and applies it to your whole code base.

00:33:18.820 --> 00:33:26.580
And does that surface itself in VS Code where you've got that little, like you can, was it Alt Enter or something?

00:33:26.680 --> 00:33:34.060
And it'll show you like, here's the fixes you can apply or the things you can apply and you can choose like, add the types to my code or something like that.

00:33:34.820 --> 00:33:35.980
I think not.

00:33:36.320 --> 00:33:39.180
I think right now it's just a command line tool, but that's a good idea.

00:33:39.660 --> 00:33:40.660
I'll write this down.

00:33:41.179 --> 00:33:41.840
There you go.

00:33:43.240 --> 00:33:47.900
But the thing is, if you're using Firefly only, you don't necessarily need to write all the types.

00:33:48.300 --> 00:33:51.460
I think we like when interface boundaries have these types.

00:33:52.000 --> 00:34:16.280
Like so for functions, if you can do a return type on those, that's actually what the typing spec mandates. So mypy doesn't type check your function unless it has a return type or like types in the arguments. But I think for like the quick fix and the IDE, it might be noisy if every time we infer something, we show it to you. So I guess these things are still being figured out.

00:34:16.360 --> 00:34:19.940
- Yeah, you don't want it to just swamp your code and kill the readability.

00:34:20.399 --> 00:34:41.220
- This is maybe an interesting challenge that might be worth clicking into a little bit in that we as the team developing Pyrefly, it's hard to create a language server and a type checker that does everything for everyone.

00:34:42.639 --> 00:35:11.940
And I think individual developers have a lot you know different opinions on like how much they want pyrefly to like get in the way of what they're doing like some people care a lot about if anything might even have a chance of being a type error they want to know about it other people you know that's too much for them and they you know they would rather like us not you know aggressively tell them that they have these errors and right

00:35:11.960 --> 00:35:17.960
Part of the magic of Python typing is you don't have to be exactly 100% complete and perfect.

00:35:18.520 --> 00:35:18.720
Yeah.

00:35:19.320 --> 00:35:19.440
Yeah.

00:35:20.020 --> 00:35:26.820
But some people do want that if they're, you know, shipping very sophisticated production level code, for example.

00:35:27.140 --> 00:35:36.940
So we've, a lot of our, I think, development discussions revolve around, you know, what should the default behavior be here?

00:35:37.020 --> 00:35:40.500
Like we can make, like, what should be like a choice that is for the user?

00:35:41.020 --> 00:35:55.640
What things do we assume that the user wants? And so it's definitely challenging. So yeah, to try and like figure out like, because there doesn't really seem to be a consensus in the Python community right now.

00:35:55.780 --> 00:36:49.120
No, no, there definitely is not. And I'm, I'm on team Kyle. I think that putting the types in on like the architectural boundary areas is super valuable because you can think about, well, what comes into this area? I want it to be completely known and accurate and right, but every single variable in a function doesn't need a type, you know, like there's a lot of, just let me work in this nice free form readable way, but also let me put up sort of the signs or signposts or whatever of people that say, if I'm going to create a public package, well, every single public bit of that's going to have types, but maybe not the internals, right? And it really, I think just a little bit like that really helps the language servers make your editors better because there's enough information for them to refer almost everything, especially the stuff that you're going to touch because that's on the boundaries.

00:36:50.660 --> 00:36:57.320
- Yeah, I definitely think at Meta, like we've had experience making sure that your code can become typed.

00:36:57.900 --> 00:37:04.540
So like Maggie at a bunch of the PyCons on our team will talk about how much success we've had in increasing type coverage.

00:37:05.220 --> 00:37:15.500
So I definitely think these inference tools and the other tools we'll provide people will be a really good way for people to add types and make their code base very strongly typed.

00:37:16.300 --> 00:37:16.600
- Yeah.

00:37:17.400 --> 00:37:27.480
To give you overdo it, you start to kill the Zen of Python and it starts to look like C# or Java or something like that, where it's like, why are all these symbols here?

00:37:27.900 --> 00:37:29.720
There's a lot of symbols here all of a sudden.

00:37:30.280 --> 00:37:34.800
- Let's not start an existential crisis around like what is Python on.

00:37:35.020 --> 00:37:35.720
- I know.

00:37:35.920 --> 00:37:37.220
- I don't think I can handle it.

00:37:39.320 --> 00:37:39.760
- Absolutely.

00:37:41.620 --> 00:37:44.340
So right here on the screen, it says, get VS Code extension.

00:37:45.960 --> 00:37:57.100
So if I were to go over there and get the VS Code extension, I know you said it's an alpha, but 15,143 people don't care.

00:37:58.440 --> 00:38:01.120
14 people gave it five stars across the board.

00:38:01.900 --> 00:38:07.280
So what happens if I install this into a VS Code-based editor?

00:38:08.400 --> 00:38:11.460
There's many branches of that tree these days.

00:38:12.060 --> 00:38:20.840
But if I install it into a VS Code-based editor from the marketplace, does it replace PyLance or Pyright or things like that?

00:38:21.020 --> 00:38:21.520
Yes.

00:38:21.820 --> 00:38:25.180
So actually now, if you install it, it's just one click install.

00:38:25.780 --> 00:38:28.720
It will disable PyLance and Pyright.

00:38:29.860 --> 00:38:31.640
It will start using Pyright for everything.

00:38:32.580 --> 00:38:37.480
And in our case, that works really well because we have very, very large code bases.

00:38:38.100 --> 00:38:41.200
and PyLance and Pyright are a little bit slow on them.

00:38:42.340 --> 00:38:54.460
If that doesn't work for you, and if you want Pyrefly to only be used in certain cases, we have settings in the, you can see in the readme, there's two, there's disabled language services and then disabled type errors.

00:38:57.020 --> 00:39:00.959
And you can configure that however you want to.

00:39:02.920 --> 00:39:04.540
- But it's ready to try out today.

00:39:04.720 --> 00:39:06.460
Like if I wanted to install it, it would work.

00:39:07.020 --> 00:39:08.520
Yes, you can even try it in front of us.

00:39:10.760 --> 00:39:11.360
There we go.

00:39:12.230 --> 00:39:13.960
Let me show you all my errors.

00:39:14.620 --> 00:39:23.060
Do you have intentions of supporting anything other than VS Code, like the JetBrains IDEs or Emacs or whatever?

00:39:23.310 --> 00:39:23.700
I don't know.

00:39:24.300 --> 00:39:27.760
So we do already have a JetBrains extension made by a community member.

00:39:29.180 --> 00:39:31.480
I don't know when the last time it was updated was.

00:39:31.590 --> 00:39:34.960
It is not a meta official one, but someone did make it.

00:39:35.680 --> 00:39:39.780
We support all editors that support LSP.

00:39:40.420 --> 00:39:44.800
So like Vim, Emacs, we have in our website ways to download Pyrefly for those.

00:39:45.600 --> 00:39:51.540
We've even made some decisions in the process of making Pyrefly that make it easier for non-VS Code editors to work.

00:39:52.020 --> 00:40:01.900
So one example of this is basically we try keeping as much out of the language client as possible to make it so any editor will work really well.

00:40:02.140 --> 00:40:02.440
Mm-hmm.

00:40:04.350 --> 00:40:06.760
OK, I'm just fooling around with the PyCharm version here.

00:40:06.880 --> 00:40:14.280
Yeah, it looks-- it's got 1,300 installs as well, which is pretty comparable.

00:40:14.660 --> 00:40:15.180
That's pretty cool.

00:40:15.640 --> 00:40:18.660
If you're using IntelliJ or PyCharm, and the plug-in's going to be installed.

00:40:18.770 --> 00:40:20.280
OK, very nice.

00:40:22.820 --> 00:40:33.160
Haven't tried that yet, but I don't-- I think that the language server type checker aspect is more presented to you in VS Code.

00:40:33.260 --> 00:40:38.020
In PyCharm, it's like, hey, PyCharm has really good type checking, but we don't know how that happens.

00:40:38.380 --> 00:40:38.760
You know what I mean?

00:40:38.900 --> 00:40:48.720
It's kind of like just behind the scenes in their tooling, whereas you're going through and picking the details in VS Code with all the extensions and piecing it together.

00:40:49.780 --> 00:40:57.180
Yeah, and I think a lot of people also are just-- it's something that you're not necessarily thinking about a lot.

00:40:57.480 --> 00:41:04.840
like you're thinking about writing your code and you're thinking about whatever goal you're trying to achieve with the project that you're building.

00:41:05.700 --> 00:41:24.160
And so I think a lot of people don't even know necessarily what default language server they're using in their IDE and how that affects their development experience, especially in IDEs like PyCharm where it's very built in and for better or worse is abstracted away from the user.

00:41:24.980 --> 00:41:25.440
- Yeah.

00:41:28.600 --> 00:42:24.060
So one of the things I think will be interesting, maybe we can explore a little bit is sometimes, you know, you talked about like picking the right defaults. And when you're new, you don't necessarily want to fiddle with the defaults. I think also, as you go through these different type checker options, they make different choices for the default behaviors and what, how strict or relaxed they're going to be. And it can be super annoying if you ever want adopt them. I remember somebody sent me a message about a I can't remember which one one of them I have a bunch of different packages that let you do different things for web frameworks like I've one for called FastAPI chameleon so if you want to use the chameleon template language but in FastAPI instead of using Jinja you just put a decorator and it does its thing right and one one is about like partial rendering.

00:42:24.190 --> 00:42:25.820
I think it was the first one I said.

00:42:26.280 --> 00:42:33.380
Somebody sent me a message and said, Pyright has given me a load of errors out of this when I use your library.

00:42:34.880 --> 00:42:37.060
It's a decorator for web calling.

00:42:37.980 --> 00:42:39.100
Nobody's calling that function.

00:42:39.320 --> 00:42:40.200
How is it giving you an error?

00:42:41.260 --> 00:42:48.540
Just the fact of like, here's a web view in Flask or FastAPI or whatever it was, and you put a decorator on it.

00:42:49.600 --> 00:42:54.080
Pyrite decided, well, here's a function that's never called, but we better validate it.

00:42:54.100 --> 00:43:00.980
And there was some slight variation, and it basically filled the screen to put out the signature differences between the two.

00:43:01.020 --> 00:43:01.780
It was gnarly.

00:43:02.660 --> 00:43:06.560
And I'm like, do I really need to figure this out to make that error go away for this person?

00:43:07.700 --> 00:43:10.600
And I did end up doing it, and it was a hassle.

00:43:10.900 --> 00:43:16.940
But my point is, these different tools out there all make these different trade-offs.

00:43:17.200 --> 00:43:28.700
And having it as a language server is really nice because if it's your language server and then maybe your CI testing tool, you see it as you build the code.

00:43:29.200 --> 00:43:32.740
You know, you don't build all the code and then run a different tool and go, whoa, it's full of errors.

00:43:33.540 --> 00:43:36.200
You see the little squigglies as you make your way through, right?

00:43:37.620 --> 00:43:44.560
And as you switch around, you'll see like a whole bunch of errors appear that you thought were not a problem, but one thing says yes, one thing says no.

00:43:45.140 --> 00:43:57.860
So that's a very long winded way of saying, let's maybe talk just a little bit about like the different type checkers and how you, what is your philosophy and like kind of that zone compared to say my pie, py, right.

00:43:59.600 --> 00:44:00.040
Pylands.

00:44:00.110 --> 00:44:02.540
We could talk about ty just a little bit as well.

00:44:02.570 --> 00:44:07.300
The other, the other new one that I feel is a peer of power fly.

00:44:10.440 --> 00:44:10.560
Yeah.

00:44:10.620 --> 00:44:29.200
Yeah, so I guess maybe our philosophy right now is like, we're fairly aggressive, I think, with trying to infer types, but we're not necessarily like super aggressive about, you know, raising type errors or like, you know, we do want to try and reduce noise.

00:44:29.300 --> 00:44:33.600
And we've tried, we've implemented a few features to help with that.

00:44:33.740 --> 00:44:48.500
Like if you are coming from mypy or PyRite, we have a Pyrefly init script that will actually take your Pyright config or mypyConfig and generate an equivalent Pyrefly config that has the equivalent error settings.

00:44:49.380 --> 00:45:02.860
And if you run it in a vacuum, then it will automatically add suppressions to certain files or ask you to opt in or out of type checking certain error codes if they're very prevalent in your project.

00:45:03.120 --> 00:45:52.060
But yeah, I guess, like, you know, compared to my PI, I guess we are a language server, and not just a type checker. And I would say compared to Pyright, we are significantly more aggressive in terms of type inference. So a good example for this is an empty container. So if you if you have, for example, if you write x equals empty list, like, and then, say, later on, you add an int to it. And then later, and then after that, you try to add a string to it, my pi and pyrefly, what we'll do is we'll determine that based on the first time you add something to the list, that it's a list of ints. And then when you try to add a string to it, it will error.

00:45:52.720 --> 00:45:57.520
And what Pyrite does is it will assume it's a list of any because it's empty.

00:45:58.050 --> 00:46:00.080
And then you can add anything to it.

00:46:00.090 --> 00:46:04.200
And then when you read from it, you lose your type safety because what you're getting out of it is an any.

00:46:05.500 --> 00:46:05.660
Right.

00:46:06.620 --> 00:46:17.540
So that's like a trade-off between, you know, the flexibility of having a list of any versus like the type safety you get by assuming it's a list of ints, you know.

00:46:18.060 --> 00:46:29.260
So it depends in this case where we're more trying to make sure that you're being as type safe as you can be, I guess, in that specific example.

00:46:30.200 --> 00:46:30.860
Yeah, it makes a lot of sense.

00:46:31.140 --> 00:46:37.880
I do feel like there's a lot of stuff geared towards, well, it could be anything, right?

00:46:38.300 --> 00:46:39.080
It's a dictionary.

00:46:39.160 --> 00:46:39.500
It could have anything.

00:46:39.680 --> 00:46:40.420
It's a list.

00:46:40.420 --> 00:46:41.940
It could have anything or a set or whatever.

00:46:42.520 --> 00:46:49.320
I might just put three customers, a shopping cart object, and a couple of integers into a list.

00:46:49.450 --> 00:46:51.420
Like it's totally possible.

00:46:51.440 --> 00:46:57.220
You can do that if you type your list, you know, at the start.

00:46:58.180 --> 00:47:04.380
But I think, you know, there's a lot of talk about like how this is an advantage and it's a thing that you want to keep the flexibility.

00:47:04.430 --> 00:47:11.900
But I don't know if I've ever seen real code written that does real things that is that flexible.

00:47:12.440 --> 00:47:12.940
You know what I mean?

00:47:14.000 --> 00:47:17.900
You usually want a list of roughly the same types of things.

00:47:19.220 --> 00:47:24.240
Maybe the integers and floats, but they're not completely unrelated almost ever.

00:47:24.430 --> 00:47:26.980
So I feel like that's a pretty fair assumption y'all are making.

00:47:27.640 --> 00:47:36.500
Yeah, and there's, I guess, a third path to doing this inference that's not pinning it based on the first time it's used or just giving up and doing any.

00:47:36.980 --> 00:47:42.960
there's another way where based on what you add to it, you continually modify the type of the list.

00:47:43.260 --> 00:47:47.380
So if you add an int to it and then you add a string, then it becomes a list of int or string.

00:47:47.990 --> 00:47:51.660
And then you get your error when you try to read from the list and use it as an int.

00:47:52.430 --> 00:48:01.560
But then you end up with kind of spooky action at a distance where you're getting your error where you're reading from the list, but you don't know where you put the wrong thing into the list at.

00:48:02.080 --> 00:48:05.180
So where you fix your error is not where your squiggle is.

00:48:05.460 --> 00:48:11.520
So we thought that giving the error when you put things into the list makes the error more easy to fix.

00:48:12.740 --> 00:48:36.560
And I guess if you're also like, if you have a code base where you're trying to sort of gradually add types to, but you want to make sure that it is type safe, then, you know, doing it the way that Pyrefly does, I think is you can have a list where you haven't declared the type from the start, and you can go back and add it later.

00:48:37.200 --> 00:48:46.480
But Pyrefly helps make sure that in the meantime, before you do that, you're not going to break things because we're catching a potential error before it happens.

00:48:47.220 --> 00:48:48.340
Yeah, I like it.

00:48:50.200 --> 00:48:54.340
So let's do a little, I don't know, compare and contrast, if you will.

00:48:54.980 --> 00:48:59.020
I think you've talked a lot about mypy already in terms of the difference of the language server.

00:48:59.700 --> 00:49:07.800
But just in terms of the type checking aspect, What are some of the philosophical differences, say, with mypy versus PowerFly?

00:49:08.040 --> 00:49:11.560
mypy seems quite strict in the way that it works.

00:49:15.120 --> 00:49:21.580
Yeah, I think mypy, I think, does a lot of inference, and in other cases, like this empty container stuff.

00:49:24.860 --> 00:49:33.360
But I think we're actually a little bit more aggressive in terms of inferring some of the types.

00:49:33.480 --> 00:49:52.160
I think, for example, when you construct a class and you aren't able to determine the type of the type parameters based on the arguments you provide to the constructor, we can actually, based on how you use that class later, infer that last type parameter.

00:49:52.720 --> 00:49:56.480
So that's something that I don't think any other type checker does.

00:49:57.180 --> 00:49:59.100
Okay. What about pyrite?

00:50:03.660 --> 00:50:11.060
I think the biggest contrast I could give is the empty container example.

00:50:11.430 --> 00:50:13.400
I don't know if Kyle or Abby have any.

00:50:14.680 --> 00:50:17.900
- No, honestly, all the type checkers blur together a little bit.

00:50:18.060 --> 00:50:18.720
- Yes, I know.

00:50:19.440 --> 00:50:24.000
Until you change them in the editors and then you get new errors, you're like, oh wait, this one does that, okay.

00:50:24.520 --> 00:50:34.220
And then there's also, and like, you can also configure each of them with your own, you know, whatever their defaults are, you can only toggle to whatever the other option is.

00:50:34.520 --> 00:50:35.920
So, yeah.

00:50:36.780 --> 00:50:36.900
Yeah.

00:50:37.080 --> 00:50:40.340
But like, overall, PyRite is like, very good.

00:50:40.660 --> 00:50:42.480
You know, they do a lot of things right.

00:50:42.780 --> 00:50:44.940
So architecturally, we're pretty similar to them, actually.

00:50:45.700 --> 00:50:50.800
Yeah, PyRite, the creator of PyRite actually made a conformance test suite that all type checkers run on.

00:50:51.210 --> 00:50:53.080
So we run PyRiply on that.

00:50:53.280 --> 00:50:54.240
PyRite runs on it.

00:50:54.360 --> 00:50:55.200
PyPy runs on it.

00:50:56.520 --> 00:51:02.320
And the goal is to make all the type checkers behave in a very, very similar way for the unspecified things.

00:51:03.560 --> 00:51:07.520
In practice, there will still be differences in the inference and other things.

00:51:07.760 --> 00:51:15.640
But ideally, if all type errors could give the same output with the same input, it would be much easier to migrate between them.

00:51:16.340 --> 00:51:17.160
Yeah, it definitely would.

00:51:17.620 --> 00:51:20.160
Maybe you can send me the links for the...

00:51:20.180 --> 00:51:21.900
Yeah, yeah, I'll put it in the show notes.

00:51:21.930 --> 00:51:22.380
Yeah, absolutely.

00:51:23.460 --> 00:51:30.080
It's like a reset CSS equivalent to try to get a weird assumption browsers make, both from typing.

00:51:32.620 --> 00:51:34.340
I was going to add one more thing.

00:51:34.500 --> 00:51:37.680
What Pyrefly also gives you is an automatic suppression script.

00:51:38.700 --> 00:51:40.600
Let's say you do switch from a different type checker.

00:51:41.100 --> 00:51:52.460
If you don't want to use our adoption script that will try mimicking the old type checkers config, you can just run this script that will automatically put a type ignore in all of the spots.

00:51:53.320 --> 00:51:54.540
for you to then later fix.

00:51:55.620 --> 00:51:56.360
Oh, interesting. Okay.

00:51:57.740 --> 00:52:10.620
Yeah. Because we know that there's probably people out there that have never used a type checker before, but also a lot of people that maybe already use mypy or PyRite and everyone hates doing migrations

00:52:10.930 --> 00:52:12.520
if it's too much for hassle.

00:52:12.840 --> 00:52:17.920
So we really tried to make that experience as pain-free as we could.

00:52:19.520 --> 00:52:22.360
Yeah, I totally get that. All right.

00:52:22.520 --> 00:52:29.800
So another one that is similar, not the same for sure, comes from Astral, right?

00:52:30.820 --> 00:52:32.280
Written in Ruffed, ty.

00:52:33.210 --> 00:52:36.440
I had Charlie Marsh on the show a month ago or something like that to talk about.

00:52:37.400 --> 00:52:38.880
Maybe a little bit longer, maybe six weeks.

00:52:39.100 --> 00:52:47.140
Him and Carl Meyer on the show to talk about ty and all the stuff it's doing, why it's different.

00:52:49.660 --> 00:52:51.500
Want to maybe compare and contrast that one.

00:52:51.560 --> 00:53:02.020
I know one of the big differences is that ty is based on Salsa, a static analysis tool from the Rust world, and you guys are not.

00:53:02.220 --> 00:53:02.820
But what else?

00:53:05.140 --> 00:53:08.740
Yeah, so I think architecturally that is a major difference.

00:53:09.240 --> 00:53:18.600
And we sort of chose not to use Salsa because we wanted more control over the memory allocation aspect of things.

00:53:18.880 --> 00:53:27.940
I think Salsa, if you're using a framework to handle the core of your type checking, then you kind of give up some of that control.

00:53:29.220 --> 00:53:36.720
Like what we are able to do things like, for example, we don't keep the whole AST in memory during the whole duration of type checking.

00:53:36.850 --> 00:53:41.440
Like we are able to free the memory for the AST as soon as we're done with it.

00:53:41.590 --> 00:53:46.100
And then that keeps our memory from spiking so much during type checking.

00:53:46.360 --> 00:53:50.680
And that's something that we wouldn't have as much control over with Salsa.

00:53:51.760 --> 00:53:56.960
It's like more of a generator-iterator type of pattern instead of just load it all up and process it.

00:53:57.720 --> 00:54:01.320
Yeah, it's sort of like an eager versus lazy thing.

00:54:01.860 --> 00:54:14.040
But I guess in terms of concrete comparisons, so everything I say has to be taken with a grain of salt because both type checkers and alpha, of course, design decisions can change.

00:54:14.620 --> 00:54:19.660
I would say right now, I think we're a bit further along in terms of implementing the typing spec.

00:54:20.880 --> 00:54:28.180
I think in terms of typing, the number of fully passing typing conformance cases, we're actually higher than mypy now.

00:54:29.920 --> 00:54:43.100
But ty has, I think, done a lot of very interesting things related to gradual typing and sort of pioneering the representation of intersection and negation types, which are not part of the typing specification.

00:54:43.580 --> 00:54:50.080
So I think there's just sort of like each type checker is like sort of ahead in different areas right now.

00:54:51.280 --> 00:54:53.080
Yeah, both very interesting indeed.

00:54:54.900 --> 00:54:58.500
So one thing I think might be fun to close this out.

00:54:58.500 --> 00:55:00.100
Well, a couple of things for sure.

00:55:00.150 --> 00:55:10.800
But one thing I think that people don't often, at least a year or two ago, they didn't really think about a benefit of typing.

00:55:12.400 --> 00:55:19.600
this originally manifests itself in like printed words or out of context information about the code, right?

00:55:19.710 --> 00:55:27.680
So if I'm doing a blog post and I've got a function, I write as a, look, here's a little thing we're doing and it doesn't have any types.

00:55:28.390 --> 00:55:31.960
We don't have necessarily how it's used and you don't have a lot of information.

00:55:32.980 --> 00:55:39.340
The 2025 equivalent of that is maybe AI coding agents, right?

00:55:39.420 --> 00:55:42.440
I want to say, here's what I'm working on. Help me.

00:55:42.660 --> 00:55:43.780
Somehow, didn't we?

00:55:44.320 --> 00:55:45.560
We had to. We had to.

00:55:45.900 --> 00:55:48.920
And so it's like, here's some Python code. Help me do this thing.

00:55:49.660 --> 00:55:57.260
If there is typing on that code, I think the AI agents have a much better chance at getting it right.

00:55:57.520 --> 00:55:59.800
Like, oh, that's an integer. That means this.

00:56:00.220 --> 00:56:07.560
And if that information is missing, well, it just has more work to figure out if it ever can possibly figure it out.

00:56:07.640 --> 00:56:24.360
So what do you all think about the benefits of typing, not for consistency of people, not for reading printed non-IDE code, but for actually this weird, bizarre and kind of amazing time we live in now with AI?

00:56:25.820 --> 00:56:36.200
Yeah, I mean, I think, I mean, I can just give you like one example of how like it helps me in my sort of daily development life.

00:56:36.440 --> 00:56:44.540
And I, you know, I will put my hands up and say I use AI assisted coding tools all the time.

00:56:44.740 --> 00:56:45.940
It saves me so much time.

00:56:47.340 --> 00:56:49.260
It's yeah, it's a huge time saver.

00:56:49.340 --> 00:56:51.760
And I'm really enjoying using them.

00:56:53.180 --> 00:57:01.240
One thing that I will do a lot is some of these AI tools you can, you know, have directly in your IDE.

00:57:01.720 --> 00:57:05.460
You can write the function signature and the doc string.

00:57:05.680 --> 00:57:09.400
And then you could just ask the AI to like fill in the rest of the code for me.

00:57:10.260 --> 00:57:18.180
It is so much, I will get a much better result if I add type annotations to my function signature.

00:57:18.660 --> 00:57:27.840
And then the whatever AI tool I'm using can use that function signature and know, oh, it needs to take in an int, but it needs to return a string.

00:57:28.380 --> 00:57:37.960
And it's a really small change that I can make and how I'm just writing the first part of that code that gives me a much better result

00:57:38.160 --> 00:57:39.620
from what the AI spits out at me.

00:57:39.740 --> 00:57:41.680
So that's one very tangible example

00:57:41.820 --> 00:57:50.380
of how typed Python, I think, is valuable in this new world of vibe coding that we're living in.

00:57:51.900 --> 00:57:54.400
Yeah, I don't know, Danny or Kyle, if you have more to add.

00:57:55.440 --> 00:58:00.560
Yeah, I definitely think Like, a lot of models are not good at keeping a ton of context.

00:58:00.740 --> 00:58:03.020
They can't keep a whole code based in the context.

00:58:03.540 --> 00:58:22.380
So if a type checker or even an LSP that can find the definition of stuff, find references, if it can just provide a little summary with some more information closer to the model, like, that I think is huge for the model being able to produce a correct result.

00:58:22.740 --> 00:58:35.740
And then on the other side, you have the, like, is a correct question, which I think these tools will become even more important in if we have agents that do things without users necessarily.

00:58:36.280 --> 00:58:36.780
Right, right.

00:58:37.000 --> 00:58:38.900
Then you kind of want to say, does this code hang together

00:58:39.540 --> 00:58:41.000
from this piece to this piece to this piece,

00:58:41.070 --> 00:58:43.200
or this job to that job?

00:58:43.350 --> 00:58:43.460
Yeah.

00:58:44.080 --> 00:58:44.180
Danny?

00:58:44.260 --> 00:58:44.400
Yeah.

00:58:44.720 --> 00:58:57.780
And I guess to piggyback off of that, type checkers are pretty valuable as both tools for coding agents to use and for graders to evaluate the finished work.

00:58:58.140 --> 00:59:08.200
So I guess having a type checker that runs quickly, of course, is very valuable because these agentic coding loops already take a really long time.

00:59:08.360 --> 00:59:13.260
Sometimes you set the AI going, you go get coffee or you eat lunch, and then you come

00:59:13.420 --> 00:59:14.920
back and check for it.

00:59:15.020 --> 00:59:17.640
So anything that can make it work faster is valuable.

00:59:17.980 --> 00:59:23.720
But also, I think grading the LLM-generated work is very important.

00:59:25.260 --> 00:59:32.900
One concrete example I can give is that at Meta, we do these things called code mods, which are sort of automated refactors.

00:59:33.120 --> 00:59:39.520
Imagine you have your 20 million line code base, and you need to upgrade an old API to a new API.

00:59:41.380 --> 00:59:44.000
And there's like 20,000 call sites.

00:59:44.340 --> 00:59:48.640
Like doing that by hand is not, you know, not really a good use of engineering time.

00:59:49.140 --> 00:59:58.900
So you normally would write like maybe a complicated AST based transformation, but not everything can be expressed in a simple like AST mapping.

00:59:59.560 --> 01:00:01.880
And like, maybe you want something that's a bit smarter.

01:00:02.160 --> 01:00:15.700
So then LLMs have unlocked a lot of like, you know, fancier types of refactoring, like maybe a simple example that I can give is I did recently did one where we were just eliminating redundant casts.

01:00:15.900 --> 01:00:19.460
So we're looking at where we're getting redundant cast warnings from the type checker.

01:00:20.020 --> 01:00:22.460
We're getting rid of the cast and then cleaning up the imports.

01:00:23.220 --> 01:00:34.560
And if you're casting like the variable you're casting and the variable you're casting to were both named X, then it would just clean it up entirely, things like that.

01:00:34.840 --> 01:00:36.800
That would be a very...

01:00:37.340 --> 01:00:40.680
It's doable, but fairly complicated to write as AST transformation.

01:00:42.240 --> 01:00:52.260
So sort of having the LLM do that and then having and running a type checker on the results to make sure that the LLM didn't like, you know, remove an import it wasn't supposed to remove.

01:00:52.420 --> 01:01:03.260
It didn't like break anything else in the code. It didn't like introduce a new type checker like suppression when it wasn't supposed to. Things like that are has been very valuable.

01:01:04.160 --> 01:01:05.560
Yeah, that's an awesome example.

01:01:06.200 --> 01:01:09.560
I definitely have in rules files for agentic agents.

01:01:09.590 --> 01:01:14.200
For me, I have things like, make sure that you run the linter on anything that you edit.

01:01:14.700 --> 01:01:16.800
And then if there's a problem, you need to go fix that.

01:01:16.960 --> 01:01:20.060
Like, don't just leave it there, you know, and type checking and things like that.

01:01:20.260 --> 01:01:26.160
I usually add a line, run firefly, and make sure that it's got all the right types.

01:01:26.700 --> 01:01:28.840
Yeah, I think that might be one of my new lines as well.

01:01:28.940 --> 01:01:29.680
That's going to be pretty cool.

01:01:32.580 --> 01:01:34.940
Okay, so let's wrap this up.

01:01:35.100 --> 01:01:38.820
Let's just maybe give people a sense of where you're going.

01:01:39.000 --> 01:01:42.360
I know if I go, like I said, there was a brand new release today, which is awesome.

01:01:43.800 --> 01:01:46.740
But this is still status alpha.

01:01:47.840 --> 01:01:49.240
Only the brave shall go here.

01:01:52.640 --> 01:01:53.740
What's coming soon?

01:01:54.160 --> 01:01:55.260
What could people look forward to?

01:01:58.060 --> 01:01:59.000
All the things.

01:01:59.420 --> 01:02:00.020
So many things.

01:02:02.020 --> 01:02:07.020
So I think we mentioned already that we do releases every week.

01:02:08.040 --> 01:02:15.540
We have, I think we have milestones as well in our GitHub so people can keep an eye out for things that are coming up.

01:02:16.859 --> 01:02:27.600
We, right now, it's a lot of like trying to fix a lot of bugs that are coming up as any alpha product has.

01:02:28.000 --> 01:02:33.120
We want to make sure that, you know, the type checking side of stuff is type checking stuff correctly.

01:02:35.040 --> 01:02:44.100
And we also really want to, actually, maybe Danny or Kyle, do you have any things to add to that of like big things that are coming that people should watch out for?

01:02:46.540 --> 01:02:46.920
Big areas.

01:02:46.920 --> 01:02:52.940
I would say at this stage, the alpha label probably only applies to the type checking side of things.

01:02:53.120 --> 01:02:56.360
Like I think our IDE is like pretty solid and ready.

01:02:56.380 --> 01:02:57.300
Pretty robust, yeah.

01:02:58.560 --> 01:03:04.800
I would say something to look forward to, I guess, is the type checker in a good enough state to use in production.

01:03:05.120 --> 01:03:12.640
I think right now people could be trying the IDE extension and changing it to beta.

01:03:13.000 --> 01:03:19.160
So we thought about calling something a beta, and I don't remember what the conclusion was.

01:03:19.260 --> 01:03:26.460
I think the more of these intermediate not done steps we have, at what point is it ready for production use?

01:03:26.580 --> 01:03:28.520
And I think we want to wait until it's production ready.

01:03:28.840 --> 01:03:29.840
We're going to call it V1.

01:03:30.240 --> 01:03:33.040
We're going to say the type checker will be good enough for everything.

01:03:33.980 --> 01:03:38.160
Like we said earlier right now, the IDE is used by every single Instagram employee.

01:03:39.440 --> 01:03:40.200
If it works for them.

01:03:40.320 --> 01:03:43.180
- And it's used at like mega scale with that much code.

01:03:43.360 --> 01:03:45.380
It's not just used a little bit, right?

01:03:45.480 --> 01:03:46.360
That's a serious test.

01:03:47.780 --> 01:03:48.080
- Yeah.

01:03:49.000 --> 01:03:49.360
- Yeah.

01:03:49.360 --> 01:03:51.280
- I updated it for you here on the website.

01:03:51.330 --> 01:03:51.760
I fixed it.

01:03:55.180 --> 01:03:58.080
You could just replace me as the developer advocate.

01:03:58.700 --> 01:03:59.100
There you go.

01:04:01.640 --> 01:04:08.760
So what are we looking at in terms of time frame before it maybe gets a little farther?

01:04:08.900 --> 01:04:13.140
Although it sounds like the VS Code side of LSP things maybe is good to go.

01:04:13.860 --> 01:04:19.960
Yeah, IDE side of stuff, like definitely people should feel confident to go and start using straight away.

01:04:20.800 --> 01:04:36.100
But the type checking side of things, I think it's going to depend on how fast we can get through the backlog of bugs and also how many new critical bugs come up.

01:04:36.760 --> 01:04:40.900
I don't think we have a solid timeline yet for when we want to reach V1.

01:04:41.640 --> 01:04:53.040
But maybe this is actually a good time for us to invite anyone who's listening to this right now to definitely go and give Pyrefly a try.

01:04:53.860 --> 01:05:04.720
And because we are still in this alpha phase, it now, you know, is a super critical time for us to get feedback from people that are using this.

01:05:06.020 --> 01:05:08.780
You know, what are the critical issues that we need to fix?

01:05:09.120 --> 01:05:14.900
Or what are some of the defaults that, you know, don't do make sense or don't make sense for you?

01:05:16.160 --> 01:05:20.600
Right now, everything is, you know, sort of up for discussion and debate.

01:05:20.980 --> 01:05:22.980
And people can open issues in our GitHub.

01:05:23.300 --> 01:05:24.720
People can come talk to us on Discord.

01:05:25.440 --> 01:05:27.580
We have office hours every fortnight.

01:05:29.260 --> 01:05:30.500
Bi-weekly for the Americans.

01:05:32.700 --> 01:05:47.140
And yeah, we don't want to commit to a solid V1 date yet until we feel, I think, a bit more confident that the type checking capabilities are really, really robust and where they need to be.

01:05:47.200 --> 01:05:50.860
And a lot of that, you know, that's why we're open source, right?

01:05:51.020 --> 01:05:55.840
Like we really need the community to help us get there.

01:05:56.900 --> 01:05:58.080
Yeah. Sounds great.

01:05:59.440 --> 01:06:08.660
Yeah, I guess, I mean, I think on our repository, readme, it says that we are planning to replace Pyre in CI by the end of this year.

01:06:08.810 --> 01:06:12.860
And I think we are still, you know, on track towards that.

01:06:13.100 --> 01:06:16.920
But it's not necessarily to say that by the end of the year, everything will be perfect.

01:06:17.110 --> 01:06:24.460
I think there, even on the IDE side, we're missing some like refactoring related features that are not like code navigation related, I think.

01:06:25.160 --> 01:06:30.500
And, you know, obviously quality of life things can also, we can also work on.

01:06:31.010 --> 01:06:41.200
And for type checking, there's like a handful of, you know, larger features that we, or like larger sort of areas that we still need to be able to, we need to understand a bit better.

01:06:41.660 --> 01:06:48.800
So, but it's like, I feel like the, in terms of like major things left to do, like the end is, you know, insight.

01:06:49.800 --> 01:06:49.880
Yeah.

01:06:50.170 --> 01:06:50.620
Oh, awesome.

01:06:51.020 --> 01:06:51.280
Congratulations.

01:06:52.280 --> 01:06:52.960
So how about this?

01:06:53.020 --> 01:07:01.360
if somebody tries it on their project and they're pretty happy with the way it's working, maybe they could use it in CI, but if they try it and they don't like it, maybe just wait.

01:07:01.860 --> 01:07:21.100
That seemed like a good advice. Yeah. Like I wouldn't like try it today and then, you know, find an issue and then think you'll never want to use Firefly ever into life. You know, it is, it is still an alpha as we said. So, you know, check back in, you know, next week, who knows, your bug could be fixed by then.

01:07:22.440 --> 01:07:25.780
So yeah, give us your feedback.

01:07:26.620 --> 01:07:27.440
It's open source.

01:07:27.630 --> 01:07:30.940
You could find the issue on GitHub and click the watch button.

01:07:31.880 --> 01:07:32.060
Exactly.

01:07:33.100 --> 01:07:35.980
Yeah, give it a spin in your VS Code, you know, report bugs.

01:07:36.980 --> 01:07:41.760
Join our Discord if you, you know, want to just chat with the dev team or want help setting things up.

01:07:41.890 --> 01:07:44.560
Like we have a, we're pretty active on Discord right now.

01:07:45.020 --> 01:07:45.680
Yeah, fantastic.

01:07:47.040 --> 01:07:47.340
All right.

01:07:47.760 --> 01:07:49.580
Well, let's leave it there then.

01:07:50.710 --> 01:07:53.140
Kyle, Danny, and Abby, thank you all for being on the show.

01:07:53.150 --> 01:07:53.640
It was really great.

01:07:54.660 --> 01:07:54.900
Thank you.

01:07:55.080 --> 01:07:55.640
Thanks for having us.

01:07:56.380 --> 01:07:56.980
Yeah, you bet.

