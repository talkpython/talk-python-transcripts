WEBVTT

00:00:00.680 --> 00:00:03.540
MATT BONGIOVI: Matt, great to have you back on the show.

00:00:04.000 --> 00:00:05.000
Welcome back to Talk Python To Me.

00:00:05.360 --> 00:00:06.260
MATT BONGIOVI: Thanks, Michael.

00:00:06.520 --> 00:00:07.440
Been a little while.

00:00:07.620 --> 00:00:08.040
Good to be back.

00:00:08.540 --> 00:00:10.040
MATT BONGIOVI: It has been a little while.

00:00:10.540 --> 00:00:22.740
As I was entering your show details into the back end system for Talk Python to say what episodes are coming up in what order and so on, I have to enter the guest ID into that thing.

00:00:23.180 --> 00:00:26.600
Yes, it could be a drop down list, but then there's so much scrolling, I just can't do it.

00:00:28.220 --> 00:00:28.920
And it's multi-select.

00:00:29.620 --> 00:00:31.480
So your guest ID is 29.

00:00:32.540 --> 00:00:41.880
We first did an episode together about Full Stack Python when I was sitting on the couch in Stuttgart, Germany, back when I lived there.

00:00:41.880 --> 00:00:42.480
How about that?

00:00:42.660 --> 00:00:42.800
Wow.

00:00:43.540 --> 00:00:43.720
All right.

00:00:43.780 --> 00:00:44.620
Yeah, it's been a while.

00:00:45.600 --> 00:00:52.200
I feel like that's like that credibility, you have that like only a double digit guest ID.

00:00:52.580 --> 00:00:53.060
Exactly.

00:00:53.560 --> 00:00:55.600
That's a low double digits, yes.

00:00:56.800 --> 00:00:59.860
It's like a pro number in racing or something, indeed.

00:01:02.040 --> 00:01:03.900
Well, that was the past.

00:01:04.400 --> 00:01:06.520
We talked about some awesome things then.

00:01:07.460 --> 00:01:12.880
The idea of Full Stack Python, I believe, was a lot of the focus, but it's honestly been 10 years.

00:01:12.880 --> 00:01:15.280
I don't remember exactly what we covered in detail.

00:01:15.740 --> 00:01:21.000
However, I can tell you, this is definitely not a backward-looking episode.

00:01:21.640 --> 00:01:22.680
This is cutting-edge stuff.

00:01:23.780 --> 00:01:24.140
Yeah.

00:01:24.780 --> 00:01:28.220
I mean, so much of this has changed over even three months.

00:01:28.510 --> 00:01:39.520
I mean, we'll talk about it all, but there's like the philosophy behind all this, the holy religious wars around what developers should be doing with it.

00:01:40.640 --> 00:01:43.640
And then let's dig into the details because that's the fun stuff.

00:01:44.380 --> 00:01:44.900
Absolutely.

00:01:45.310 --> 00:01:45.440
Absolutely.

00:01:47.420 --> 00:01:53.980
I would say it's certainly one of the most controversial topics in dev space these days.

00:01:55.380 --> 00:02:05.420
Well, it's almost like, if you remember when Django and Ruby on Rails came out, and they were the new frameworks, even before all the JavaScript frameworks and everything like that.

00:02:05.420 --> 00:02:09.899
It was back-end server, server-side code, and you could do so much more.

00:02:09.990 --> 00:02:13.240
I remember, this was back when I was an early professional developer.

00:02:13.390 --> 00:02:20.640
I was working in Java with servlets in a framework called Tapestry, and everything was so hard to do.

00:02:20.770 --> 00:02:22.480
And they tried to add so many layers of abstraction.

00:02:22.760 --> 00:02:25.300
It was like peak enterprise Java development.

00:02:25.320 --> 00:02:27.900
How many layers of dependency injection were up for me?

00:02:27.900 --> 00:02:28.080
Oh, yeah.

00:02:28.380 --> 00:02:31.660
And so then I would go home and I'm like learning Django.

00:02:31.720 --> 00:02:40.060
And I was like, I can't believe how much more I can get done in an hour than I did eight, nine, ten hours a day working in the Java code.

00:02:40.420 --> 00:02:48.900
Not because there's literally nothing wrong with Java, but it was just that the frameworks were so well built for what we were trying to do.

00:02:49.560 --> 00:02:57.140
So that's the only parallel I personally have to like what is happening right now, which and this is like 10x, 100x of what that is.

00:02:57.200 --> 00:03:06.100
It's like if you use the tools properly for the right purposes at the right time period, because like a year ago versus today is very different.

00:03:06.960 --> 00:03:08.980
You can be wildly more productive.

00:03:10.100 --> 00:03:17.000
There's also the downsides, but there is substantial improvement to be had in certain areas of software development.

00:03:17.200 --> 00:03:22.040
And I feel like that is actually really the big takeaway.

00:03:23.030 --> 00:03:24.440
Among all the hype, break everything out.

00:03:24.540 --> 00:03:35.220
It's like there's tactical things you can use this, agentic tools for LLMs that will 10x, 100x certain things that are super annoying about software development right now

00:03:35.550 --> 00:03:37.180
in a way that was previously impossible.

00:03:37.980 --> 00:03:39.680
Right. Summarize my architecture.

00:03:40.860 --> 00:03:42.460
Have you tried that compared to like,

00:03:42.740 --> 00:03:44.240
I have 100,000 lines of code

00:03:44.310 --> 00:03:48.660
and I've got to like study the crap out of it figure out what piece connects to what.

00:03:49.140 --> 00:03:51.040
I love the roast my code.

00:03:51.660 --> 00:03:54.880
Like, don't just tell me about it.

00:03:55.080 --> 00:03:56.760
Like, give it to me straight here.

00:03:57.020 --> 00:03:59.900
Like, how could this function be improved?

00:04:00.420 --> 00:04:00.920
Roast it?

00:04:01.320 --> 00:04:01.440
Okay.

00:04:01.840 --> 00:04:03.500
Now tell me how I can improve it.

00:04:03.740 --> 00:04:03.960
Okay.

00:04:05.520 --> 00:04:09.620
And at the end, just give me a little bit of like ego boost because I need it after all the roasting.

00:04:10.440 --> 00:04:11.140
Yes, exactly.

00:04:11.900 --> 00:04:13.100
Put that in your cursor rules file.

00:04:13.340 --> 00:04:16.140
Anytime you talk me down, just include a little,

00:04:16.260 --> 00:04:21.920
little spirit lifting comment as well well the best the best part is like okay roast me okay if

00:04:21.959 --> 00:04:45.400
you're so smart go fix it for me yeah you're like oh that's right it did work sometimes it does actually which is sometimes which is insane yeah i think probably the best way i could say we should frame people should frame this conversation to at least to get started with in their mind is a balanced take, right?

00:04:45.720 --> 00:04:54.040
It's not necessarily vibe coding, while that's hilarious and has spawned many amazing YouTube videos, right?

00:04:57.280 --> 00:05:12.360
But it's also, it doesn't necessarily make sense to imagine that these tools don't exist and just out of principle say, well, I'm never going to touch them because I'm not going to replace coders with this.

00:05:14.120 --> 00:05:18.280
It's like saying, I was just playing a bunch with rough, the formatting tool, right?

00:05:19.479 --> 00:05:24.700
And it's ripping through 500 files at a time on these projects I'm working on.

00:05:25.260 --> 00:05:30.000
Rough format, rough check fix, bam, 37 files repaired.

00:05:31.500 --> 00:05:36.900
I could have done that by hand and flexed my dev skills, but should I?

00:05:37.140 --> 00:05:38.140
No, of course I shouldn't.

00:05:38.260 --> 00:05:38.640
It takes microseconds.

00:05:38.640 --> 00:05:40.180
- That's the best use of your time.

00:05:40.360 --> 00:05:42.000
- It certainly does not.

00:05:42.200 --> 00:05:48.000
And so if these tools exist, well then I think it comes down to like, well, what is the right way to use them?

00:05:48.320 --> 00:05:49.200
How do they go well?

00:05:49.230 --> 00:05:50.060
How do they go poorly?

00:05:51.440 --> 00:05:52.380
Are they too expensive?

00:05:52.960 --> 00:05:53.420
- That's spot on.

00:05:53.560 --> 00:06:07.000
I mean, what I find fascinating about this shift is like most professional developers have spent their entire adult lives just like learning new technologies.

00:06:08.160 --> 00:06:09.920
I actually don't know why this is any different.

00:06:10.800 --> 00:06:19.000
Like the whole point of being a developer is like keeping an open mind and open philosophy of like, what can I learn?

00:06:19.420 --> 00:06:20.560
How should I be learning?

00:06:21.380 --> 00:06:34.060
Just that is what appeals to me so much about being a software developer is like this, this mindset of I go into this year, not even knowing what tools I may be using by the end of the year, because they may not exist yet.

00:06:34.780 --> 00:06:35.940
And I want to go learn them.

00:06:36.320 --> 00:06:42.440
And some of them I'm going to throw immediately in the wastebasket and other ones are going to stick with me for potentially decades.

00:06:43.800 --> 00:07:03.680
And in fact, like I, when it comes to LLMs, like I had put out like a post on X and I was like, I feel like Olama is one of those tools that I've added to my tool belt, like Django or Vim or Tmux that will be with me potentially for a couple of decades because it is just so straightforward.

00:07:04.200 --> 00:07:07.300
and it makes it so easy to use these open-weighted models.

00:07:08.100 --> 00:07:09.920
And so that's incredible.

00:07:10.620 --> 00:07:13.300
18 months ago, I hadn't even heard of this tool.

00:07:13.580 --> 00:07:16.680
And actually, it didn't exist before, I don't know, 18, 24 months ago.

00:07:17.240 --> 00:07:19.780
And here's something that I'm like, wow, this is going to stick with me.

00:07:19.940 --> 00:07:24.980
So I think that's what's maybe getting lost in a little bit of the hype cycle is we're developers.

00:07:25.480 --> 00:07:26.780
All we do is learn new stuff.

00:07:26.960 --> 00:07:30.840
Why is this any different from learning an open source project that you just found on GitHub?

00:07:31.980 --> 00:07:32.380
100%.

00:07:33.760 --> 00:07:34.160
100%.

00:07:35.040 --> 00:07:37.480
I'm definitely here with you on that.

00:07:37.700 --> 00:07:44.360
I'd see in other areas like education, I see it, you know, like write this essay for me.

00:07:45.280 --> 00:07:48.980
That's very problematic if you're in 10th grade and you're supposed to learn how to write an essay.

00:07:49.980 --> 00:07:53.860
But your job is to create software that works, add features, make it awesome.

00:07:54.780 --> 00:07:56.160
Like there's not a test.

00:07:56.840 --> 00:07:56.940
Yeah.

00:07:57.700 --> 00:07:59.040
Well, and I think other than shipping.

00:07:59.880 --> 00:08:08.380
Anyone who's used these tools, if you are legitimately using them to build software, you will definitely not be at all concerned of software development jobs going away.

00:08:09.160 --> 00:08:11.940
There's so many things that these tools do not do right.

00:08:12.360 --> 00:08:18.300
And unless you are an experienced software developer and understand those nuances, you can very quickly get into that.

00:08:18.360 --> 00:08:28.240
I don't know if they call it the wall of despair, or there's different hit of despair phrases that people have had where you're kind of building something and all of a sudden the LLM goes in a direction.

00:08:29.760 --> 00:08:36.020
If you're not a senior enough developer, you're not experienced enough, or you're not willing to dig deep enough, you suddenly are stopped.

00:08:36.440 --> 00:08:37.599
There's nothing you can do from there.

00:08:37.630 --> 00:08:39.280
You're like, no, fix it, fix it.

00:08:39.289 --> 00:08:41.320
It doesn't matter how many times you tell the LOM to fix it

00:08:41.320 --> 00:08:42.060
or the tool to fix it.

00:08:42.169 --> 00:08:43.140
Please, or you go to jail.

00:08:43.320 --> 00:08:44.320
Yeah, exactly.

00:08:44.820 --> 00:08:46.840
Yes, there's people on the train tracks.

00:08:47.010 --> 00:08:48.200
You must fix this right now.

00:08:49.120 --> 00:08:49.360
Exactly.

00:08:49.690 --> 00:08:51.260
My grandma's life depends upon it.

00:08:51.580 --> 00:08:51.720
Right.

00:08:51.730 --> 00:08:53.420
You've got to make this database query work.

00:08:53.720 --> 00:08:53.860
Yeah.

00:08:55.140 --> 00:09:35.660
I think, you know, one thing that maybe is preventing people from embracing some of this stuff is I actually don't even think that a lot of the terminology is clear. So if you'll allow me to be pedantic for a minute, I actually think that this is often the most insightful thing that I work with people on or tell people about, which is just like, what is the difference between an AI model, an LLM, an AI agent, and some of these other things? Because actually, people use these interchangeably. People Like these are not drop and replace terminology for each other.

00:09:35.740 --> 00:09:36.900
They have very specific meanings.

00:09:37.060 --> 00:09:44.620
And I think particularly when I've seen like kind of the traditional software companies try to all of a sudden AI all the things.

00:09:45.380 --> 00:09:59.300
This is part of why developers get so annoyed with the AI ecosystem, because it's like it's like saying, you know, Django is not you wouldn't say web framework, you would say like, oh, it's an AI agent coding tool.

00:09:59.380 --> 00:10:00.180
It's like, no, it's not.

00:10:00.400 --> 00:10:02.840
What are you talking about? Immediately lose your credibility, right?

00:10:03.180 --> 00:10:07.760
It's an AI generative web framework builder.

00:10:07.790 --> 00:10:15.480
Right. Thank goodness it's not. Thank goodness Django, the creators and the maintainers know what they're good at.

00:10:15.480 --> 00:10:18.180
And they're not trying to be a part of the hype cycle.

00:10:19.260 --> 00:10:26.180
Ironically, I think Simon Wilson, one of the original Django folks, is one of the leading people in AI.

00:10:27.140 --> 00:10:28.660
I've learned so much from his writing.

00:10:28.750 --> 00:10:29.740
Yeah, absolutely. It's amazing.

00:10:29.900 --> 00:10:31.580
I actually didn't think that.

00:10:32.660 --> 00:10:32.800
Go ahead.

00:10:32.860 --> 00:10:32.940
Yeah.

00:10:33.290 --> 00:10:35.980
I don't know how, I don't know how, I don't understand how he can be so prolific.

00:10:36.200 --> 00:10:36.940
He's incredible.

00:10:37.280 --> 00:10:45.240
Like he's, he's just like a true gift to software development, having been on the leading edge of so many things.

00:10:45.460 --> 00:10:45.760
It's amazing.

00:10:46.500 --> 00:10:47.220
Yeah, absolutely.

00:10:47.820 --> 00:10:56.460
So if I could just lay out real quick, maybe for, for folks, like a, an AI model was an AI model is typically when people are talking about that.

00:10:56.540 --> 00:11:05.200
Now, again, like there can be a little bit of nuance and gray areas with some of these but typically an AI model is something that is trained on some sort of like training set.

00:11:06.100 --> 00:11:13.040
And it's been typically trained on the transformer architecture, which is a fairly recent, you know, last eight years kind of development.

00:11:13.370 --> 00:11:28.940
And so this is really what's allowed the breakthrough when we talk about AI now versus AI, you know, a couple of decades ago when it was like complete AI winter and no one wanted to talk about it, is we've had this breakthrough in architecture and it's not just like one breakthrough.

00:11:29.180 --> 00:11:34.120
It is a tremendous number of breakthroughs around attention and the way that things are weighted and things like that.

00:11:34.260 --> 00:11:37.360
But essentially, like to boil that down is like you have these AI models.

00:11:37.490 --> 00:11:41.580
Now, an AI model is not equivalent to a large language model in LLM.

00:11:42.030 --> 00:11:43.900
An LLM is one type of AI model.

00:11:44.480 --> 00:11:52.780
So when I was at Assembly AI, like they were training or they are training state of the art speech to text models is not an LLM.

00:11:53.340 --> 00:11:57.780
So a lot of times people will say like AI model LLM, but that's not those are not equivalent.

00:11:58.000 --> 00:12:05.380
An AI model is a superset of the subset, which is like an LLM, which is one type of typically working on text modality.

00:12:06.220 --> 00:12:13.600
Although there are things called multimodal models, which could have different image inputs and image outputs and text inputs, text outputs and stuff like that.

00:12:13.700 --> 00:12:19.600
But I think that's one thing where a lot of companies and maybe even developers who are like learning about the space get confused.

00:12:19.700 --> 00:12:22.460
It's like, is an AI model and LLM the exact same thing?

00:12:22.460 --> 00:12:24.700
Like, no, there's a relationship there, but they're not the same.

00:12:25.400 --> 00:12:30.700
So then you have like generative AI, which a lot of companies just kind of like sprinkle that into everything that they talk about.

00:12:30.800 --> 00:12:38.800
It's like generative AI is really using AI models, typically LLMs, but also image generation and some other forms to create some sort of output.

00:12:39.300 --> 00:12:41.780
So it's the generative component of it.

00:12:42.260 --> 00:12:47.340
So you have some sort of input and then there's a non-deterministic set of outputs that come out the other side.

00:12:47.340 --> 00:12:52.260
So it'll be, for example, like draw me a red dragon breathing fire for the image generation.

00:12:52.620 --> 00:12:58.520
And that generative AI is basically using an AI model to produce that image out the other side.

00:12:59.020 --> 00:13:01.400
So those are some of the common terms.

00:13:01.600 --> 00:13:11.800
And then you have AI agents, which is a lot of what we talk about or we're going to talk about, which is it is using typically an LLM, but it's typically using some sort of AI model.

00:13:12.600 --> 00:13:14.640
And that is kind of almost think about it as like the core.

00:13:15.220 --> 00:13:18.960
There's inputs into the system and non-deterministic outputs that come out the other side.

00:13:19.080 --> 00:13:25.160
So you'll say something like, write me a bunch of unit tests and in Cloud Code or in Cursor or in WindSurf.

00:13:25.740 --> 00:13:31.800
And then it will interpret those inputs and then produce code or some sort of output out the other side.

00:13:32.040 --> 00:13:36.800
So I think for developers who are trying to get into, you know, how do I even understand kind of the AI space?

00:13:37.140 --> 00:13:39.260
It's actually really important to get that terminology correct.

00:13:39.360 --> 00:13:47.720
Because otherwise, you won't even know when you're reading, like, particularly for companies or people that aren't as familiar with the space.

00:13:48.760 --> 00:13:50.640
what they're even talking about.

00:13:51.050 --> 00:13:52.200
So I always like to kind of frame that conversation.

00:13:52.200 --> 00:14:00.180
Because a lot of the companies, yeah, their job, it's to their benefit to obscure and make it just seem like it's everything you're seeing.

00:14:00.860 --> 00:14:01.080
Totally.

00:14:01.420 --> 00:14:09.560
There's financial incentives by some companies to obscure what they're doing and make it seem much more complicated so that they can sell this solution.

00:14:09.730 --> 00:14:15.060
Oh, it takes this really complicated problem and streamlines it down to some sort of simple solution.

00:14:15.090 --> 00:14:17.500
And that's often not the case.

00:14:17.720 --> 00:14:21.540
When you peel it back as a developer, you're not really doing that.

00:14:22.480 --> 00:14:31.400
So I think that's often where I think a lot of developers get frustrated with the current state of the industry because you're like, no, it's not what you're doing.

00:14:32.420 --> 00:14:33.920
You're not doing generative AI.

00:14:34.120 --> 00:14:35.560
You're not doing actual agents.

00:14:36.820 --> 00:14:39.920
And then there's autonomous agents, which are operating independently.

00:14:40.280 --> 00:14:49.480
So that's one thing I think developers can take away from the conversation is just like, is the company accurately describing what they are doing?

00:14:49.880 --> 00:14:51.700
Yeah, I 100% agree.

00:14:53.399 --> 00:14:58.580
And let me do a little sidebar rant and I'd love to get your thoughts on this.

00:14:58.630 --> 00:14:58.760
Yeah.

00:14:58.760 --> 00:14:59.260
Yeah.

00:14:59.610 --> 00:15:05.980
So when I hear people say, I've tried AI, it's a bunch of AI slop.

00:15:06.050 --> 00:15:07.680
It just makes up a bunch of mistakes.

00:15:09.680 --> 00:15:18.620
I noticed a couple of things that are often the case when I hear those and have people avoid that, right?

00:15:18.910 --> 00:15:23.700
So one, a lot of times I feel like people are not getting the best experience.

00:15:23.890 --> 00:15:26.280
They say, like, I tried this. It really wasn't for me.

00:15:26.880 --> 00:15:29.360
It just messes up more than it provides.

00:15:29.830 --> 00:15:34.220
They're using the cheapest free models that they can find, right?

00:15:34.900 --> 00:15:48.820
If you use Cloud's Opus model versus some free model, like a 3 billion parameter local model, they're not even in the same category.

00:15:49.050 --> 00:15:54.120
The type of accuracy and insight and the context.

00:15:54.120 --> 00:15:58.560
Do they understand everything rather than, well, they only understand the last file they read.

00:15:59.860 --> 00:16:02.180
That is one half of the problem.

00:16:03.360 --> 00:17:10.360
And then I think the other for people who are not being successful yet with this kind of stuff, it has to do with not providing enough information and context and stuff in the prompt. So I'll see like, oh, refactor this function. It's like, well, hold on. What, where, where do you even want it to go? Right? It's just going to like start randomly doing stuff. Here's a function. It is similar to these. And I need to move this to this kind of design pattern, keeping in mind that I'm using this ORM and like give it like the same amount of description you would to a junior developer who's not super familiar with your project so you want to give that thing like a possibly a multi-page write-up of what it needs to do and then ask it to plan it out and then start working through the plan not just refactor to be you know yeah did you do this or whatever and I I think those two things are both problems, they often go together because the cheaper models can't accept that kind of information and keep it working. Right? Yes. What do you think about that? I mean, I totally

00:17:10.560 --> 00:17:16.140
agree. I think also to like, these models, you cannot just like mix and match and replace things.

00:17:16.699 --> 00:18:01.540
So like, you may have an experience with one model and also recognize that these models, even though you know, Claude for Opus is the name public name of that model, they are tweaking and tuning that model in the back end to figure out how they can more, maybe not profitably, but serve this model up at scale in a window of resources. So even within a given model, unless it is an open weighted model that you've downloaded, if you have under complete control, these models are changing over time. So this is like a, I think that's actually been one of the most concerning parts for me as a, as a developer. I was like, what if I rely on a tool and it changes and I wake up one day.

00:18:01.630 --> 00:18:04.720
The tests passed last week. They don't pass this week. I have no control or visibility.

00:18:04.860 --> 00:18:09.400
I was productive last week or I was productive yesterday and I can no longer be productive today.

00:18:10.440 --> 00:18:25.260
And that's setting aside downtime or API stuff. Right. So I think the thing is, is like, that's why I very much appreciate the vibe check, the whole concept of a vibe check, which is you get a new model or get access to a new API.

00:18:25.900 --> 00:18:28.620
And what are the individual components that you want to test?

00:18:29.040 --> 00:18:33.900
So even to your example of refactor, here's the ORM, that sort of thing.

00:18:34.200 --> 00:18:36.240
I started very...

00:18:36.460 --> 00:18:38.760
When I have a model, and I use a lot of Cloud Code.

00:18:38.800 --> 00:18:41.560
I use a lot of Opus and so on now, but I'm sure this will evolve.

00:18:41.700 --> 00:18:44.400
I would love to try it with some open-weighted models soon.

00:18:45.000 --> 00:18:57.540
And I will say something like in this URLs.py, because I work a lot with Django on the back end, I'll say update just the-- I'm trying to add a new page.

00:18:58.240 --> 00:18:59.140
It's going to be at this route.

00:18:59.380 --> 00:19:04.060
Here is the-- please update the URLs.py file for me.

00:19:04.320 --> 00:19:05.700
And here's roughly what I expect, right?

00:19:06.000 --> 00:19:07.000
Super specific.

00:19:07.170 --> 00:19:14.200
And if it can't even get that part right, the chances of you saying, OK, now build a new page, now build a new view.

00:19:14.400 --> 00:19:34.140
now do X, Y, and Z are very small. So you kind of have like the smallest unit that you would work with, and then start building up. And it's it is a two way street, like you have to build confidence in that model. Over time, like what are its true capabilities, and I will say like, it's a lot of work. But it's a lot of work being a software developer and learning a new open source project.

00:19:34.540 --> 00:19:44.480
So yeah, it's actually not that different from just like, okay, pip install new library, reading documentation all those things like but it's a different form format of like going back and

00:19:44.570 --> 00:20:08.840
forth with the computer i think it encourages people to be less serious because it feels like a a little little chat a little back and forth just hey i just asked a question it came with a cool answer it doesn't it doesn't speak you need to study this and you need to like really this is a skill it's like it's like i'm having just a chat with like you know someone you know or whatever

00:20:09.480 --> 00:21:19.400
Well, it does open up, even if you set aside code generation, it opens up new capabilities that I would argue are useful for every single developer regardless of how soon you are. So just being able to run Claude and in plan mode, ask it questions about like, where might I have security vulnerabilities in my code? Where could I refactor database queries in order to compress the number of database queries within this view or where could i add caching that would be most impactful and don't even have it touch your code um other than to read the code like i that was actually like my my big kind of breakthrough with lms was i was like i'm just going to use them in read-only mode i don't need them to modify my code for me i'm comfortable doing that myself as a developer but once i got confident in the models being able to read the code i was kind of like just like dip my toe in the water like maybe modifying some things and especially in python i've read a lot of scripts i'm like updating data and i just i don't know it's not my favorite part of coding so having models that can make for me even if it's not perfect and then i can modify it i need to

00:21:19.480 --> 00:21:30.639
export this from the database in that format and like if it works at all it's perfect if it's not going to work at all right like it's a little risk yeah and an export from a database is uh as long

00:21:30.540 --> 00:22:00.500
you're not like accidentally dropping a table it is just like a read only kind of like tell me about my code right like there's all these there's all these things out there that uh in software development are like you have to do the analysis yourself but if you can shortcut it with an llm that actually seems like a big win to me and i don't actually see any downside to doing that like if again if it's if it's a read only and you're not touching the code that to me feels like only a win it was it's time that i have saved that otherwise i would have to invest myself

00:22:01.920 --> 00:23:33.240
yeah let let me give people an example of something i recently did and i want to kind of tie this back to like really emphasize the agentic side of things so i have i just checked i have 530 github repositories on my hard drive i have three computers i have like this streaming course live recording computer that we're talking on now there's a mac mac 2 m2 mac mini i have an m4 mac mini which i usually work on but also my laptop and so every now and then usually i'm on top of things but every now and then i'll open up a project and i'll start making changes i'm like oh i forgot to do git pull oh no oh this might be this might be bad you know especially if it's like a binary file like a powerpoint that i'm going to use for a course it's like there's no fixing it right you just yeah put them side by side and rename one and copy it over but it's it's not great and so i was sitting at my my um kitchen table on my laptop about to take my daughter to school and i opened up um cursor with cloud sonnet in agentic mode and i described what i want i said What I would like is for you to create a script that I can run as a single command that will recursively find all the Git repositories in a certain, whatever folder I'm in, downward, find that, do a Git pull on every single one of them, and report out which ones have changed.

00:23:35.120 --> 00:23:45.780
I drove my daughter to school, which is five minutes one way, five minutes back, sit down, the thing was there, it had created little test directories, It ran it.

00:23:45.780 --> 00:23:46.960
It said, it looks like it's totally good.

00:23:47.240 --> 00:23:50.500
And I literally just now have that as a utility.

00:23:51.210 --> 00:23:52.620
I can just-- when I sit down, I'm like, oh,

00:23:52.700 --> 00:23:54.440
it's been like a week since I worked on this queue.

00:23:54.500 --> 00:23:57.780
Just get refreshed and just give it a moment, and then boom.

00:23:58.240 --> 00:24:01.680
You can see a report of all the stuff that's changed across all the parts.

00:24:03.840 --> 00:24:08.800
Even on something amazing is like ChatGPT, you don't get that because it's not agentic.

00:24:09.010 --> 00:24:18.260
So maybe like let's-- that's a long-winded way of saying, Tell us about the magic of like, what is this agent and tool using aspect for it?

00:24:18.260 --> 00:24:20.520
Because I think when I said my rant, it's not working for people.

00:24:20.660 --> 00:24:23.880
I think a lot of times people are not doing agentic AI.

00:24:24.180 --> 00:24:28.240
They're asking LLM to write functions or stuff, which is great, but it's not the same.

00:24:29.000 --> 00:24:29.320
Yeah.

00:24:29.580 --> 00:24:34.440
Well, I think I would say like kind of the biggest thing, and there's like, there's multiple attributes to it.

00:24:34.480 --> 00:25:01.920
Like, again, going back to some of the definitions, it's like you have an LLM and that LLM, if it's running through ChatGPT on your web browser, it's not going to have access to all the stuff in your code base, unless you have a public GitHub repository or something. But generally, when you're working in your local development environment, it's not going to have access to that stuff. To be fair, there are some tools that will take enough context and upload it to ChatGPT.

00:25:01.920 --> 00:25:34.520
But again, what you're starting to do is you're starting to get really far away from a natural workflow and into one in which you have to bend to how the LLM is set up. So to me, I think the simplest way that I would look at is like a Gentic is like, it's something that is running side by side with you. It's almost like, I don't want to say copilot because copilot has overloaded the terms with like kind of GitHub copilot, but it is essentially like, think about it almost as like pair programming with like more junior developers. Other people have used that analogy.

00:25:34.900 --> 00:25:39.040
It's not perfect, but it's kind of the one that I have that kind of sticks with me.

00:25:39.040 --> 00:25:40.680
It's as close as we got, I think, honestly.

00:25:40.680 --> 00:25:41.860
It's as close as we've got, right?

00:25:41.860 --> 00:25:44.680
You can tell it to go do stuff, and it's not just going to only read.

00:25:45.060 --> 00:25:45.920
It'll look around.

00:25:47.299 --> 00:25:48.100
It'll experiment.

00:25:48.460 --> 00:25:49.220
It'll try something.

00:25:49.360 --> 00:25:50.040
It'll see it's wrong.

00:25:50.240 --> 00:25:50.800
It'll try something.

00:25:52.320 --> 00:25:53.240
It's kind of independent.

00:25:53.880 --> 00:26:06.760
And I think the easiest one for a lot of folks to have tried, because it was the one that I frankly got the most comfortable with at first, was in Cursor, you have what's essentially VS Code.

00:26:07.000 --> 00:26:21.700
So Cursor is embedded within that, and then you have different ways of interacting with an agent mode where you're just asking you to do stuff, asking stuff about the code base or please to write this function, whatever it is.

00:26:22.440 --> 00:26:25.060
So I do think that that works for some folks.

00:26:25.660 --> 00:26:27.400
For me, it was not the light bulb moment.

00:26:27.400 --> 00:26:49.960
It was where I started initially using it was, I would, if I was like, oh, I need to like use this new API, or I need to like, kind of like develop a script or whatever it is, it was kind of like my, because I don't normally work in VS Code, I'm like a Vim, Tmux, like for a long time, like that's kind of my natural environment. And I was never going to like kind of adapt my own workflow. And I think a lot of people are like that, right?

00:26:49.960 --> 00:27:30.780
Like you're in Jeff Reigns, or you're in Xcode or whatever it is, you don't, you, what there's a breakthrough for you is like to build it in a way to your work your development workflow that just is natural and i think that's kind of uh not the canonical definition but to me is kind of most representative of kind of like agentic programming is like it it's just completely a part of your workflow and you don't have to adapt so um so again like that that cursor mode is kind of like okay i'd use it for like one-off stuff for me the breakthrough was using was using And I'll actually, instead of talking about Cloud Code, I'll say, here was the bet that I made.

00:27:31.880 --> 00:27:41.400
My feeling was there was enough value from Cloud Code based off of what I've been, the videos that I've been watching, what I've been reading, and a lot of folks have been using it.

00:27:41.400 --> 00:27:48.620
But I was like, I'm a little worried about getting too reliant upon this tool, which is an API.

00:27:49.280 --> 00:27:51.080
And I will give Anthropic a lot of credit.

00:27:51.260 --> 00:27:53.420
They have done a lot of good work on these models.

00:27:54.360 --> 00:28:02.180
But I've also used Anthropic stuff in the past, which either had bad uptime or they were changing the model too frequently on the backside or things like that.

00:28:02.240 --> 00:28:03.380
But I was like, I was worried.

00:28:03.860 --> 00:28:06.420
And I think that's like a natural thing as a software developer.

00:28:06.720 --> 00:28:09.260
Like, should I really use this API?

00:28:10.660 --> 00:28:20.420
So I was like, my bet was, okay, even if I use this and it's amazing, if it goes away, I still need to be comfortable just like moving back to my workflow.

00:28:20.980 --> 00:28:24.420
Or there could be open weighted models in the future.

00:28:24.760 --> 00:28:34.520
Like I can just run a llama and I could run either cloud code or some sort or open code or some sort of CLI that would allow me to just do the same things, right?

00:28:34.700 --> 00:28:36.780
May not exactly, but roughly the same things.

00:28:37.320 --> 00:28:38.440
So that was kind of the bet that I made.

00:28:38.440 --> 00:28:43.920
That was like the philosophical like mindset shift for myself was I'm already very comfortable as a software developer.

00:28:44.640 --> 00:28:47.640
Let me add this in a way that doesn't break my coding workflow.

00:28:47.720 --> 00:28:51.180
I'm not adapting to these tools in a way that is unnatural.

00:28:52.520 --> 00:29:04.360
And then I will use them in ways that I feel like are actually going to be productive as opposed to forcing them to be used in ways that almost like all the hype cycle and the news media is talking about.

00:29:05.000 --> 00:29:06.640
You will never write another line of code again.

00:29:06.880 --> 00:29:08.900
I don't actually really believe that is true.

00:29:09.220 --> 00:29:09.840
I don't know.

00:29:10.460 --> 00:29:12.480
I feel like anybody who's saying that is not actually using these tools.

00:29:13.140 --> 00:29:15.180
And I actually don't think it's going that direction.

00:29:16.139 --> 00:29:17.220
So I don't know.

00:29:17.300 --> 00:29:27.960
That kind of sets the stage rather than like how I use the tools, like what was going through my mind as a software, as an experienced software developer of like, should I even make this shift?

00:29:27.980 --> 00:29:30.780
I don't know if that if you had to undergo that as well.

00:29:32.600 --> 00:29:33.200
I did.

00:29:35.260 --> 00:29:39.620
And I guess I haven't been as introspective about it as you.

00:29:39.660 --> 00:29:47.740
But for me, the real shift for me was I'm already a good coder.

00:29:48.260 --> 00:29:50.480
I feel very competent flying around.

00:29:50.590 --> 00:29:54.400
Our tool chain, I know yours and mine, is like kind of quite different, right?

00:29:54.430 --> 00:29:56.260
You're very Tmux-based.

00:29:56.610 --> 00:30:00.240
I'm very much often in PyCharm, jumping around there.

00:30:00.310 --> 00:30:03.420
But we all are very fluid and capable, right?

00:30:03.540 --> 00:30:06.520
So you're feeling like this is like I'm really productive and competent.

00:30:06.580 --> 00:30:10.180
And the last thing I want to do is just like spend my days in a chat engine.

00:30:10.920 --> 00:30:11.400
You know what I mean?

00:30:11.940 --> 00:30:12.040
Right.

00:30:12.200 --> 00:30:13.540
Like that is not it.

00:30:15.060 --> 00:30:18.440
And I guess one of the main things, I sat down with a friend of mine.

00:30:18.480 --> 00:30:21.120
We were out having beer and he had his laptop, a friend named Mark.

00:30:21.240 --> 00:30:22.940
And he had his laptop.

00:30:23.140 --> 00:30:26.060
I said, well, let's just, man, I've been doing some really cool stuff with Agenda.

00:30:26.200 --> 00:30:27.940
Let me just, let's just do an example.

00:30:28.780 --> 00:30:35.920
And over like a beer, we built the most amazing app that would literally take weeks.

00:30:36.720 --> 00:30:40.420
or a week at least, you know, knowing what you're doing.

00:30:40.740 --> 00:30:43.940
Like not, I'm going to learn these frameworks and then do it.

00:30:44.340 --> 00:30:45.920
But even with this,

00:30:46.620 --> 00:30:48.980
that actually changes my perspective.

00:30:49.320 --> 00:31:00.280
Did it use open source libraries and frameworks in order to create, like did the tool pull in a bunch of stuff and it actually stood up and built this application off of all the open source code, right?

00:31:00.400 --> 00:31:01.660
Yes, and it was ridiculous.

00:31:02.620 --> 00:31:04.339
It was a FastAPI app

00:31:05.399 --> 00:31:09.640
using SQLAlchemy to talk to SQLite.

00:31:10.410 --> 00:31:13.120
The web design was done in Bulma CSS.

00:31:14.500 --> 00:31:20.880
It used simple MDE for live markdown editing.

00:31:21.680 --> 00:31:25.040
And it just kept going.

00:31:25.480 --> 00:32:01.500
And one of the things I think is really interesting, and I know you have some thoughts on this as well, it's the more the more you work with like new fancy hip frameworks the less well off you are right like i could have said tailwind but tailwind's got all these build steps and all these little nuances bulma is just include a css and so it didn't have that was like a thing it didn't have to worry about and so on you know what i mean yeah so i i find it's it's like i find myself trending towards more simple code than more towards frameworks which is the opposite i think that yeah

00:32:02.180 --> 00:32:25.140
there's i'll i'll even take it a step further which is i very much appreciate i very i agree with you on the like less build steps and in fact like the simpler is often better but i will say that i very much appreciate the opinionated tools and frameworks and that's why i've actually had a better experience doing using like cloud code with Django.

00:32:25.940 --> 00:32:39.520
And a big piece is also I've written thousands, if not tens of thousands of lines of code already in Plush Cap, which is typically what I'm building, if not some side scripts and stuff like that.

00:32:40.399 --> 00:32:42.380
Let's do a really quick sidebar

00:32:42.520 --> 00:32:52.700
that you introduce those projects, just because I know it's really nice to be able to like reference back when I was adding this feature or this is the, so give people something concrete, you know,

00:32:52.700 --> 00:32:55.200
like tell us about full stack Python and Flush Cap.

00:32:55.520 --> 00:32:56.400
- So this is full stack Python.

00:32:56.640 --> 00:32:58.260
I wrote full stack Python.

00:32:58.300 --> 00:33:10.860
It's like over 150,000 words, all about the Python ecosystem, ranging from like the Python language itself to web frameworks, to deployment options, and content delivery networks, APIs.

00:33:11.760 --> 00:33:14.920
So it was kind of like all the things around Python.

00:33:15.640 --> 00:33:18.120
And it was broken down by conceptual ideas.

00:33:18.360 --> 00:33:28.640
So like data visualization and implementations, which I feel like is something that is not particularly obvious to people that are learning to program is like you have conceptual ideas and those have specific implementations.

00:33:28.860 --> 00:33:32.740
So a web framework is a conceptual idea across many different programming languages.

00:33:33.240 --> 00:33:42.640
But the specific implementations like a Ruby on Rails, like Rails, the framework or Django, the framework are the specific implementations within those programming ecosystems.

00:33:43.220 --> 00:33:46.460
So that's essentially how I built out this site over 10 years.

00:33:46.680 --> 00:33:51.640
I will say that I only really work on one side project at a time.

00:33:52.300 --> 00:33:56.400
And Fullstack Python, I felt like, kind of run its course over 10 years.

00:33:56.520 --> 00:33:58.640
So I really haven't updated it in a few years.

00:33:59.090 --> 00:34:06.620
I still think it's actually relevant for most of it, but some of the links are a little bit dated and things like that.

00:34:06.670 --> 00:34:14.780
And it's not been brought into the conversation that we're having around coding agents and things like that.

00:34:15.020 --> 00:34:21.780
is it is still relevant, but I would say not as relevant as it was when I was updating it literally

00:34:22.050 --> 00:34:27.919
every day. Right. Back in 2016 or something like that. Yeah. Yeah. And I also, I'm, I struggle a

00:34:27.950 --> 00:34:48.480
little bit because like, I would love to go back to working on full stack Python. But what I struggle with is you can ask LLMs about all of this stuff and it will give you very good answers. And so a lot of what I was doing was just bringing like an, as an experienced software developer, like writing almost like essays on like, you can see here, like, why are web frameworks useful?

00:34:49.030 --> 00:34:58.620
You can ask an LLM like why web frameworks are useful. And actually it'll probably give you a better answer than what I've written here because it's going to incorporate tons of different sources.

00:34:59.220 --> 00:35:16.000
So that's where I've struggled a little bit with like, as you know, the chat models based on LLMs, especially as they've added search have gotten better. I'm not really sure how to add enough value on top of what an LLM can tell you to justify a substantial investment in writing.

00:35:17.140 --> 00:36:02.980
And then also, the one challenge with Full Stack Python is it's a statically generated site. It is primarily Markdown built with Pelican, which is a great static site generator in Python, but it was a lot of writing and it wasn't as much code as I wanted. The site is kind of the site and then you add a ton of content to it to me i really wanted to get back to like especially as like now um as a you know a vp uh for the last several years of my career in executive level like i don't get a lot of time day in and day out to code um and so i really wanted something that i was coding every single day on nights and weekends and just doing in my spare time so that's kind of where i shifted to this project, PlushGap, which is at plushgap.com.

00:36:03.860 --> 00:36:08.920
So this is like a landscape of developer-focused companies with self-service motions.

00:36:09.440 --> 00:36:19.140
So the hypothesis behind this was like when I was at Twilio, we were tracking like developer content and events and other competitors.

00:36:19.680 --> 00:36:26.400
And it wasn't back then, but now YouTube is a really important source for teaching developers.

00:36:26.820 --> 00:36:30.620
And so I want to just like to aggregate a lot of this data.

00:36:31.070 --> 00:36:31.620
So that's what I've done.

00:36:32.180 --> 00:36:42.060
It's essentially 500 developer-focused companies across all different stages from like pre-seed all the way to publicly traded companies, where they stand kind of in their competitive position.

00:36:42.610 --> 00:36:48.700
And then like leaderboards that will show you like how many videos and views and subscribers do different companies have.

00:36:49.180 --> 00:37:14.320
and so like, there's just a lot of data analysis, a lot of data visualization, a lot that essentially just goes into, like if you go to, if you scroll down on airbyte and you go down to, on this page, if you scroll down to the website structure and click on the blog, like, sorry, if you click on, go back and just click on the, hold on or, just go up a little bit of blog posts.

00:37:14.340 --> 00:37:14.500
Gotcha.

00:37:14.960 --> 00:37:15.160
I see.

00:37:15.400 --> 00:37:22.140
under content category, this lays out the number of blog posts that was published per month by the company.

00:37:22.350 --> 00:37:34.700
And so just being able to visualize their content patterns and trends has been helpful for me as I talk to companies about their go-to-market motions with developers and developer marketing, things like that.

00:37:35.400 --> 00:37:46.980
Anyway, this is a Django project running on DigitalOcean, Cloudflare as a CDN, a ton of Python, a ton of database stuff on the back end.

00:37:47.440 --> 00:37:57.740
So for me, I just love digging into this and I use coding agents and they really greatly accelerated what I can actually do with this.

00:37:57.860 --> 00:38:00.220
Because what I'll do is I'm in meetings all day.

00:38:01.040 --> 00:38:04.720
So in the start of the day, I'll just tee up a bunch of stuff that I want to get done.

00:38:05.330 --> 00:38:09.200
And then throughout the day, as I'm getting out of meetings, I can just hit, okay, okay, good.

00:38:09.650 --> 00:38:12.120
And I just run it all on my own computer.

00:38:12.270 --> 00:38:13.740
And then I've got my work computer.

00:38:13.880 --> 00:38:16.600
I've got my own computer where I'm running all this stuff.

00:38:16.670 --> 00:38:19.780
And periodically when I'm taking a break, I'm going to be like, okay, yep, that looks good.

00:38:19.780 --> 00:38:21.220
Or no, I don't do that thing.

00:38:21.810 --> 00:38:29.760
So to me, it is like having a development team, even just a small development team, because I'm not doing huge stuff to actually implement things.

00:38:30.060 --> 00:38:32.420
So that's really where I use all these tools.

00:38:32.570 --> 00:38:34.660
And I have an established code base.

00:38:34.830 --> 00:38:38.200
I wrote the code base myself over three years by hand.

00:38:39.000 --> 00:38:40.380
So now I have all the design patterns.

00:38:40.650 --> 00:38:42.380
I have an opinionated framework with Django.

00:38:42.740 --> 00:38:46.960
I've already chosen the vast majority of the open source libraries that I need.

00:38:47.500 --> 00:38:57.060
And it is mostly about the coding tools pattern matching against what I've already done to create a new visualization or to create a new scraper.

00:38:57.130 --> 00:38:59.580
Because I'll scrape all the content from all these sites.

00:39:00.120 --> 00:39:06.940
So if I add a new company in the database, I have to write some custom web scrapers in order to get all their data.

00:39:07.480 --> 00:39:08.500
And that stuff is annoying.

00:39:08.740 --> 00:39:10.020
I've already written hundreds of those.

00:39:10.300 --> 00:39:10.940
So I'd rather...

00:39:10.940 --> 00:39:12.000
You're done right now.

00:39:13.660 --> 00:39:17.440
And then out the other side comes something that I can actually use.

00:39:18.240 --> 00:39:20.960
And I don't have to do all the grunt work because I've done a lot of that myself.

00:39:21.600 --> 00:39:27.180
Yeah, there's no more lessons to learn by making you figure out their nav structure.

00:39:28.200 --> 00:39:48.040
Yeah. Or like, you know, I'm pulling like, CS, okay. Which CSS class corresponds to like the author name of the blog post so that I can get some structured data out of what is otherwise like, unstructured data because it's every single company has a different blog, blog format. Right. So, yeah, I think this, you, you touched on two real interesting things here

00:39:48.180 --> 00:40:30.460
first. Oh, three, I guess one plush cap is super cool. Thanks. Yeah. Two having a low stakes project that you can just kind of go mad on with agentic AI and it's not going to end things or end badly. And three, I think this is really interesting. And I've noticed the same trends for me as well. But having already created the project, having really carefully thought about design structures, like, okay, it's going to be in this folder structure, and it's going to follow this design pattern over and over using these three libraries I like.

00:40:30.720 --> 00:40:34.400
Not the most popular ones, actually, but the ones that I think I want to work with.

00:40:34.860 --> 00:40:42.280
Putting that in place really limits the, oh, it just, why is it using NPM?

00:40:42.460 --> 00:40:43.200
This is a Python project.

00:40:43.330 --> 00:40:43.920
What is it up to?

00:40:43.990 --> 00:40:51.660
You know, like, it's way, way more focused and more likely to be aligned with what you were hoping it would do in the first place.

00:40:52.500 --> 00:40:56.040
And you need to choose the tools that you can debug the best.

00:40:57.100 --> 00:41:00.320
And so for me, like this is a bootstrap front end.

00:41:00.520 --> 00:41:08.580
There's a framework called tabler, which is built kind of on top of bootstrap, which makes it even easier to build kind of these admin style interfaces and pulls in.

00:41:08.610 --> 00:41:10.100
I think it's I think it's chart.js.

00:41:11.460 --> 00:41:12.240
Apex might be.

00:41:12.550 --> 00:41:14.060
I was using a few different charting frameworks.

00:41:14.840 --> 00:41:16.360
So it might be like Apex or something now.

00:41:16.540 --> 00:41:23.280
But the whole point of choosing your tools and being opinionated about your tools, I think actually helps a lot.

00:41:23.650 --> 00:41:32.760
Because then you don't have to get up to speed on the framework or the library before you debug the problem that the LLM created.

00:41:33.810 --> 00:41:39.340
Because the LLMs are typically going to get you often 95% of the way there.

00:41:39.410 --> 00:41:40.720
And you can keep prompting them.

00:41:41.170 --> 00:41:44.920
But it's often better to just go fix it yourself.

00:41:45.260 --> 00:42:00.900
There might be like a one line tweak or something like that that you need to do as opposed to like trying to get it to like, sometimes it feels like getting the last like five to 10% of polish is like finding a needle in the haystack because it's changing too much often.

00:42:01.680 --> 00:42:08.460
Whereas if you can just go in and modify it yourself, you're not going to introduce additional noise into the development process.

00:42:09.060 --> 00:42:09.300
Yeah.

00:42:10.020 --> 00:42:13.420
I have a, but it seems like an out of left field question, but it's not.

00:42:15.000 --> 00:42:16.600
What about Git and source control?

00:42:17.420 --> 00:42:18.100
Oh, well, yeah.

00:42:19.060 --> 00:42:36.840
So, I mean, that's the thing that we haven't talked about, which is like wildly important, which is like after when I'm letting something run, it is off of either, it's either in a separate Git branch from running a bunch of things, or I actually like, oh, granted, I have some simplifying assumptions with my own code base.

00:42:37.380 --> 00:42:40.820
I will, I've split the code base into multiple parts.

00:42:41.360 --> 00:42:45.840
So I have like scripts where the scripts are like, you know, web scrapers.

00:42:46.360 --> 00:42:57.260
And if I'm updating things through an API, like I use the YouTube API, I use like the PyPy API, I use like a bunch of different APIs to get data into the database.

00:42:57.930 --> 00:43:01.460
So like I can have an agent running on that thing, right?

00:43:01.630 --> 00:43:02.300
And that's separate.

00:43:02.420 --> 00:43:09.720
I actually only have those things interface with an API that is running with Django REST framework with the main production application database.

00:43:10.580 --> 00:44:12.160
So I've created a layer of abstraction where I can have an agent running on this thing here, then I can also have it running on the main application code base. And as long as we're not changing anything about the API, then I know that they can make their changes separately and that they're not going to interfere with each other. And all of this, going back to your original question about Git, I'm constantly just doing Git add, Git commit. The one thing I've definitely noticed about some of these tools is they will go off and create a bunch of different files. And so you do have to get pretty careful with like i used to just do you know git commit all the things git commit dot or no sorry git add dot git commit a little message and i've learned like oh geez like there's some debugging files that it actually didn't remove i i gotta like manually remove those now again like i think a lot of these tools you can configure them to like get rid of those problems I think that that's the thing that's really improving quickly now.

00:44:12.210 --> 00:44:18.200
So if you ask me, like, what's the thing now that's really annoying that will likely be much easier a year from now?

00:44:18.200 --> 00:44:26.120
It will be like you're going to have a standard like claw.md file that gives instructions that's just going to be like standardized.

00:44:26.580 --> 00:44:29.740
It's like how everybody has a git ignore file.

00:44:31.240 --> 00:44:33.080
Like you just kind of copy it from somewhere.

00:44:33.410 --> 00:44:33.520
Right.

00:44:33.720 --> 00:44:33.800
Yeah.

00:44:34.080 --> 00:44:35.320
And then you modify it a little bit.

00:44:35.780 --> 00:44:37.340
But like the vast majority of it's the same.

00:44:37.850 --> 00:44:37.980
Yeah.

00:44:38.060 --> 00:44:39.400
Like that's where we're going to go, right?

00:44:39.800 --> 00:44:40.600
Right, right.

00:44:40.630 --> 00:44:42.980
You're like, oh, we've all tended towards this.

00:44:43.790 --> 00:44:43.900
Yeah.

00:44:44.820 --> 00:44:48.780
So that goes back to my you're not prompting enough sort of things, right?

00:44:48.900 --> 00:44:55.900
Like if you're opinionated about how your project is built, put that in there.

00:44:56.060 --> 00:45:01.680
And a lot of times these agentic tools have like a rules file, like cursor has a dot cursor rules.

00:45:02.270 --> 00:45:07.560
And the stuff you might put in there is my preferred web framework is FastAPI.

00:45:08.760 --> 00:45:43.020
when you install things or create a virtual environment use uv not python's native right and you'll see it when it's working it'll say things like i know that i'm supposed to use uv so it'll run uv pip list when it's checking if something got installed right and it'll even like sort of remind itself from what you've said and it's it's those kind of things that keeps it on track right so i would say one of the things people should actually put more effort into the initially think is like setting up these rules about just your general preferences yes and uh

00:45:43.230 --> 00:46:08.820
i think it was armin roeniker had a really great uh tip the other day where essentially like you can just use i believe it's a hook in cloud code and it's like basically if the um the lm tries to use a pip install something it will actually throw an error and it will know based off of that error that it should be using uv uh and so you can add enough of these hooks and so like what i anticipate is like over time, number one, like people will develop some level of standardization for these.

00:46:08.950 --> 00:46:15.200
Like right now, the configuration files are very fragmented across the different agentic tools.

00:46:15.840 --> 00:46:19.320
So you can't quickly swap from like one to the other.

00:46:20.150 --> 00:46:30.400
Like I know like there's a Gemini CLI and there's a Claude that has a configuration both for project specific and for all your development workspaces.

00:46:30.780 --> 00:46:36.680
My guess is like a lot of this stuff will start to get standardized, just like MCP was standardized and an open standard.

00:46:37.260 --> 00:46:44.840
And then it will make it much easier for people to like just transpose their development preferences from one tool to the other.

00:46:45.000 --> 00:46:48.520
So my guess is like that's probably what's coming over the next 12 to 18 months.

00:46:48.580 --> 00:46:56.320
And if the big companies don't want that to happen, they'll be left behind by the open source tools that will make that much easier.

00:46:57.400 --> 00:47:01.540
Yeah, I think I think the other thing is like I actually don't I don't know.

00:47:02.200 --> 00:47:04.500
Maybe I'm like one of the oddballs with Vim.

00:47:04.660 --> 00:47:07.820
I don't, I have a VimRC, like for my configuration.

00:47:08.180 --> 00:47:15.620
I don't have like an insane number of extensions or, you know, or I guess plugins or like a huge VimRC or anything like that.

00:47:15.620 --> 00:47:25.760
Like I actually try to keep things relatively standard and then just focus on the patterns that are most important or the configurations that are most important.

00:47:25.860 --> 00:47:30.240
And I'm still kind of like that with using Cloud Code.

00:47:30.580 --> 00:47:35.500
I do have, you know, cloud MD file and stuff, but I also found that it's not 100% accurate.

00:47:35.660 --> 00:47:42.520
And so I think there's going to be a lot of development around making sure that like the tools adhere to the practices that you really want.

00:47:42.780 --> 00:47:52.300
Because right now I feel like if you want reliability in like code formatting, you need to run the code formatter like as a separate step as a part of your build workflow.

00:47:52.960 --> 00:47:56.700
Like the agentic tools are just not, I haven't, maybe I'm.

00:47:57.300 --> 00:48:07.460
I've gotten Cloud Sonnet to know that it's supposed to run Ruff format and rough check --fix whenever it finishes anything.

00:48:07.890 --> 00:48:15.380
And so at the end, it'll say, and now I'm supposed to do this to make sure it's tidy and the style you like according to your ruff.toml, right?

00:48:16.240 --> 00:48:17.500
Yeah, and that makes sense.

00:48:17.930 --> 00:48:20.220
But sometimes it doesn't, right?

00:48:20.440 --> 00:48:20.820
Right.

00:48:21.300 --> 00:48:22.020
But you usually do.

00:48:22.160 --> 00:48:22.960
What's wrong with you?

00:48:23.520 --> 00:48:23.860
I know.

00:48:24.120 --> 00:48:44.080
Yeah. And also, I feel like everything that you add to the agent, like the more and more steps that you add, actually, like, again, like, this will change over time, but I feel like it actually gets less reliable. And also, like, the number of steps, I would rather just have it run a script that will handle all those things before I'm ready to commit, rather than having it run all the time.

00:48:44.180 --> 00:48:47.960
Because I've also found like sometimes I want to add a tool for like code formatting or something.

00:48:48.220 --> 00:48:51.760
And then it slows down the whole process too much for me.

00:48:52.400 --> 00:48:56.480
And then the main thing with these tools is I want them to be extremely fast.

00:48:57.220 --> 00:49:02.900
And that is probably the biggest piece of advice I can get to like any of these companies is like why cloud code over others?

00:49:02.970 --> 00:49:09.660
Like it is insanely fast, even though the LLMs require, you know, processing time and stuff like it's responsive.

00:49:09.960 --> 00:49:14.120
And so my guess is that's also where a lot of the open source tools will go as well.

00:49:14.240 --> 00:49:16.780
They'll just be really fast and responsive, just like Vim and Tmonks are.

00:49:17.440 --> 00:49:17.800
Yeah.

00:49:19.740 --> 00:49:22.420
Leave it to a Vim user to say it's not fast enough.

00:49:22.470 --> 00:49:22.800
Just kidding.

00:49:24.840 --> 00:49:25.280
Yeah, exactly.

00:49:25.450 --> 00:49:29.840
So I think maybe just some quick shout outs to some of the tools, right?

00:49:30.100 --> 00:49:32.940
So Cloud Code, obviously, is a really interesting one.

00:49:33.220 --> 00:49:34.260
We've been talking about that a lot.

00:49:34.440 --> 00:49:35.820
I've mentioned Cursor a few times.

00:49:35.980 --> 00:49:42.320
I think as much as I'm a much more fan of the PyTarm style, I find it to be very effective.

00:49:42.900 --> 00:49:46.980
I've done some stuff with Juni, which is kind of a new project from JetBrains.

00:49:47.070 --> 00:49:52.300
Like JetBrains has had an AI agent that was kind of like a super-duper autocompleter.

00:49:52.720 --> 00:49:54.340
And maybe we could talk about that difference as well.

00:49:54.940 --> 00:49:56.700
But it's like a super-duper autocompleter.

00:49:56.810 --> 00:50:02.500
But then they have a separate, completely different install thing that is an agentic AI called Juni.

00:50:03.360 --> 00:50:04.700
And I think it's making good stuff.

00:50:04.760 --> 00:50:07.660
It really integrates with PyCharm if you're into that.

00:50:09.180 --> 00:50:09.340
Yeah.

00:50:09.500 --> 00:50:10.880
Well, and that's been the evolution, right?

00:50:10.980 --> 00:50:16.160
Like we had GitHub Copilot, which was essentially like a very fancy autocomplete.

00:50:17.100 --> 00:50:21.520
It would complete your code for you, but it wasn't an agent in any meaningful capacity.

00:50:21.760 --> 00:50:25.780
That's what kind of kicked off some of this stuff of like, wow, it's really great autocomplete.

00:50:25.820 --> 00:50:28.320
And I think a lot of the tools followed that pattern.

00:50:28.380 --> 00:50:38.440
Like even when you would use cursor, like say a year ago, it was very much like autocomplete, at least the standard pattern, right?

00:50:38.590 --> 00:50:39.640
Before they had agent mode.

00:50:40.020 --> 00:50:40.460
For sure.

00:50:40.490 --> 00:50:42.000
And that never really connected with me.

00:50:42.510 --> 00:50:44.020
I'm like, I don't need that.

00:50:44.050 --> 00:50:46.480
I can just, I can autocomplete it word by word.

00:50:46.560 --> 00:50:49.880
I don't really, because half the time it'll autocomplete like three or four lines.

00:50:50.030 --> 00:50:51.920
I'm like, yes, but not that line.

00:50:51.990 --> 00:50:53.880
And how do I get it to autocomplete the next?

00:50:53.970 --> 00:50:56.120
I guess I got to accept it and go edit that part.

00:50:56.160 --> 00:51:01.720
You know, like, it's just, I never really vibed with that, but the agentic mode that is next level stuff.

00:51:02.400 --> 00:51:09.080
Also, if you're a PyCharm or VS Code user, the cloud code integrates in both of them.

00:51:09.660 --> 00:51:09.740
Right.

00:51:10.300 --> 00:51:10.360
Yes.

00:51:10.620 --> 00:51:14.360
Like, you know, it's, so maybe talk, like, I know you're using cloud code.

00:51:14.480 --> 00:51:18.080
So maybe tell people like what it's like and why you like that one.

00:51:18.460 --> 00:51:18.840
Okay.

00:51:19.000 --> 00:51:25.820
So I started using cloud code like six months ago, but I was using it off of the API credits, which was before, like they're, they came out with the plans.

00:51:26.499 --> 00:51:31.780
started evaluating it. I was like, this is going to be way too expensive. Like this is very expensive.

00:51:31.930 --> 00:51:50.040
Very soon. I was like this, you based off of my usage patterns, like just like monthly, it's probably going to cost me over a thousand dollars a month. I was like, I, this is just not, it's not worth that. Right. So then they came out with the max plan, which was, I think originally $200 a month. Now they have a hundred dollars and $200 a month, which I thought was interesting.

00:51:50.150 --> 00:52:55.680
Right. But I was like, I talked to enough people that did use it. And I was like, that's interesting, but i i'm not that comfortable with this workflow yet they came out with the pro plan which was 20 a month they said okay i'll try it for a month uh it was almost like a to me it was almost like a free trial like i'm willing to invest 20 into a course or whatever it is like 200 is like a pretty high bar but 20 bucks i was like yeah okay fine even if even if this sucks i'll just i'll try it so i maxed out the pro plan i was like i'm gonna get every drop out of the pro plan that i possibly can for my 20 bucks and then i'll make a decision as to whether i want to upgrade or not i i was like this is good enough uh i got and that was only with the sonnet model wasn't the higher opus model so there's like a lot of stuff that was like a little bit more limiting about it if you give a lot more instructions it wasn't as good as like architecting things but i got enough out of it i was like okay i'd be willing to like upgrade um and so i'm on i'm actually currently now on the For me personally, it forces me to be a little bit more addicted to using it.

00:52:55.680 --> 00:52:57.160
Like I want to get my money's worth.

00:52:57.970 --> 00:53:04.480
And so there's a tool called CC Usage, which was originally just for the API.

00:53:04.550 --> 00:53:11.940
But now it'll just give you your usage patterns, even if you're on the subscription plan.

00:53:12.620 --> 00:53:17.180
I will say like my usage yesterday, if it was by API, would have been $105.

00:53:18.080 --> 00:53:25.800
So, you know, over a course of a month, if I was actually consistent, I'd be spending over $3,000 a month off of API credits, which is just not sustainable, right?

00:53:26.800 --> 00:53:31.000
So, yeah, there might be people out there listening who think, you know what, Matt is actually crazy.

00:53:32.020 --> 00:53:36.680
Because $200 a month to some random AI thing when I'm a developer is insane.

00:53:38.080 --> 00:53:53.300
But if you had somebody who worked for you, who you could give detailed instruction to and have some reasonable expectation that they can get it done independently, and you said, well, that person you hired is $200 a month, that would be insane, right?

00:53:53.560 --> 00:53:58.480
And you can really turn this thing loose and get a lot done.

00:53:58.500 --> 00:54:20.080
But I think one of the mind shifts, at least I had to make, was if I'm going to pay for one of these AIs at a level like that, you better make use of it. And you better have a plan that like, this thing is, this is how I'm going to take advantage of it. But when you do all of a sudden, you're like, wow, this is actually a bargain. Yeah. Well, and let's, let's compare it to like another like AI tool

00:54:20.400 --> 00:54:36.640
that I use, which is Descript. And I use Descript quite a bit. Descript is for creating, you just record video and then you can edit off of the transcript and it'll like edit the video. It's not perfect, but it's very, very good. And I'm on like a, I don't know, it's like 150 bucks a year or something like that.

00:54:36.720 --> 00:54:47.760
I use it a lot for, I run, like my teams are remote distributed and I like to record videos just so they can hear from me like in five to 10 minute increments of like, here's what I'm thinking about or shout outs or whatever it is, right?

00:54:48.100 --> 00:54:53.720
So I use it like quite a bit internally, but like if I don't use it for a week because I'm traveling, I don't feel bad about it.

00:54:55.260 --> 00:54:58.140
And so like, but that's 150 bucks a year.

00:54:58.700 --> 00:55:03.540
Like I get enough usage out of it at 150 bucks a year that if I don't use it for a week, it's not that big of a deal.

00:55:04.020 --> 00:55:39.280
200 bucks a month is like really high bar and so my bet there was just like with the 20 a month plan was if i don't use this enough i'm going to cancel it um and the other bet is i think eventually that the open weighted models are going to get really interesting here um and so i just want to be on the edge of seeing this ahead of time and so i look at it as a little bit of an investment in my own uh learning um And so like to me, there's just no replacing hands on time with the tools.

00:55:40.160 --> 00:55:40.280
Right.

00:55:40.560 --> 00:55:43.460
And so that to me is really what this is about.

00:55:43.660 --> 00:55:49.180
And to be fair, like I've used other tools, other APIs, developer tools where I paid for them.

00:55:49.960 --> 00:55:52.940
Actually, a browser base, which is like a web scraping tool is awesome.

00:55:53.660 --> 00:55:56.520
I have paid 40 bucks a month here and there to use it.

00:55:56.600 --> 00:55:59.460
And then when I don't use it enough, I will just downgrade my plan.

00:55:59.700 --> 00:56:07.640
And you kind of have your short list of things that you're using as a developer as a time, as opposed to thinking that it is like, indefinitely, I'm going to be paying for this.

00:56:07.980 --> 00:56:08.240
Yeah.

00:56:09.350 --> 00:56:16.760
Yeah, I definitely think it's important for people to maybe not try the $200 plan, but like the $20 plan or something if they're interested in these things.

00:56:16.940 --> 00:56:31.180
Because downloading a free model that runs on your local machine, that 3 billion parameters, and saying, well, I tried AI and it doesn't work is not the same as trying this type of thing.

00:56:31.400 --> 00:56:33.560
Right. It's really, really different.

00:56:34.200 --> 00:56:34.260
Yeah.

00:56:34.480 --> 00:56:39.280
So yeah, it's if you have a I think that's why my situation.

00:56:39.980 --> 00:56:43.720
Let's let's maybe like set up a little framing of who I think this is most valuable for.

00:56:44.720 --> 00:56:53.280
If you are like an elite developer and you're working on things like embedded systems or things that absolutely cannot break, I actually think there is less value for you here.

00:56:53.500 --> 00:56:57.960
I think the read only mode is valuable in that, like analyze my C code.

00:56:58.040 --> 00:57:04.720
where could there be like, you know, like memory, you know, buffer, buffer or tax or whatever it is.

00:57:04.740 --> 00:57:14.120
Right. But I think if you are building like side projects, like I'm not trying to like monetize like plush cap really, but like, you know, maybe someday I will.

00:57:15.020 --> 00:57:17.300
I just really love building plush cap.

00:57:17.520 --> 00:57:27.860
Like I think if you have a side project and for you, like you're building courses, you have your website, like there's a lot there that if you just had more bandwidth, you could build so much more cool stuff.

00:57:28.020 --> 00:57:37.800
Like, yeah, like when you have a backlog of ideas and you don't have time to build them, that's actually where I think these tools are most valuable because you can build a lot of those ideas.

00:57:38.400 --> 00:57:41.960
And some of those ideas might be stupid and then you can just throw them away.

00:57:42.540 --> 00:57:52.340
But the ones that you can just clear your backlog and come up with new ideas because this thing is just you're able to ship so much faster, even if you have to refactor by hand, that's amazing.

00:57:53.320 --> 00:58:15.540
Yeah. I have three projects that are like sort of side project ish, but are like related to Talk Python in various ways. And yeah, it's just turn the stuff loose on it and see if it's a good idea. Who knows if it'll see like the light of day, but it goes from, can I dedicate three months to that too? Well, let me try an afternoon.

00:58:16.480 --> 00:58:16.540
Yeah.

00:58:16.840 --> 00:58:47.400
see how it comes out you know let me let me show you like something that i built purely off of like claude code if you go to if you go to plush cap i have a um a leaderboard uh of youtube channels and by company so you've got i actually have you know all almost 500 companies in there but it cuts off at a thousand so yeah if you go to leaderboards youtube um you know there's there's 231 companies listed here and all 231 are, have over a thousand subscribers.

00:58:48.060 --> 00:58:52.740
Now, the thing that's interesting, like I was just showing this to someone and they're like, Oh, you know, it'd be really interesting.

00:58:52.800 --> 00:58:56.580
It's like, you have like subscribers, you've got videos, you've got views.

00:58:56.900 --> 00:59:02.220
And if you click into like views, like if you click into the number of views, this is total views over time.

00:59:02.380 --> 00:59:09.040
It's a visualization of like, you know, what, how many views, open AI has on their YouTube channel over time.

00:59:09.840 --> 00:59:12.060
They were like, what would this look like?

00:59:12.280 --> 00:59:14.320
You know, because they're producing more and more videos.

00:59:15.440 --> 00:59:20.040
So is the average number of views going up over time or down?

00:59:20.130 --> 00:59:22.400
Like, are they becoming more efficient or less efficient?

00:59:22.900 --> 00:59:28.640
So I was like, I wonder, like, I already have subscribers, videos, and views.

00:59:28.950 --> 00:59:29.620
I have the visualization.

00:59:29.730 --> 00:59:31.980
I literally have the pattern for what I would like this to be.

00:59:31.990 --> 00:59:32.840
And yeah, there.

00:59:33.360 --> 00:59:38.940
Now you can see, actually, they're becoming less efficient over time as they add more videos.

00:59:39.560 --> 00:59:41.220
And there's different ways you can slice this data.

00:59:41.290 --> 00:59:45.120
So I've actually got like a bunch more ideas just from creating this view.

00:59:45.820 --> 00:59:48.880
But this view was based off of the pattern that I had already created.

00:59:49.470 --> 00:59:55.660
And so it was just basically like using the Django ORM to pull the data, you know, create a new webpage.

00:59:56.719 --> 00:59:59.680
And I could tell whether it was correct or not and then like tweak it.

01:00:00.240 --> 01:00:07.140
So it had the pattern and it just needed to mimic that in a way that was a new view and visualization.

01:00:08.520 --> 01:00:09.460
And I feel like that's what this is.

01:00:09.460 --> 01:00:12.540
- Pull new data, make a new page, but it's pretty much the same, yeah.

01:00:12.620 --> 01:00:13.940
- Exactly, yes.

01:00:14.739 --> 01:00:19.780
So this isn't like rocket science or anything like that, but for me, I wanted to build this view.

01:00:20.010 --> 01:00:31.520
I actually, the interesting part about the story is like, I talked to somebody in the morning and I shipped this when I had a quick break and I was like, I sent it over to them and I was like, hey, I built this thing.

01:00:33.520 --> 01:00:36.900
And actually, no, it was my boss at work at DigitalOcean.

01:00:37.100 --> 01:00:38.900
He was like, because we're looking at our YouTube channel.

01:00:39.020 --> 01:00:40.760
And he's like, I wonder what the average views are over time.

01:00:40.820 --> 01:00:44.020
And I was like, a few hours later, I was like, I had a break.

01:00:44.100 --> 01:00:44.560
I shipped it.

01:00:44.620 --> 01:00:45.300
And he's like, this is crazy.

01:00:45.700 --> 01:00:50.460
Because we use this data as a part of running my work, like Debra and stuff.

01:00:50.740 --> 01:00:51.660
So it's helpful.

01:00:51.900 --> 01:00:54.100
Because whenever we have an idea, we're like, what does the data look like?

01:00:54.859 --> 01:00:56.280
Especially when you compare it across companies.

01:00:56.660 --> 01:00:57.200
That's really helpful.

01:00:59.540 --> 01:00:59.860
Yeah.

01:01:00.060 --> 01:01:01.020
It's the perfect type of thing.

01:01:01.200 --> 01:01:02.000
I absolutely love it.

01:01:02.420 --> 01:01:03.840
So let's close this out.

01:01:03.860 --> 01:01:05.240
We got maybe take a few more minutes.

01:01:05.480 --> 01:01:08.420
let's give people some concrete tips.

01:01:08.840 --> 01:01:10.840
Like, for example, when we talked about Git,

01:01:11.370 --> 01:01:12.400
you know, check in off the,

01:01:13.599 --> 01:01:16.660
let it finish a job, save it and check that in.

01:01:17.260 --> 01:01:19.200
And don't let it just go wild for a while.

01:01:19.230 --> 01:01:21.580
Cause if it goes bonkers and you're like, oh, I hate that.

01:01:21.660 --> 01:01:24.120
You're like, but that's also hours of work that's gone.

01:01:24.420 --> 01:01:24.800
You know what I mean?

01:01:24.900 --> 01:01:32.160
Like, like use, use source control as a sort of a save along the way there.

01:01:33.340 --> 01:02:36.080
You've got a bunch of tips and stuff very give us specific tips yes i know okay number one thing i actually feel like i can clear uh i have better clarity around technical debt and how important it is to get rid of tactical debt now because if an l if you're using it like an agent and it it like is looking to pattern match to your what you have in your code base and it finds the area that you know is like basically technical debt and it copies that and you don't you know like you're not really on top of looking through the code, it will often copy design patterns that you really do not want in your code base. And so I actually feel like it allows you to make the argument that cleaning up technical debt is more important when you use LLMs and agents than when you were doing things by hand where you knew as a developer, I'm just going to ignore that section of the code and I'm not going to use it. So that's like a very specific tip, which is like, if you are going to pattern match against something you're doing in your code base, make sure it's not copying the area that you know is a problem.

01:02:36.940 --> 01:02:42.260
And then just like shipping that. I think that's, that's one. You don't want to supercharge your bad

01:02:42.400 --> 01:02:48.780
habits. Yeah. Yeah. I would say on top of this, you absolutely do want to clean up technical debt.

01:02:50.240 --> 01:03:05.560
You can, when it's done, say great work, that's valid, but now please apply some dry principles and some design patterns that you know that we're already using and just polish this up one more time and you'll get pretty good results.

01:03:06.280 --> 01:03:18.920
On the other side is if you've got a project that's got a ton of technical debt, you can kind of just have this conversation with the agentic AI and say, help me understand, like, where are the long functions?

01:03:19.460 --> 01:03:20.440
Where is there too much coupling?

01:03:20.650 --> 01:03:22.520
Like, let's start breaking that down.

01:03:22.690 --> 01:03:26.560
And when it's in that mindset, it's pretty good at like addressing those problems.

01:03:27.580 --> 01:03:32.800
Right. And that's the flip side of the technical debt is it should be easier, arguably, to clean up technical debt.

01:03:32.880 --> 01:03:39.800
Because if you fix something or you're asking the agent, be introspective, how could this be improved?

01:03:40.220 --> 01:03:41.180
What are the design patterns?

01:03:41.620 --> 01:03:44.680
And particularly, at least in Cloud Code, there's a plan mode.

01:03:44.920 --> 01:03:47.080
I use plan mode. It's like shift tab.

01:03:47.880 --> 01:03:53.780
I use it all the time because then it's going to just tell you what it's going to do, not go and do it.

01:03:53.860 --> 01:03:54.940
Not going to make any changes.

01:03:55.680 --> 01:03:59.780
And so I will ask it, how can I optimize these database queries?

01:04:00.300 --> 01:04:03.420
How can I simplify this code without oversimplifying?

01:04:03.660 --> 01:04:04.200
That type of thing.

01:04:04.620 --> 01:04:09.280
And that's actually really helpful for just identifying what changes actually should be made.

01:04:09.740 --> 01:04:14.300
Then I can make the decision, are you going to go ahead and implement those, or should I just go ahead and implement them?

01:04:14.410 --> 01:04:16.560
Because they're easy enough for me to make the changes myself.

01:04:18.120 --> 01:04:18.780
MARK MANDEL: Awesome.

01:04:19.600 --> 01:04:19.900
Next tip.

01:04:20.920 --> 01:04:26.780
Yeah. So I feel like you've already talked a little bit about this.

01:04:26.860 --> 01:04:29.620
Like the context is really important and the prompting is important.

01:04:29.960 --> 01:04:37.820
I will say that like where I failed in the past and I like was not happy with LLMs was like, I'd say something like, can you just write a bunch of unit tests for this thing?

01:04:38.420 --> 01:04:40.280
And like, of course, it's not going to have enough.

01:04:40.700 --> 01:04:43.420
Like I give it the code that I want it to be testing.

01:04:44.040 --> 01:04:51.880
But now what I found is like, after I have it write some code, I will say like, okay, now write me like a few happy paths.

01:04:52.300 --> 01:04:53.720
And I'll like evaluate the happy paths.

01:04:53.760 --> 01:04:55.360
And I'll be like, write the unhappy paths.

01:04:55.440 --> 01:04:57.500
And I'll like look at those and how it's failing.

01:04:57.740 --> 01:04:59.380
And then I'm like, what are the edge cases?

01:04:59.700 --> 01:05:04.380
And so you just have to, even if you, like a lot of people are like, oh, here's how you write the perfect prompt.

01:05:04.500 --> 01:05:10.040
Like, I actually really hate doing that because what if I wrote the perfect prompt and it still didn't give me what I wanted at the other side?

01:05:10.560 --> 01:05:13.260
Then you have to tell it it's going to go to jail, please, you know?

01:05:13.580 --> 01:05:32.000
I just tend to be really incremental. I'm like really specific, like, just like, again, going back to like that junior developer mentality is like, just write me like three happy path tests to test this function. Like, give me some inputs and the expected outputs. Okay, now I want you to write the things that like basically would break it and make sure that it doesn't break.

01:05:32.860 --> 01:05:41.560
So what that does is like, rather than I have not found success, or it's been a lot harder with like, write me a bunch of tests, both happy path than unhappy path.

01:05:41.600 --> 01:05:47.300
And then it's kind of, you know, depending which model you're using or what day you get, like it may or may not be correct.

01:05:47.560 --> 01:05:59.300
And so it's also think about like for yourself and your own sanity, when you're doing reviewing the changes that it's making, you really want it to just like be consumable, like, okay, those are the happy path.

01:05:59.520 --> 01:06:03.340
mentally you're like, okay, happy path tests or mentally not that.

01:06:04.620 --> 01:06:12.420
You should, if you instruct it in the way that you want to consume the information that it's created out the other side, that can actually be really helpful as well.

01:06:14.140 --> 01:06:17.600
Yeah, I find it's terrible if you just, this project needs tests, write tests.

01:06:17.860 --> 01:06:22.220
It ends up testing like just the smallest arbitrary aspects of the code.

01:06:22.220 --> 01:06:23.080
And you're like, what is this?

01:06:23.400 --> 01:06:26.560
Like now I got to maintain this junk

01:06:26.780 --> 01:06:28.040
that like one plus one is two.

01:06:28.200 --> 01:06:30.940
like, no, this is not what I want from you, right?

01:06:30.960 --> 01:06:33.120
You got to be really specific and do bite size.

01:06:33.380 --> 01:06:37.000
And it's a little bit of the plan too, like maybe plan out like the types of tests we should have.

01:06:37.200 --> 01:06:41.580
Okay, let's do this first one and focus, you know, like really guide it a little bit.

01:06:41.680 --> 01:06:44.560
Treat it like it's a junior that's kind of new to this stuff.

01:06:44.700 --> 01:06:47.940
Don't just, you wouldn't tell the junior, like we need to refactor the architecture.

01:06:48.020 --> 01:06:49.040
I'll see you next week.

01:06:49.140 --> 01:06:50.540
You're like, whoa, what are you going to get back?

01:06:50.760 --> 01:06:51.160
You don't know.

01:06:51.380 --> 01:06:55.120
Yeah, well, maybe like three quick, like lightning round tips.

01:06:55.800 --> 01:06:56.240
Yeah, do it.

01:06:56.340 --> 01:07:09.520
One of them, mostly just I thought about because I do this with, I have been doing this for years, where if I'm working on different projects or different part of the code base, like I will just use different terminal backgrounds, different colors.

01:07:09.740 --> 01:07:11.060
This is my blue terminal.

01:07:11.280 --> 01:07:17.040
This is my, so like blue is like where I've got Tmux and Vim and I'm like running a bunch of stuff.

01:07:17.220 --> 01:07:17.320
Exactly.

01:07:18.120 --> 01:07:22.660
And then, yeah, I think my colleague, Amit, tweeted about this.

01:07:23.260 --> 01:07:31.420
And then black will be, I'm running the server, I'm running my task queue, all the stuff that is like running right now, local development.

01:07:32.100 --> 01:07:35.960
Then if I'm like tailing a bunch of logs on the server, like that'll be in another different color.

01:07:36.220 --> 01:07:39.520
So just- Does this happen automatically?

01:07:39.580 --> 01:07:41.940
No, I actually just open up separate terminals.

01:07:42.080 --> 01:07:42.380
Gotcha, gotcha.

01:07:42.440 --> 01:09:19.000
within that i'll have different team up sessions running uh where i can just be like again it is has nothing to do with the computer it has everything to do with me a lot of times just doing a ton of context switching so i've found this to be applicable as a pattern for for the agents if i'm having an agent that works primarily on one part of the code base then i will just like have that be blue and then another part of the code base have it be black right so um again like i also this maybe goes right into the second tip which is a lot of people are like still microservices versus monolith like i actually think that the perfect design pattern right now for a lot of projects is like much closer to monolith but like you split it up into like based off of the number of agents that you want to run so like for me i've got like my web scraping and like data collection stuff and like i generally just want like one maybe two agents so like that is like a separate project and then it interfaces with everything else through apis like actual like web apis and so like that is actually how i've architected things where i'm like how many developers developers agents do i want working on the code base at once like what is my actual capacity to review the code as a single developer there's only so much capacity that i have and so i will actually architect um or i've started to architect around that but that doesn't mean i have a thousand microservices it typically means that i split the architecture into like three or four components um maybe two beyond the main application and that helps me to just feel like i'm being productive without being overwhelmed

01:09:19.540 --> 01:09:25.799
yeah it's also good advice just for working in small teams anyway yeah yeah exactly and it's

01:09:25.799 --> 01:09:31.540
like a little bit more of the teams are automated right it's crazy yeah it's it's like a pragmatic like I'm not doing crazy microservices.

01:09:31.620 --> 01:09:34.520
I'm not also like, I'm not also doing like monolith everything, right?

01:09:34.720 --> 01:09:38.960
So I think that to me, I'll just kind of be a little bit more, more pragmatic about things.

01:09:39.540 --> 01:09:39.700
Yeah.

01:09:39.799 --> 01:09:48.920
I wonder if you could automate, if you could, if you could AI agentic code some form of automatic color profile selecting.

01:09:50.520 --> 01:09:53.759
I mean, yeah, they go pretty good on bash scripts.

01:09:53.859 --> 01:09:55.060
I mean, it's possible.

01:09:56.380 --> 01:09:57.640
I've one, one last tip,

01:09:58.020 --> 01:09:59.180
which kind of bit me.

01:09:59.720 --> 01:10:02.380
Luckily, I'm running Sentry.

01:10:03.080 --> 01:10:05.200
Shout out to the Sentry team for Blush Cap.

01:10:05.500 --> 01:10:06.740
And I caught this bug.

01:10:07.420 --> 01:10:09.920
And a lot of times I'm finding bugs.

01:10:09.950 --> 01:10:11.380
Like, oh, it's a 500 error or whatever.

01:10:12.020 --> 01:10:12.560
Not the end of the world.

01:10:12.740 --> 01:10:13.480
I go and fix it.

01:10:14.220 --> 01:10:17.540
I have definitely written more bugs myself by hand.

01:10:20.000 --> 01:10:22.880
Now that I have a mixed toolkit.

01:10:25.140 --> 01:11:05.440
It's just something to be mindful of, which is like, I'm so used to having like bits and pieces written by an agent, and then I review it, that when I'm writing code, I have like my, it's almost like overconfidence, like I review a lot of code. I actually almost feel like the agent should be reviewing the code that I'm writing by hand. And so I'll just say like, that's one thing that I feel like is a big tip for developers and might bite a lot of people as they spend somewhat less time writing code, especially like low level kind of like rote detail kind of stuff and then they have then they are like i'll go do that real quick and then they suddenly like introduce a bug and they're like oh geez i didn't yeah yeah haven't

01:11:05.460 --> 01:11:25.380
done this like yeah by hand with the clickety click for a while yeah exactly exactly yeah i um i think that we need to we need to embrace and be mindful like you're saying um a certain level of like student mind when we're doing this kind of stuff.

01:11:25.870 --> 01:11:33.240
I mean, you say you've been using clock code for like six months and these are starting to show up, like imagine 10 years down the line, you know what I mean?

01:11:33.360 --> 01:11:35.520
It could be seriously an issue.

01:11:36.280 --> 01:11:36.640
Yeah.

01:11:37.050 --> 01:11:42.020
I did help one person do a bunch of agentic coding and I won't name it.

01:11:42.040 --> 01:11:46.600
Cause I'm not sure they want to be named, but, they, they really were like, wow, this is incredible.

01:11:46.880 --> 01:11:58.640
And the thing that surprises me, they said, was as it's going through maybe 30 or 40 things it does to process a request, it's explaining why it's doing it.

01:11:58.790 --> 01:12:02.140
It says, okay, now I need to make sure that this runs in this way.

01:12:02.260 --> 01:12:06.740
So let's do this like Django, this ManagePy command or something like that, right?

01:12:07.240 --> 01:12:13.120
And they're like, I'm actually, if I'm paying attention, I'm actually learning new things about how this is supposed to be done.

01:12:14.020 --> 01:12:16.080
And in the end, it says, here's why I made these changes.

01:12:16.660 --> 01:12:18.920
I think it's so easy to just go, great, next.

01:12:19.540 --> 01:12:20.140
You know what I mean?

01:12:20.300 --> 01:12:20.360
Yeah.

01:12:20.540 --> 01:12:22.260
But if we just slow down a little bit

01:12:22.970 --> 01:12:25.360
and use those opportunities, learn, you learn.

01:12:25.480 --> 01:12:26.040
I've learned a ton.

01:12:26.680 --> 01:12:30.060
Like I can just hit escape and I'm like, tell me why you're doing that.

01:12:30.090 --> 01:12:32.440
I'm not really sure why you're doing that.

01:12:32.960 --> 01:12:33.800
And it'll explain it.

01:12:34.000 --> 01:12:36.700
And then you can, it's the back and forth.

01:12:36.790 --> 01:12:44.920
I mean, it is like having the conversation about code that you often can't have with another developer.

01:12:45.220 --> 01:12:47.620
It's really expensive to take your whole team's time

01:12:47.800 --> 01:12:49.880
to talk through some change to the code base.

01:12:49.940 --> 01:12:51.020
You can have all those conversations.

01:12:51.560 --> 01:12:58.180
And I personally find, as someone who is relatively introverted, it is not taxing on me to just have that conversation with the computer.

01:12:58.420 --> 01:13:03.880
So I can still have all the conversations with the humans and not be drained by the conversation with the computer.

01:13:04.040 --> 01:13:04.940
- Yeah, that's awesome.

01:13:05.140 --> 01:13:12.600
And think of the opportunity for people who either are sole developers or they live in places where they can't go to user group meetup type things.

01:13:12.780 --> 01:13:12.940
- Yeah.

01:13:13.520 --> 01:13:13.800
- Yeah.

01:13:14.380 --> 01:13:20.360
Or they're like busy in meetings all day and they still want to be a productive developer and be hands on with this stuff.

01:13:20.550 --> 01:13:25.780
And not, you know, I think a big part of it is like not getting caught up too much with the whole hype cycle.

01:13:26.600 --> 01:13:39.520
I am firmly in the camp that like this is while this is a shift, it is it is not that big of a shift compared to like when they said, oh, software developers are going to go away because we have COBOL.

01:13:40.060 --> 01:13:44.060
Software developers are going to go away because we have code generation off UML diagrams.

01:13:44.740 --> 01:13:47.700
software developers are going to go away because of low code, no code.

01:13:48.420 --> 01:13:56.440
I get the sense having used these tools that a lot of companies will use them in the wrong way of thinking they can just replace developers.

01:13:56.630 --> 01:14:01.980
And actually what they're doing is they're building up a massive amount of technical debt and they're going to need software developers to fix it.

01:14:02.120 --> 01:14:02.220
Yeah.

01:14:02.500 --> 01:14:06.360
So that's, I just, I think it's building further layers of abstraction and more code.

01:14:06.770 --> 01:14:15.540
I think that you and I and everyone else out there who is very competent coders pre AI, we're going to be a little bit like cobalt programmers.

01:14:15.850 --> 01:14:25.520
I think there's going to be places that are just like, look, we've just got to call some people that know how to write code and figure this out. Like this stuff, the crazy analogy,

01:14:26.210 --> 01:14:29.360
the crazy analogy is like, okay, this is what I read one.

01:14:29.590 --> 01:14:37.540
Like, so that like the U boats during German, you boats during world war one have like a pre they've steel in them.

01:14:37.900 --> 01:15:03.440
That is pre, or it's not been affected by like nuclear, uh the nuclear bombs that were set off around you know during and after world war ii so like they will extract the steel from those because they're not uh affected by the radiation i guess we're like the old u-boats they're going to extract those from retirement and be like you still know how to program in this esoteric language the llms can't do it i don't know maybe that's gonna take

01:15:03.450 --> 01:15:19.740
the mothballs out that's right yeah and we're going back into into service it's boy it's an interesting time. And there's a lot of opportunity as, as you pointed out. So I want to leave people with message of don't be scared, embrace this, see what it can do for you. There's a lot

01:15:19.740 --> 01:15:36.460
of opportunity here, but Matt, you get the final word. Yeah. I mean, I agree. I think it's, again, it's like the same philosophy we started with, which is like, I don't see this as, as that big of a shift compared to like a lot of the other stuff that's happened in industry. like just, I would just learn these things.

01:15:36.570 --> 01:15:41.800
And frankly, like then you are empowered to say like, I'm not going to use that because you've tried it.

01:15:42.660 --> 01:15:45.080
And so like then you have an informed opinion on it.

01:15:45.740 --> 01:15:53.600
And I think that's really what matters as software developers, not to just like dismiss something simply because it seems like a hype cycle, but actually just to try it.

01:15:53.770 --> 01:15:56.180
And if it doesn't work and you're like, well, I have an informed opinion.

01:15:56.570 --> 01:15:59.180
I will say, though, this is actually rapidly evolving.

01:15:59.250 --> 01:16:08.620
And as we've talked about through our conversation, I would actually try this multiple times over several months because it is does get better and it does get, it does change with the tools.

01:16:08.850 --> 01:16:11.340
And so it's not just like I tried it once and I'm going to toss it away.

01:16:11.990 --> 01:16:15.040
I would give it a try every few months and see if it works for, you know,

01:16:15.160 --> 01:16:16.880
kind of clicks for you, it kind of works for your use case.

01:16:17.380 --> 01:16:17.580
Yeah.

01:16:17.780 --> 01:16:24.760
If you try, if we had this conversation, pre-agentic code agents could be, could be very, very different, but six months later, look,

01:16:24.920 --> 01:16:28.200
it's just, it's just like, it's just like when open source was like nascent.

01:16:28.980 --> 01:16:30.280
Oh, I tried open source once.

01:16:30.920 --> 01:16:34.740
If you haven't tried it in 15 years, like, I don't know what to say.

01:16:34.910 --> 01:16:34.980
Right.

01:16:35.220 --> 01:16:37.620
I think it's a similar thing, but it's just a little bit faster evolution.

01:16:38.060 --> 01:16:38.120
Yeah.

01:16:38.440 --> 01:16:39.920
Yeah, it's crazy times.

01:16:40.100 --> 01:16:49.140
I mean, I'm honestly thinking maybe we should ship this episode like this week without recording, not the two weeks out that is scheduled to be recording because who knows what's going to happen.

01:16:49.500 --> 01:16:49.980
No, I'm just kidding.

01:16:50.300 --> 01:16:51.900
But they are changing fast.

01:16:53.500 --> 01:16:55.280
Well, thanks for coming back on the show.

01:16:55.380 --> 01:16:56.480
Always great to catch up with you.

01:16:57.300 --> 01:16:57.600
Thanks, Michael.

01:16:57.920 --> 01:16:58.180
It's been great.

01:16:58.280 --> 01:16:58.840
Yeah, bye.

01:17:26.740 --> 01:17:27.240
Bye.

