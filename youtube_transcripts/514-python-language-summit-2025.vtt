WEBVTT

00:00:00.939 --> 00:00:02.840
Seth, welcome back to Talk Python.

00:00:03.000 --> 00:00:03.880
Awesome to have you here.

00:00:04.610 --> 00:00:05.200
Thank you for having me, Michael.

00:00:06.879 --> 00:00:08.860
Yeah, it's always fun to have you on the show.

00:00:10.340 --> 00:00:10.820
You know what?

00:00:10.930 --> 00:00:14.680
I don't even think we're going to talk that much about security this episode, are we?

00:00:16.139 --> 00:00:16.960
Not too much, no.

00:00:18.279 --> 00:00:19.260
As I say that,

00:00:19.500 --> 00:00:21.060
I'm sure we're going to come up with something, right?

00:00:21.110 --> 00:00:22.820
But the last couple of times I've had you on,

00:00:24.079 --> 00:00:28.080
it's because you're doing something with security and Python,

00:00:28.580 --> 00:00:30.200
And it's always been very interesting.

00:00:30.460 --> 00:00:30.660
It's

00:00:30.660 --> 00:00:30.860
true.

00:00:30.980 --> 00:00:33.440
Yeah, no, I do a lot of security these days, but I do other things too.

00:00:36.200 --> 00:00:41.420
Like be the eyes and ears of everyone who could not attend the Language Summit?

00:00:42.720 --> 00:00:44.860
Yeah, so I was the blogger again this year.

00:00:44.920 --> 00:00:45.740
I got invited back.

00:00:45.900 --> 00:00:47.860
They liked what I did last year.

00:00:48.000 --> 00:00:49.560
So they're like, ah, well, we'll have this guy again.

00:00:49.700 --> 00:00:49.980
Why not?

00:00:50.140 --> 00:00:50.220
Right?

00:00:51.140 --> 00:00:51.860
Yeah, it was great.

00:00:52.080 --> 00:00:54.200
I mean, I love attending the Language Summit and blogging for it.

00:00:54.400 --> 00:00:58.860
It's a really unique way to contribute back to the Python community.

00:00:59.280 --> 00:01:00.540
It's such a specific role.

00:01:01.800 --> 00:01:03.060
Yeah, it really is.

00:01:03.060 --> 00:01:04.900
I think maybe we start there.

00:01:05.080 --> 00:01:09.740
Maybe we start with what is the Language Summit

00:01:10.460 --> 00:01:14.180
and why are there not just a bunch of videos online

00:01:14.400 --> 00:01:18.320
and why aren't there sessions that necessarily open sessions at PyCon, right?

00:01:18.440 --> 00:01:20.400
It's kind of a special event.

00:01:21.680 --> 00:01:29.540
Yeah, so the Language Summit is, historically, it is this event that happens every year before, right before PyCon US.

00:01:30.160 --> 00:01:34.500
It's been hosted in other PyCons as well, but nowadays it happens at PyCon US.

00:01:35.560 --> 00:01:38.880
And it occurs kind of at the same time that tutorials are happening.

00:01:39.000 --> 00:01:44.640
So that's a day or two before the actual conference starts for most attendees where there's talks and all of that.

00:01:45.800 --> 00:01:58.180
And basically what ends up happening is a bunch of core developers and triagers and some special guests all convene into one room for a full day of short talks followed by tons of discussion.

00:01:59.860 --> 00:02:03.420
And the reason that it's a closed session is, one, it's a logistical thing.

00:02:03.690 --> 00:02:05.460
The room is only so big.

00:02:05.740 --> 00:02:12.860
And I'm pretty sure the organizers know that if it was just open session, it would be like, oh, we need to have this huge conference room of people.

00:02:12.930 --> 00:02:14.900
And it's not really conducive to discussion.

00:02:15.020 --> 00:02:21.480
because it is very fast-moving, asking questions, getting answers,

00:02:21.740 --> 00:02:25.060
and having people be able to exchange this information really quickly.

00:02:26.020 --> 00:02:29.500
And so to offset the lack of openness, right,

00:02:29.680 --> 00:02:32.620
because not everyone can possibly attend that wants to attend,

00:02:33.380 --> 00:02:37.840
what ends up happening is a blogger, someone who covers the actual event,

00:02:38.120 --> 00:02:41.460
every single talk, every single discussion, all the questions, what gets discussed,

00:02:42.260 --> 00:02:45.960
And then like the vibes of the room and like how people are feeling about topics.

00:02:47.100 --> 00:02:50.320
That gets covered by a blogger, which this year was me.

00:02:50.500 --> 00:02:51.280
Last year was also me.

00:02:51.380 --> 00:02:56.720
But then the years prior has been like Alex Waygood covered the year prior to me starting.

00:02:57.500 --> 00:03:00.600
So Alex taught me everything I need to know and what to expect and all of that.

00:03:01.080 --> 00:03:01.280
Nice.

00:03:01.450 --> 00:03:01.560
Yeah.

00:03:01.570 --> 00:03:04.360
And I had you on last year and I had Alex on the year before, I believe.

00:03:04.620 --> 00:03:05.900
So it's a bit of a tradition.

00:03:06.300 --> 00:03:06.680
There we go.

00:03:10.020 --> 00:03:10.120
Cool.

00:03:10.340 --> 00:03:15.920
And yeah, also people should know it's a working session with the goal of not just presenting ideas,

00:03:16.320 --> 00:03:25.780
but making decisions, trying to come to an agreement with the core devs and steering council and maybe other councils, as we'll see, all the councils.

00:03:26.520 --> 00:03:27.380
Yeah, yeah, right.

00:03:27.490 --> 00:03:30.040
No, it's lots of decision makers in there.

00:03:30.180 --> 00:03:34.260
I feel like it tends to be a really great arena

00:03:34.620 --> 00:03:37.900
to kind of just get really quick feedback

00:03:38.340 --> 00:03:40.220
on either ideas or questions.

00:03:40.920 --> 00:03:41.880
Because it's really funny,

00:03:42.180 --> 00:03:43.780
one of the talks happened,

00:03:45.100 --> 00:03:46.540
not to get into too much detail right away,

00:03:46.600 --> 00:03:47.680
but one of the talks happened,

00:03:47.700 --> 00:03:48.800
they're like, oh, we have this problem.

00:03:48.940 --> 00:03:51.360
We really need more ARM builders for GitHub CI

00:03:51.700 --> 00:03:52.600
for this specific reason.

00:03:53.380 --> 00:03:56.020
And E. Durbin, Director of Infrastructure at PSF,

00:03:56.100 --> 00:03:57.880
was in the room, and they were just like,

00:03:57.920 --> 00:03:58.760
oh, I just bought more.

00:03:59.680 --> 00:04:01.100
And it's like, oh, great.

00:04:01.320 --> 00:04:01.740
That's

00:04:01.740 --> 00:04:01.960
awesome.

00:04:02.520 --> 00:04:03.280
Quick feedback.

00:04:04.780 --> 00:04:05.820
That's the way to make it happen.

00:04:06.400 --> 00:04:06.720
That's right.

00:04:08.040 --> 00:04:16.160
You know, before we get into that, just maybe it's worth a quick conversation about.

00:04:16.280 --> 00:04:17.820
You were actually in New York City.

00:04:18.380 --> 00:04:20.079
We just heard a siren go by.

00:04:20.239 --> 00:04:23.240
So we now officially know that you're in New York City, right?

00:04:23.800 --> 00:04:23.980
Yes.

00:04:24.260 --> 00:04:24.620
There's always

00:04:24.620 --> 00:04:27.000
something going on there in terms of

00:04:27.000 --> 00:04:28.380
noise

00:04:28.380 --> 00:04:29.500
or energy or whatever.

00:04:31.020 --> 00:04:33.920
for the UN Open Source Conference.

00:04:34.460 --> 00:04:35.300
That's super interesting.

00:04:35.350 --> 00:04:35.760
What is that?

00:04:36.260 --> 00:04:38.800
Yeah, so United Nations Open Source Week.

00:04:39.050 --> 00:04:42.460
I got invited to attend through the Sovereign Tech Agency

00:04:42.590 --> 00:04:43.620
and also Alpha Omega.

00:04:44.440 --> 00:04:48.900
They are collaborating to host a maintain-a-thon,

00:04:49.200 --> 00:04:53.340
which is essentially just get a whole bunch of open source project maintainers,

00:04:53.560 --> 00:04:55.080
project leaders, governance people,

00:04:55.220 --> 00:04:56.800
like people doing more than just security.

00:04:57.030 --> 00:04:59.420
So I was there to represent the security perspective.

00:05:00.060 --> 00:05:02.160
and also Python, Python Software

00:05:02.160 --> 00:05:02.480
Foundation.

00:05:04.500 --> 00:05:05.660
And just getting us all together

00:05:06.100 --> 00:05:08.380
and trying to talk about really complicated issues

00:05:09.180 --> 00:05:11.540
for open source and how open source can be used

00:05:12.060 --> 00:05:14.700
to better the world, to be a part of

00:05:14.980 --> 00:05:17.520
a more open access world, more open data world.

00:05:18.320 --> 00:05:19.540
Those are kind of like the themes.

00:05:20.599 --> 00:05:22.700
Specifically the maintain-a-thon was more

00:05:23.460 --> 00:05:25.880
like hosting small sessions with lots of discussion,

00:05:26.160 --> 00:05:28.819
almost kind of like the language summit where there's a really short

00:05:28.880 --> 00:05:35.600
presentation about a topic. I presented on low energy security. So security practices and

00:05:36.060 --> 00:05:41.580
processes for projects that don't have access to tons of security expertise. And then like,

00:05:41.660 --> 00:05:45.760
what are the, how can we make the situation better for those types of projects?

00:05:46.980 --> 00:05:52.879
Oh, very cool. There's, you know, there's a lot of energy for open source in the United States

00:05:53.600 --> 00:05:59.500
corporately, but internationally, there's a lot of energy for open source at a governmental level,

00:06:00.680 --> 00:06:06.580
way more so than the U.S. I mean, there's little pockets of things like, hey, we'd like to have

00:06:06.680 --> 00:06:12.220
some open source initiatives for what we're building in the U.S., but there's, I can't remember what

00:06:12.460 --> 00:06:17.800
country's doing it right now, one of the countries is trying to replace basically Microsoft Office and

00:06:18.340 --> 00:06:21.560
Windows with something Linux and open source, and there's a lot of stuff like that.

00:06:22.700 --> 00:06:22.740
Yeah,

00:06:23.140 --> 00:06:25.320
I mean, it's about having sovereignty

00:06:25.640 --> 00:06:27.700
over your technology stack, right?

00:06:27.940 --> 00:06:30.180
Making sure that you have complete control

00:06:30.580 --> 00:06:31.700
and that there's interoperability

00:06:32.020 --> 00:06:35.380
and that, yeah, being able to work independently

00:06:36.180 --> 00:06:37.320
as like a government agency,

00:06:37.560 --> 00:06:38.880
just as important as a company, right?

00:06:38.960 --> 00:06:39.040
You

00:06:39.040 --> 00:06:39.800
want to make sure

00:06:39.800 --> 00:06:41.460
that you're able to control

00:06:41.620 --> 00:06:43.280
all the processes and data that are inside

00:06:43.780 --> 00:06:44.480
that are important to you.

00:06:45.500 --> 00:06:51.139
Sure, and I think we're in a bit of a special situation

00:06:51.160 --> 00:06:57.200
being in the U.S., I don't think we have as much of a feeling of,

00:06:57.900 --> 00:07:00.440
wouldn't it be nice if we weren't beholden to U.S. companies?

00:07:01.240 --> 00:07:03.040
Because we're already beholden to the U.S.

00:07:03.050 --> 00:07:05.380
We live here, we pay taxes, we're subject to the rules.

00:07:05.900 --> 00:07:07.440
But if you're outside of the U.S.,

00:07:08.080 --> 00:07:11.640
most countries and organizations are still beholden to U.S. companies.

00:07:11.870 --> 00:07:16.640
And I think that that's a part of the vein of

00:07:16.640 --> 00:07:18.140
the ideas there, right?

00:07:18.460 --> 00:07:19.800
Yeah, it definitely is a part of it.

00:07:19.920 --> 00:07:24.020
being able to do your own thing without worrying about other countries,

00:07:24.130 --> 00:07:25.980
what they're doing or what their relationship is with you,

00:07:26.180 --> 00:07:28.980
and still being able to interoperate on a global scale, right?

00:07:29.160 --> 00:07:32.620
Because a lot of these formats are open and they interoperate,

00:07:32.800 --> 00:07:34.340
like PDF, DocX,

00:07:34.540 --> 00:07:35.020
they're

00:07:35.020 --> 00:07:36.460
all open.

00:07:36.590 --> 00:07:39.020
They can be written by any software, not just

00:07:39.020 --> 00:07:39.780
Microsoft software.

00:07:40.480 --> 00:07:40.860
Yeah, absolutely.

00:07:41.960 --> 00:07:46.820
And I guess that's true for the U.S. in terms of software,

00:07:47.020 --> 00:07:48.800
but not so much for hardware, right?

00:07:48.940 --> 00:07:52.480
We're more in the same boat as everyone else with hardware.

00:07:52.700 --> 00:07:56.440
But that is a bit too far down the weeds maybe,

00:07:56.600 --> 00:07:57.700
so we don't need to debate that.

00:07:57.730 --> 00:07:59.520
But it's super interesting that you're at that conference,

00:07:59.860 --> 00:08:00.720
and it sounds really fun.

00:08:01.360 --> 00:08:02.240
Yeah, it's a great time.

00:08:02.400 --> 00:08:03.520
A lot of really smart people here,

00:08:03.590 --> 00:08:06.360
so I'm happy that they let me in.

00:08:08.060 --> 00:08:08.580
How'd I get here?

00:08:09.680 --> 00:08:10.020
Exactly.

00:08:10.380 --> 00:08:12.360
What office did you run for to get elected to that?

00:08:12.590 --> 00:08:12.680
Oh,

00:08:13.080 --> 00:08:13.740
none. None of them.

00:08:16.160 --> 00:08:16.360
Cool.

00:08:18.260 --> 00:08:21.000
So let's talk Language Summit.

00:08:23.400 --> 00:08:25.460
When we started sort of backstage,

00:08:25.770 --> 00:08:28.300
we were trying to plan out some of the themes and stuff.

00:08:28.760 --> 00:08:31.340
You talked about there being a couple of major themes

00:08:31.550 --> 00:08:32.919
of the Language Summit this year.

00:08:33.099 --> 00:08:34.860
And I certainly, reading your write-up,

00:08:35.120 --> 00:08:38.880
thought like, wow, multi-threading has got some attention.

00:08:40.140 --> 00:08:43.280
Yeah, free-threading was a big part of the Language Summit.

00:08:43.330 --> 00:08:45.939
I think it was like a third, somewhere between a third

00:08:45.960 --> 00:08:50.080
and a half of the talks touched free threading

00:08:50.360 --> 00:08:53.300
or parallelism or the concurrency model of Python.

00:08:54.440 --> 00:08:55.580
It was obviously a big theme.

00:08:58.340 --> 00:08:59.880
Yeah, what are some of the other themes?

00:09:00.820 --> 00:09:03.380
Yeah, so the other ones are things like,

00:09:03.660 --> 00:09:06.160
okay, we have all these other platforms for Python.

00:09:06.480 --> 00:09:10.160
If you read the last year's Language Summit,

00:09:11.100 --> 00:09:14.320
there's kind of this through line of mobile and web,

00:09:14.660 --> 00:09:15.740
both kind of got discussed.

00:09:16.060 --> 00:09:24.260
And so if you contrast the status of those projects then, what the write-ups were to now, the projects are way further down the line.

00:09:24.460 --> 00:09:32.280
So Russell came up and got to say, oh, mobile for Python, both on Android and iOS, are basically here.

00:09:32.680 --> 00:09:44.800
And a huge round of applause from all the core devs because they were super successful in achieving the mission that they set out to do back a year ago at the Language Summit where they laid out what their plans were.

00:09:45.860 --> 00:09:52.580
so yeah there it will be basically mobile support i think it's for three working i think is the hope

00:09:52.780 --> 00:09:58.340
that it's going to be actually like working and you should use it and you can build apps with it

00:09:59.110 --> 00:10:00.140
yeah that's really exciting

00:10:00.140 --> 00:10:02.120
it

00:10:02.120 --> 00:10:03.500
is very exciting yeah

00:10:03.500 --> 00:10:05.980
and then the other platform is web obviously so

00:10:06.639 --> 00:10:11.179
pyodide is one of the big ones there so if you've heard of like pi script or

00:10:12.420 --> 00:10:18.560
jupyter lite uses pyodide both of those platforms like for python on the web

00:10:19.430 --> 00:10:25.980
there was this talk about upstreaming the ffi the javascript ffi and some javascript apis

00:10:26.460 --> 00:10:30.240
to see python as opposed to keeping them resident in pyodide

00:10:30.240 --> 00:10:31.420
and

00:10:31.420 --> 00:10:32.520
what that would essentially mean

00:10:32.520 --> 00:10:41.160
is that if you ran python compiled for what was it like the like WebAssembly platform you would

00:10:41.180 --> 00:10:43.000
able to interact with JavaScript from

00:10:43.220 --> 00:10:45.080
the standard library, like the OS module

00:10:45.180 --> 00:10:45.920
or something like that.

00:10:46.840 --> 00:10:49.120
It's pretty exciting to hear something

00:10:49.140 --> 00:10:50.920
like that. And there was also some talk about

00:10:51.580 --> 00:10:52.920
apparently recently MicroPython

00:10:53.340 --> 00:10:55.120
got web support, and so trying to

00:10:55.540 --> 00:10:56.820
unify a little bit the

00:10:57.140 --> 00:10:58.840
APIs that the two are using.

00:11:00.100 --> 00:11:01.060
Yeah, that's super exciting.

00:11:01.320 --> 00:11:02.540
We'll definitely dive into it, but

00:11:03.820 --> 00:11:05.460
the fact that MicroPython

00:11:05.740 --> 00:11:06.440
got web support

00:11:07.100 --> 00:11:08.960
means it's possibly

00:11:09.420 --> 00:11:10.540
a good use for

00:11:11.220 --> 00:11:12.680
broader web applications, right?

00:11:12.700 --> 00:11:13.740
Because PyDyde is awesome,

00:11:14.260 --> 00:11:16.140
but it's also something like 10 megs.

00:11:16.820 --> 00:11:17.860
Or somewhere

00:11:17.860 --> 00:11:18.640
in megs,

00:11:18.640 --> 00:11:19.660
and it takes a bit to load up

00:11:19.780 --> 00:11:21.480
because it is basically CPython.

00:11:22.380 --> 00:11:23.880
Whereas MicroPython is 100K.

00:11:24.540 --> 00:11:26.420
And people are used to doing 100K JavaScript,

00:11:26.540 --> 00:11:31.040
but not multi-meg JavaScripts for standard stuff.

00:11:31.260 --> 00:11:32.180
So yeah, really exciting.

00:11:33.020 --> 00:11:33.680
We'll dive into that.

00:11:33.940 --> 00:11:34.580
We'll dive into that.

00:11:37.400 --> 00:11:38.740
So not surprising.

00:11:38.940 --> 00:11:42.200
I thought we could just maybe work our way through the different presentations.

00:11:43.500 --> 00:11:45.680
How long is each presentation besides the lightning talks?

00:11:46.760 --> 00:11:51.320
Yeah, so each session is, I think it's like 30 minutes.

00:11:52.620 --> 00:11:55.120
The talk itself is usually like 10 minutes.

00:11:55.230 --> 00:11:56.260
I could actually think of the schedule.

00:11:56.370 --> 00:11:57.760
I should know this off the top of my head.

00:11:58.160 --> 00:11:59.580
The presentations are super fast.

00:11:59.680 --> 00:12:02.160
They're like 10 minutes, and then the rest is discussion.

00:12:02.880 --> 00:12:03.660
So it's quite

00:12:03.660 --> 00:12:05.520
a quick format.

00:12:06.620 --> 00:12:08.560
And your write-up mirrors that, right?

00:12:08.740 --> 00:12:17.940
So if people read your post, I'll link to, what I'm going to do is I'm going to link to the meta post, I guess, in the sense of like a meta package.

00:12:18.570 --> 00:12:24.960
In that it says, here's all the articles that I wrote up for the Language Summit, so you can jump to the ones you want to see.

00:12:26.440 --> 00:12:28.140
And your write-ups mirror that.

00:12:28.140 --> 00:12:33.620
It's like, here's what happened in the presentation, and then the discussion that happened below it from all the core devs.

00:12:34.600 --> 00:12:36.820
Yeah, it's short presentation,

00:12:36.940 --> 00:12:41.300
and then it's just immediately into questions, feedback, all of that.

00:12:41.460 --> 00:12:42.540
So it mirrors it.

00:12:43.240 --> 00:12:43.400
Yeah.

00:12:44.400 --> 00:12:44.580
Cool.

00:12:45.320 --> 00:12:48.420
So the first one, I mean, I didn't always write down the names here.

00:12:49.340 --> 00:12:50.280
The first one is,

00:12:50.640 --> 00:12:54.260
how can we make breaking changes less painful by Itmar Oren?

00:12:55.680 --> 00:13:03.740
And so this one, Itmar deploys a bunch of Python code for production at Meta,

00:13:04.480 --> 00:13:11.680
and said, you know, going from version, I don't know, 3.11 to 3.12 or 3.12 to 3.13

00:13:13.940 --> 00:13:16.480
has breaking changes that can be challenging.

00:13:17.900 --> 00:13:21.620
You know, I don't encounter too many breaking changes in upgrading Python versions,

00:13:22.360 --> 00:13:27.160
but I also don't have literally millions of lines of code doing intricate things either.

00:13:27.460 --> 00:13:33.580
So, all right, this is a pretty edge case, but also an important one, right?

00:13:34.180 --> 00:13:34.360
Yeah,

00:13:35.710 --> 00:13:40.160
so this talk, I think one of the big things about this talk too is it wasn't just

00:13:40.250 --> 00:13:42.720
about like, oh, jumping from one version to one version.

00:13:43.090 --> 00:13:49.380
A lot of companies employ like a skip version upgrading style where they'll experience breaking

00:13:49.500 --> 00:13:53.960
changes in a slightly different way than a lot of other users where they're jumping from

00:13:54.090 --> 00:13:57.160
like 3.11 to 3.13 as opposed

00:13:57.160 --> 00:13:58.180
to like 3

00:13:58.180 --> 00:14:02.099
.11, 3.12 to 3.13 because upgrading is obviously

00:14:02.120 --> 00:14:06.700
this like big task and so they don't want to do it every year maybe they do want to do it every two

00:14:06.880 --> 00:14:11.540
years and that's fine for them unless there's some feature that they really need or something like

00:14:11.620 --> 00:14:18.240
that but yeah so like anytime that you're upgrading more than one tython version like it just the

00:14:18.360 --> 00:14:21.620
breaking changes are obviously twice as many on average yeah

00:14:21.620 --> 00:14:23.780
sometimes they even go from 2.7 to

00:14:23.900 --> 00:14:24.080
3

00:14:24.080 --> 00:14:27.720
.11. Yes, and on rare occasions

00:14:27.860 --> 00:14:29.460
they go from 2.7 to 3.11.

00:14:31.160 --> 00:14:33.160
Thankfully that happens less and less.

00:14:34.320 --> 00:14:37.600
That's a story from the last decade

00:14:38.180 --> 00:14:38.360
thankfully.

00:14:40.140 --> 00:14:40.940
This was

00:14:40.940 --> 00:14:42.120
talking about

00:14:43.540 --> 00:14:47.520
we're not trying to say breaking changes shouldn't happen because we know that they're

00:14:47.820 --> 00:14:51.740
important and they're a good way to unblock things and remove pieces of software that we

00:14:51.680 --> 00:15:01.680
don't want users using. But trying to make it so that we can almost like quantify how bad a breaking

00:15:01.920 --> 00:15:08.660
change will be for users. And then based on that quantization, figure out what we need to do,

00:15:08.920 --> 00:15:13.040
maybe extra if it's like a particularly bad breaking change, or if it's just like, oh,

00:15:13.760 --> 00:15:18.380
this has been deprecated for five years, and then removing it, or like, there's an easy drop in

00:15:18.340 --> 00:15:24.340
replacement that's one-to-one. Those sorts of breaking changes are really easy versus things

00:15:24.540 --> 00:15:29.880
like, oh, this behavior changed, and you won't know until runtime, and things like that are way

00:15:29.950 --> 00:15:35.300
more difficult. You have to have a test harness that's actually testing all of the possibilities

00:15:35.590 --> 00:15:42.299
in the code to know whether you're safe or not versus a syntactical control F, find the bad

00:15:42.320 --> 00:15:43.460
function and then replace it.

00:15:44.600 --> 00:15:46.160
It could be super subtle,

00:15:46.700 --> 00:15:48.140
right? It could be the

00:15:48.320 --> 00:15:50.300
runtime things, but it could

00:15:50.360 --> 00:15:50.800
also be

00:15:53.420 --> 00:15:54.020
the memory

00:15:54.460 --> 00:15:56.340
structure of something we put into

00:15:56.500 --> 00:15:58.180
a Redis cache via pickling

00:15:58.260 --> 00:15:59.100
has changed.

00:16:00.680 --> 00:16:02.220
And the cache

00:16:02.440 --> 00:16:03.840
version no longer works and

00:16:04.420 --> 00:16:06.360
we have to somehow figure out how to completely

00:16:06.660 --> 00:16:07.860
delete the cache

00:16:08.520 --> 00:16:10.319
and start over. And some web apps

00:16:11.620 --> 00:16:12.420
that's a problem

00:16:12.420 --> 00:16:13.360
right when they're

00:16:13.360 --> 00:16:17.400
under tons of traffic that sort of cold start experience can be

00:16:17.400 --> 00:16:18.560
a problem yeah

00:16:18.560 --> 00:16:24.000
and there's there's even things that like aren't even part of this gets mentioned

00:16:24.070 --> 00:16:29.500
in a future talk about parallelism where it's not even a function of the language but it just

00:16:29.670 --> 00:16:34.660
happens to be a property of how a particular set of code executes in one version versus another

00:16:35.200 --> 00:16:37.480
so like with the from

00:16:37.480 --> 00:16:38.380
the difference between 3

00:16:38.380 --> 00:16:42.460
.9 and 3.10 where something is thread safe that it

00:16:42.620 --> 00:16:45.620
doesn't look thread safe at all like if you look at the code you're like oh that's not thread safe

00:16:45.820 --> 00:16:46.000
but the

00:16:46.000 --> 00:16:47.140
gill based

00:16:47.140 --> 00:16:51.360
like the implementation of the GIL in 3.9 keeps it thread safe but in 3.10 and

00:16:51.520 --> 00:16:56.640
beyond it's no longer thread safe but the thing is you were relying on behavior that's not defined

00:16:57.400 --> 00:17:01.420
it wasn't guaranteed yeah there's no guarantee that that and

00:17:01.420 --> 00:17:01.600
so

00:17:01.600 --> 00:17:02.220
it's like is that

00:17:02.220 --> 00:17:03.019
a breaking change

00:17:03.720 --> 00:17:08.939
no but also like it'll probably break somebody and also how do you detect that at a syntax level you

00:17:09.060 --> 00:17:10.180
can't the syntax is the same

00:17:10.180 --> 00:17:12.920
should it be written down as a breaking change i don't know maybe

00:17:13.860 --> 00:17:17.699
does it does your code feel broken if it gives you different answers and those answers start

00:17:17.900 --> 00:17:18.280
becoming wrong

00:17:18.280 --> 00:17:24.699
maybe maybe yeah it's tough it's a really tough thing um i think core developers were

00:17:25.579 --> 00:17:31.040
like pretty happy with the idea of like treating different breaking changes differently trying to

00:17:31.000 --> 00:17:33.280
develop some sort of taxonomy of breaking changes.

00:17:33.560 --> 00:17:39.000
And there was some interesting ideas with like running these like code update scripts,

00:17:39.330 --> 00:17:43.200
providing code update scripts that if you have code and there's breaking changes that

00:17:43.200 --> 00:17:45.280
are on the syntax level, being able to upgrade them.

00:17:46.080 --> 00:17:46.840
Apparently Ruff

00:17:46.840 --> 00:17:50.400
had some ability to do this for two major versions of NumPy.

00:17:51.540 --> 00:17:53.800
And so like that got brought up as an example of like,

00:17:53.920 --> 00:17:54.700
oh, this worked

00:17:54.700 --> 00:17:55.620
really well for NumPy.

00:17:55.780 --> 00:17:57.120
So maybe Python?

00:17:57.980 --> 00:17:58.620
Yeah, absolutely.

00:17:58.880 --> 00:18:01.080
Well, I was, yeah, absolutely.

00:18:01.360 --> 00:18:04.880
I think rough is certainly in a good position to do that.

00:18:06.600 --> 00:18:06.820
Yeah.

00:18:09.040 --> 00:18:11.360
You could say this pattern isn't wrong,

00:18:11.700 --> 00:18:15.620
but maybe it should come up with a warning just so you know.

00:18:16.540 --> 00:18:16.880
Run

00:18:16.880 --> 00:18:18.640
this check if you really want to see, right?

00:18:19.200 --> 00:18:19.340
Yeah.

00:18:20.660 --> 00:18:23.160
Yeah, so one of the things Edmar pointed out was

00:18:23.680 --> 00:18:26.780
it's difficult to find the documentation of deprecated

00:18:26.820 --> 00:18:30.000
and removed modules because after a module is removed,

00:18:30.140 --> 00:18:31.880
the documentation is also removed.

00:18:33.560 --> 00:18:34.960
It's a bit of a catch-22.

00:18:36.640 --> 00:18:39.600
Yeah, that one was really interesting because, yeah,

00:18:40.120 --> 00:18:41.800
especially if you're skipping versions too,

00:18:42.080 --> 00:18:46.400
you go to the docs and the module is just gone

00:18:46.700 --> 00:18:49.960
and you're kind of left to figure out

00:18:49.960 --> 00:18:51.800
what was the last version that had that module,

00:18:52.140 --> 00:18:53.680
when did the deprecation warning start,

00:18:53.740 --> 00:18:56.060
where is the actual documentation

00:18:56.060 --> 00:18:56.520
that

00:18:56.520 --> 00:18:57.300
says what to do.

00:18:59.120 --> 00:19:01.580
And so, yeah, apparently the docs editorial team

00:19:02.720 --> 00:19:03.580
are working on that.

00:19:03.720 --> 00:19:04.820
They're trying to figure out a solution

00:19:05.120 --> 00:19:08.840
for better documentation for removed modules specifically.

00:19:09.350 --> 00:19:10.120
Or removed modules.

00:19:10.860 --> 00:19:12.860
Yeah, Carol Williams said they were working on that.

00:19:13.700 --> 00:19:14.160
Very interesting.

00:19:15.660 --> 00:19:18.940
You can go to the documentation, like docs.python.org,

00:19:20.320 --> 00:19:21.740
and pick through it,

00:19:21.920 --> 00:19:23.780
but by default it lands on the latest, right?

00:19:24.300 --> 00:19:25.580
Yeah, by default it lands on the latest.

00:19:25.780 --> 00:19:30.660
And if there are any links to modules or to deprecation links

00:19:30.780 --> 00:19:32.940
that aren't pinning to a specific version,

00:19:34.240 --> 00:19:35.160
it'll go to the latest

00:19:35.160 --> 00:19:35.340
and

00:19:35.340 --> 00:19:35.640
be like,

00:19:35.720 --> 00:19:36.800
oh, we don't have those docs anymore.

00:19:37.000 --> 00:19:37.200
Yeah,

00:19:37.340 --> 00:19:37.960
it's just 404.

00:19:38.160 --> 00:19:39.000
You're like, huh, weird.

00:19:39.840 --> 00:19:40.460
Weird, weird.

00:19:40.920 --> 00:19:42.980
Okay, well, very, very interesting.

00:19:44.440 --> 00:19:48.060
The next one we have, an uncontentious talk about contention.

00:19:48.380 --> 00:19:53.300
And now we start into the heart of the topics,

00:19:53.500 --> 00:19:59.860
which is threading, async, IO, parallelism, concurrency, all these things.

00:20:01.200 --> 00:20:04.620
And this is the one you were referencing when you ask,

00:20:05.330 --> 00:20:06.360
is this code thread safe?

00:20:06.390 --> 00:20:07.920
So just give people a sense.

00:20:07.980 --> 00:20:13.760
There's an incredibly simple parallel example of create a counter class.

00:20:13.950 --> 00:20:14.860
The counter has a value.

00:20:16.340 --> 00:20:20.640
You can run some code that goes for 100,000 times, increment the value.

00:20:21.120 --> 00:20:23.740
start 10 threads at all, jam on that.

00:20:26.440 --> 00:20:28.140
And then this is by Mark Shannon.

00:20:28.190 --> 00:20:31.820
He says, we would like this to print exactly 1 million.

00:20:33.260 --> 00:20:34.880
I'm not sure that that's necessarily true.

00:20:35.730 --> 00:20:38.660
You would, as a creator of this program,

00:20:38.790 --> 00:20:40.360
you wouldn't exactly print a million,

00:20:40.430 --> 00:20:42.500
but there might be advantages

00:20:44.020 --> 00:20:47.820
to allowing code to run more parallel

00:20:48.070 --> 00:20:48.980
rather than less parallel.

00:20:49.080 --> 00:20:52.640
and say it's on the author of that code

00:20:53.160 --> 00:20:54.200
to make it thread safe.

00:20:54.780 --> 00:20:55.040
Yeah.

00:20:55.930 --> 00:20:56.040
Right.

00:20:56.320 --> 00:20:56.700
If

00:20:56.700 --> 00:20:58.080
it's five times faster

00:20:59.100 --> 00:21:00.000
because Python, the runtime,

00:21:00.660 --> 00:21:01.460
doesn't make it thread safe.

00:21:02.020 --> 00:21:04.640
Maybe you choose the time

00:21:04.740 --> 00:21:05.840
and the way that you run that code.

00:21:05.920 --> 00:21:06.540
That's all I'm getting at.

00:21:06.880 --> 00:21:09.260
We would like it to print exactly a million times

00:21:09.740 --> 00:21:10.600
as a correctness,

00:21:11.380 --> 00:21:12.840
but maybe it's not Python's job.

00:21:13.250 --> 00:21:13.600
No, I

00:21:13.600 --> 00:21:14.440
think maybe

00:21:14.440 --> 00:21:15.799
that comment is like

00:21:16.420 --> 00:21:21.500
not necessarily like we core developers should want this program to print exactly one million

00:21:21.570 --> 00:21:26.260
i think it's more of like oh if you were someone who's writing this code you would maybe

00:21:26.260 --> 00:21:26.760
expect

00:21:26.760 --> 00:21:26.820
it

00:21:26.820 --> 00:21:31.640
to print a million because they're like oh in 3.9 and before it prints a million so like that's fine

00:21:32.170 --> 00:21:33.220
uh but then

00:21:33.220 --> 00:21:34.120
yeah so you know

00:21:34.120 --> 00:21:37.840
what changed in the GIL i actually don't know specifically what

00:21:38.020 --> 00:21:43.739
changed in the GIL um it was something to do with context switching uh in the GIL made this

00:21:44.120 --> 00:21:45.140
made this no longer change.

00:21:45.420 --> 00:21:45.920
My guess is

00:21:45.920 --> 00:21:46.140
that

00:21:46.140 --> 00:21:47.540
it's performance, like you said.

00:21:47.860 --> 00:21:48.260
Yeah, exactly.

00:21:48.860 --> 00:21:48.960
Exactly.

00:21:49.220 --> 00:21:51.760
They probably said we can make the GIL more fine-grained

00:21:51.780 --> 00:21:57.420
and get more perceived cooperative or primitive multi-threading

00:21:57.420 --> 00:21:59.480
as it goes,

00:21:59.600 --> 00:22:00.320
something like that, right?

00:22:00.540 --> 00:22:00.860
Exactly.

00:22:02.500 --> 00:22:03.980
Yeah, and that's kind of what I was hinting at there.

00:22:06.200 --> 00:22:09.380
Okay, so that's the story.

00:22:10.980 --> 00:22:15.100
And basically, Mark said, thread safety is a property of the program,

00:22:16.160 --> 00:22:18.680
the Python code you write, or someone's written,

00:22:19.840 --> 00:22:23.880
and the implementation of CPython and how it behaves,

00:22:24.370 --> 00:22:25.440
in this case, the GIL, right?

00:22:26.620 --> 00:22:30.240
Yeah, so Mark was, I think the big thing for Mark's talk

00:22:30.420 --> 00:22:36.280
was this synchronization quadrant where he is basically trying

00:22:36.410 --> 00:22:39.579
to make some bets about what's going to happen next

00:22:39.600 --> 00:22:41.360
to try to solve some of the problems

00:22:41.540 --> 00:22:44.520
that we're going to start seeing for parallel Python.

00:22:45.600 --> 00:22:48.280
And that's either, anytime that you have

00:22:48.620 --> 00:22:51.400
both mutability and shared references,

00:22:51.920 --> 00:22:55.140
you have problems with synchronization.

00:22:55.640 --> 00:22:58.680
And if you introduce more immutability

00:22:59.080 --> 00:23:00.720
or less sharing,

00:23:01.600 --> 00:23:03.520
then you're starting to solve these problems.

00:23:05.260 --> 00:23:07.039
But the unfortunate thing is that there's a lot of Python

00:23:07.060 --> 00:23:10.320
that happens in the shared and mutable section.

00:23:11.360 --> 00:23:14.160
And we don't want to have to ask everyone

00:23:14.640 --> 00:23:16.120
to rewrite all their Python programs.

00:23:16.840 --> 00:23:20.560
So it's definitely a tough quantization problem.

00:23:21.140 --> 00:23:24.440
How big of an issue would making changes like this be?

00:23:24.960 --> 00:23:27.220
But then also, we don't even really today

00:23:27.560 --> 00:23:29.920
give people a ton of the tools that they would need

00:23:29.920 --> 00:23:32.520
to be able to work with immutable data structures.

00:23:33.580 --> 00:23:34.660
Because you have frozen set,

00:23:34.900 --> 00:23:36.940
And we have tuples,

00:23:37.160 --> 00:23:39.060
frozen list,

00:23:39.400 --> 00:23:41.400
frozen dictionary, any of that.

00:23:43.120 --> 00:23:45.580
And so, yeah, Mark just basically gave a whole bunch of things

00:23:45.740 --> 00:23:47.700
where it's like, here's all of these ideas that I have

00:23:47.880 --> 00:23:52.640
for making this more easy, having more immutability.

00:23:53.680 --> 00:23:56.240
And we should probably start thinking about that now

00:23:56.660 --> 00:23:58.560
because we're starting to get the free threading time.

00:23:59.520 --> 00:24:05.200
Yeah, certainly a threading collections sort of deal would be great.

00:24:07.260 --> 00:24:07.500
Yeah, I

00:24:07.500 --> 00:24:07.680
think

00:24:07.680 --> 00:24:08.560
the

00:24:08.560 --> 00:24:10.280
final thing there was like,

00:24:10.440 --> 00:24:12.780
oh, we should definitely be doing this on PyPI.

00:24:13.010 --> 00:24:15.540
And I think the free threading team is planning on creating

00:24:15.800 --> 00:24:18.820
some immutable data structures and putting them on PyPI at first

00:24:19.700 --> 00:24:20.140
before...

00:24:20.170 --> 00:24:21.720
Oh, yeah, that's an interesting idea.

00:24:22.820 --> 00:24:25.580
Take them for a test run before people,

00:24:26.360 --> 00:24:29.320
before they get baked into a pattern, right?

00:24:29.520 --> 00:24:29.800
Exactly.

00:24:32.800 --> 00:24:40.360
You know, one of the things that I think is a danger of those types of data structures, and don't get me wrong, they're useful and they're good.

00:24:40.900 --> 00:24:47.260
But one of the dangers is they can give people a false sense of security, right?

00:24:47.400 --> 00:24:52.520
If you have four or five lines of code that is changing state,

00:24:53.640 --> 00:24:55.700
check to see something that is in the list,

00:24:57.120 --> 00:24:59.840
and then in the next line, remove something from the list.

00:25:02.280 --> 00:25:04.160
Even if that list itself is thread safe,

00:25:05.380 --> 00:25:06.980
if it's immutable, that's one thing.

00:25:07.020 --> 00:25:11.620
But if it's a mutable list that you're trying to make a thread safe version of,

00:25:12.780 --> 00:25:15.839
it's still possible that the check was thread safe

00:25:16.340 --> 00:25:17.660
and they're removed with ThreadSafe.

00:25:17.810 --> 00:25:19.900
But something happened between those two

00:25:20.160 --> 00:25:21.680
where the thing's no longer in the list, right?

00:25:22.100 --> 00:25:23.360
It gives people this sense of,

00:25:23.980 --> 00:25:25.340
well, I've got a ThreadSafe collection,

00:25:25.520 --> 00:25:26.180
so I'm good to go.

00:25:26.320 --> 00:25:29.360
It's like on a line-by-line basis, that's true.

00:25:29.410 --> 00:25:31.380
But as a block of code, it's still not true.

00:25:31.490 --> 00:25:33.460
And you still have to think more about these things.

00:25:34.060 --> 00:25:34.500
That doesn't mean

00:25:34.500 --> 00:25:35.100
you shouldn't have them,

00:25:35.540 --> 00:25:38.320
but it is like an awareness sort of thing

00:25:38.520 --> 00:25:40.980
because I'm doing ThreadSafe.

00:25:41.010 --> 00:25:45.120
Look, from system.threading.collections, import, whatever.

00:25:45.420 --> 00:25:45.900
We're good to go.

00:25:45.960 --> 00:25:47.720
Like, better.

00:25:48.940 --> 00:25:49.500
Yeah, yeah.

00:25:49.640 --> 00:25:51.020
You actually have to use the data structures.

00:25:51.180 --> 00:25:51.600
You can't.

00:25:51.860 --> 00:25:53.120
You have to use the immutable ones.

00:25:53.280 --> 00:25:55.240
Don't use the immutable ones and expect for

00:25:55.240 --> 00:25:55.300
anything.

00:25:55.340 --> 00:25:59.740
Yeah, so it's, but it is certainly in the right way.

00:25:59.940 --> 00:26:07.940
There was some, there's some pretty extreme in terms of how much they would change programming paradigms and ideas.

00:26:09.400 --> 00:26:09.940
Suggestions here.

00:26:09.940 --> 00:26:13.760
And I don't remember if they, how things are starting to blend together these different topics.

00:26:14.160 --> 00:26:25.160
but yeah, like one of the challenges is that functions and types are mutable, right?

00:26:25.220 --> 00:26:33.340
And that makes it hard even at a CPython implementation, runtime level of dealing with some of these things.

00:26:35.240 --> 00:26:42.140
But changing them breaks the sort of style of Python somewhat.

00:26:42.880 --> 00:26:42.980
Yeah.

00:26:43.280 --> 00:26:44.160
That's a trade-off, right?

00:26:44.360 --> 00:26:44.800
It's

00:26:44.800 --> 00:26:45.740
a huge trade-off, yeah.

00:26:45.920 --> 00:26:48.440
And the fact that everything is mutable

00:26:49.600 --> 00:26:51.420
and a lot of things are shared,

00:26:51.600 --> 00:26:52.360
like the standard library,

00:26:52.360 --> 00:26:55.080
the whole standard library is shared across everything.

00:26:56.100 --> 00:26:58.460
It's really difficult to say that,

00:26:58.510 --> 00:27:01.440
oh yeah, if you're in that top right quadrant

00:27:01.640 --> 00:27:02.460
of shared and mutable,

00:27:03.200 --> 00:27:05.480
which way does the standard library move?

00:27:05.920 --> 00:27:10.220
You can't make everything mutable

00:27:10.290 --> 00:27:12.080
and you can't make everything not shared.

00:27:12.900 --> 00:27:14.440
So it's what do you do?

00:27:15.020 --> 00:27:15.820
Yeah, for sure.

00:27:15.960 --> 00:27:18.460
And it's also a performance issue that you could,

00:27:19.280 --> 00:27:21.060
because, you know, like right here,

00:27:21.360 --> 00:27:24.480
Mark points out that where we build these lots a day,

00:27:25.720 --> 00:27:27.480
maybe it is there, but not for a good reason,

00:27:27.600 --> 00:27:31.820
like functions and class method resolution order,

00:27:31.960 --> 00:27:32.540
all that stuff.

00:27:32.700 --> 00:27:34.320
It's mutable, but should it be?

00:27:34.980 --> 00:27:37.060
The thing is, if it's going to remain mutable,

00:27:37.960 --> 00:27:40.860
you probably have to do locks and stuff down in CPython,

00:27:41.480 --> 00:27:42.380
which will slow it down.

00:27:42.620 --> 00:27:44.360
If it were immutable, you don't have to lock it.

00:27:44.580 --> 00:27:46.760
You can read from multiple threads all day long

00:27:46.850 --> 00:27:47.800
and it's not going to hurt anything.

00:27:49.030 --> 00:27:51.960
So it's actually a performance consideration,

00:27:52.380 --> 00:27:53.900
not just a flexibility, right?

00:27:53.990 --> 00:27:56.300
If you say, we really value this multi-threading

00:27:57.180 --> 00:28:00.020
and we wanted to operate as quick as regular Python

00:28:00.300 --> 00:28:01.100
but scale really well,

00:28:02.160 --> 00:28:03.460
these are trade-offs you've got to consider.

00:28:03.660 --> 00:28:07.140
But then we all have scars from two to three

00:28:07.940 --> 00:28:09.200
and this could be a little like that.

00:28:10.440 --> 00:28:14.440
Yeah, I think it's going to matter.

00:28:14.800 --> 00:28:18.060
And I think that companies are going to have to maybe start

00:28:18.200 --> 00:28:20.760
even profiling their own code and trying to see

00:28:21.580 --> 00:28:25.980
where they're hitting those, or stop the world locks

00:28:26.220 --> 00:28:27.960
or any sort of performance issue

00:28:28.120 --> 00:28:30.720
and trying to track down where in their code

00:28:31.280 --> 00:28:34.840
we're hitting those really expensive operations.

00:28:36.120 --> 00:28:39.440
And if they're trying to write this extremely high parallel,

00:28:40.240 --> 00:28:41.980
code. Having a way

00:28:42.160 --> 00:28:43.280
to profile it

00:28:44.060 --> 00:28:45.640
sounds really like a good idea

00:28:46.000 --> 00:28:47.860
because I think that there's

00:28:48.100 --> 00:28:49.820
going to be, once this starts happening,

00:28:50.060 --> 00:28:51.720
people are going to have to start thinking about

00:28:52.880 --> 00:28:53.760
CPython the runtime.

00:28:53.920 --> 00:28:55.920
What are the expensive operations that are

00:28:56.160 --> 00:28:57.840
happening in my own code that

00:28:58.200 --> 00:28:58.320
maybe

00:28:58.320 --> 00:28:59.440
could be done differently

00:28:59.980 --> 00:29:01.680
to take advantage of pre-threading completely.

00:29:02.460 --> 00:29:02.740
Yeah.

00:29:03.980 --> 00:29:05.920
Well, and going back to the

00:29:06.120 --> 00:29:06.820
opening part with

00:29:06.820 --> 00:29:09.600
like the RedSafe collections and so on.

00:29:10.500 --> 00:29:13.680
It's really difficult for us as Python devs to create those

00:29:14.560 --> 00:29:16.320
because we could write that in Python,

00:29:16.580 --> 00:29:18.180
but that makes it fairly slow.

00:29:18.230 --> 00:29:22.060
You need that down at the machine level, right?

00:29:22.260 --> 00:29:25.080
Like probably CPython.

00:29:25.250 --> 00:29:28.000
We'll see if it's CPython or RPython or whatever

00:29:28.130 --> 00:29:30.060
as we go through this series of talks.

00:29:30.260 --> 00:29:32.860
But at the time of speaking or recording,

00:29:33.060 --> 00:29:34.540
it's CPython, right?

00:29:34.580 --> 00:29:46.040
It would be way faster if there was a, in the standard library, C implementation of a thread-safe thing that's not being coordinated by a bunch of calls from the Python level.

00:29:48.640 --> 00:29:49.120
Okay.

00:29:50.340 --> 00:29:57.020
I guess closing this one out, Mark suggested adding freezing methods to data structures like byte arrays.

00:29:57.180 --> 00:29:58.160
That's kind of what we were talking about.

00:29:58.280 --> 00:30:01.340
and Barry Warsaw said that he brought up a proposal,

00:30:02.760 --> 00:30:09.740
a PEP that was a freeze protocol that was rejected 20 years ago.

00:30:11.020 --> 00:30:11.940
Those were different times.

00:30:12.520 --> 00:30:13.580
Those were different times, right?

00:30:13.720 --> 00:30:14.880
How many cores did we have?

00:30:15.340 --> 00:30:16.180
Was it like a dual?

00:30:17.060 --> 00:30:17.720
Single digit still.

00:30:17.900 --> 00:30:18.460
Yeah,

00:30:18.680 --> 00:30:22.920
certainly a single dual, maybe a quad core if you were awesome back then.

00:30:24.140 --> 00:30:25.080
That's not the case anymore.

00:30:25.180 --> 00:30:28.880
So the benefit of having something like this is certainly higher.

00:30:29.040 --> 00:30:29.960
So I was like,

00:30:30.000 --> 00:30:31.220
why was that rejected again?

00:30:31.610 --> 00:30:32.040
We don't know.

00:30:32.440 --> 00:30:32.660
Yeah.

00:30:33.080 --> 00:30:39.320
Freezing comes up yet again in another one of the talks about a fearless concurrency as well.

00:30:40.240 --> 00:30:46.460
So I think that something like that is probably going to get resurrected, at least tried to be done again.

00:30:47.450 --> 00:30:47.600
Yeah.

00:30:47.900 --> 00:30:50.760
I don't know if you wanted to jump to that one because I think that

00:30:50.760 --> 00:30:50.920
one

00:30:50.920 --> 00:30:51.160
in the

00:30:51.160 --> 00:30:52.999
uncontentious talk is quite...

00:30:53.120 --> 00:30:54.020
Are you talking

00:30:54.020 --> 00:30:55.140
fearless concurrency?

00:30:55.460 --> 00:30:55.680
Yes.

00:30:56.220 --> 00:30:57.520
Yeah, let's talk that one.

00:30:57.520 --> 00:31:04.300
So that's by Matthew Parkinson, Tobias Riggstad, and Friedhoff Stoltz.

00:31:05.220 --> 00:31:07.300
Hopefully I did justice to your name, folks.

00:31:08.920 --> 00:31:09.960
Yeah, so fearless concurrency.

00:31:10.140 --> 00:31:12.760
This was one of the more detailed ones.

00:31:12.960 --> 00:31:18.460
So this one, I don't know how I feel about this one, Seth.

00:31:21.799 --> 00:31:28.000
This is one of those things where it's like if we take this really wild idea

00:31:28.180 --> 00:31:32.300
that really changes the way people have traditionally done programming for concurrency,

00:31:33.090 --> 00:31:34.100
then we could get great benefits.

00:31:35.010 --> 00:31:40.400
But it also is like a â€“ I don't know what your assessment is.

00:31:41.910 --> 00:31:46.900
My sense is that most Python people don't think a lot about threading,

00:31:47.300 --> 00:31:53.600
haven't done much threading, and their skills of threading, problem-solving,

00:31:55.060 --> 00:31:58.720
using fairly straightforward things like locks is still pretty much like,

00:31:59.320 --> 00:32:00.500
I think they have those in the language.

00:32:00.870 --> 00:32:01.280
You know what I mean?

00:32:01.420 --> 00:32:02.980
Like not really like, yeah, oh, yeah, yeah.

00:32:03.000 --> 00:32:06.460
I use event signals and all sorts of like producer consumers,

00:32:06.770 --> 00:32:08.480
like not very much of that.

00:32:08.600 --> 00:32:09.060
You know what I mean?

00:32:11.120 --> 00:32:16.400
And so anyway, tell us what this is about because it's an interesting concept.

00:32:17.220 --> 00:32:17.380
Yeah,

00:32:17.580 --> 00:32:20.600
this concept is all about,

00:32:20.700 --> 00:32:22.420
so the central concept is regions.

00:32:23.060 --> 00:32:25.480
And regions are essentially,

00:32:26.360 --> 00:32:28.300
in Rust, they have this model

00:32:28.620 --> 00:32:34.960
where a mutable object is only allowed to be referenced once.

00:32:35.380 --> 00:32:37.580
That's the ownership model in Rust.

00:32:38.440 --> 00:32:42.560
But that's not compatible with how Python programs are in general.

00:32:43.259 --> 00:32:44.640
Because we love our mutability.

00:32:45.800 --> 00:32:52.480
And so this is essentially like, okay, well, what if we could have kind of like a looser version of that,

00:32:52.800 --> 00:32:57.880
where you have objects that are doing mutability and all of that within a region,

00:32:58.820 --> 00:33:02.180
but then anything outside the region can't mess with it.

00:33:02.660 --> 00:33:09.100
And then if you have that situation, which is more common and more understandable for a Python programmer,

00:33:10.640 --> 00:33:12.660
then you can get a bunch of performance benefits,

00:33:12.800 --> 00:33:15.680
because you know that nothing outside of the region

00:33:15.860 --> 00:33:19.160
is going to be doing any sort of like that special mutability

00:33:19.370 --> 00:33:20.100
just out of nowhere.

00:33:20.250 --> 00:33:22.940
We're going to change something about your function signature or something.

00:33:24.700 --> 00:33:26.580
And so then when you have this situation,

00:33:26.690 --> 00:33:28.620
you can even do the at-links of this diagram

00:33:28.880 --> 00:33:34.680
showing all these references into that region from a specific thread.

00:33:35.420 --> 00:33:38.080
We know because of how the region is created

00:33:38.480 --> 00:33:40.940
that the other thread can't modify anything inside.

00:33:41.220 --> 00:33:42.820
and so you get a bunch of performance benefits

00:33:43.360 --> 00:33:45.060
for all of the operations that are happening

00:33:45.190 --> 00:33:45.820
inside that region.

00:33:46.800 --> 00:33:49.000
I think that's kind of like the

00:33:49.940 --> 00:33:50.620
elevator tunnel.

00:33:51.200 --> 00:33:52.620
Regions are like Rust, but

00:33:53.220 --> 00:33:54.540
better for Python programmers.

00:33:55.060 --> 00:33:57.060
Yeah, yeah, sure. And if you want some

00:33:57.070 --> 00:33:58.460
other thread to have access to it,

00:33:58.960 --> 00:34:01.120
you've got to make all the

00:34:01.220 --> 00:34:02.900
things in that region and let go of it

00:34:03.080 --> 00:34:05.260
so that it can be transferred

00:34:05.500 --> 00:34:07.020
ownership over to the other thread

00:34:07.260 --> 00:34:07.760
and so on.

00:34:08.960 --> 00:34:11.780
Yeah, it's an interesting idea.

00:34:16.190 --> 00:34:19.340
Like I said, I feel like it's powerful,

00:34:19.540 --> 00:34:21.840
but I feel like it might be a bridge too far, you know?

00:34:21.889 --> 00:34:22.280
I don't know.

00:34:24.700 --> 00:34:28.540
Yeah, I think that, again, immutability came up here.

00:34:28.889 --> 00:34:32.379
They even had some talking about being able to freeze regions,

00:34:32.879 --> 00:34:35.020
and so you create a region of objects

00:34:35.090 --> 00:34:37.500
and then freeze the entire region of objects,

00:34:37.840 --> 00:34:40.860
And then none of those references can get modified.

00:34:41.110 --> 00:34:44.159
And so the whole freeze protocol discussion kicked off again.

00:34:46.100 --> 00:34:48.080
Yeah, so maybe something to look forward to

00:34:48.320 --> 00:34:49.280
for each protocol in Python.

00:34:51.500 --> 00:34:53.100
Yeah, the region-based ownership,

00:34:54.000 --> 00:34:55.020
it was definitely an interesting thing.

00:34:55.060 --> 00:34:56.639
I feel like, yeah, like you said,

00:34:57.020 --> 00:34:58.740
there's a bunch of people that were asking questions

00:34:59.040 --> 00:35:00.980
about how much is the benefit.

00:35:03.160 --> 00:35:05.920
It's this different, like, to take advantage of it,

00:35:06.020 --> 00:35:07.760
you would have to change your code slightly

00:35:07.940 --> 00:35:11.060
so it's not just this free thing that happens.

00:35:11.340 --> 00:35:13.700
It's more of like, okay, if you're a library

00:35:14.340 --> 00:35:16.320
or a project that really wants to take advantage

00:35:16.460 --> 00:35:19.260
of tons of parallelism, you would use these features.

00:35:19.600 --> 00:35:21.620
It wouldn't be just like, oh, every Python programmer.

00:35:21.900 --> 00:35:23.860
Once they upgrade, they just get a bunch of free performance.

00:35:25.220 --> 00:35:26.200
No, no, of course not.

00:35:27.020 --> 00:35:27.440
Of course not.

00:35:33.200 --> 00:35:40.780
Yeah, I feel like there was some interesting questions, like interesting discussion, but for some reason I kind of left it out on my notes here.

00:35:40.940 --> 00:35:41.680
Let me see.

00:35:42.740 --> 00:35:45.720
So one of the things is there's basically four PEPs proposed

00:35:45.720 --> 00:35:47.060
or at least imagined.

00:35:47.460 --> 00:35:48.820
I don't know if they're actually proposed yet.

00:35:49.220 --> 00:35:49.340
No.

00:35:49.560 --> 00:35:51.900
That would make this happen.

00:35:52.920 --> 00:35:58.440
But maybe it's coming from a different section, but a different freezing conversation somewhere else.

00:35:58.580 --> 00:36:04.020
but there was the conversation like, okay, well, I've got a list.

00:36:04.680 --> 00:36:05.900
The list has a bunch of pointers.

00:36:06.980 --> 00:36:11.900
Some other thread got a hold of one of the items that's somewhere in the list,

00:36:12.380 --> 00:36:13.400
but I freeze the list.

00:36:15.340 --> 00:36:20.200
And so the list is frozen, but then you still have this object graph

00:36:20.540 --> 00:36:27.340
that has leaked some of the mutable data, right?

00:36:27.420 --> 00:36:31.720
So you could use that one pointer to one part in the ray and you could be making changes to it.

00:36:32.110 --> 00:36:44.040
So there's like this discussion of object graphs as their whole becoming invalid or like they're becoming problems with like trying to share those that were not obvious, right?

00:36:44.200 --> 00:36:44.920
Like really subtle

00:36:44.920 --> 00:36:46.960
programming challenges.

00:36:47.110 --> 00:36:54.400
Not a race condition, but kind of a syntactical structure behavior problem that you run into and you can say, well, this section is frozen.

00:36:54.950 --> 00:36:56.080
But someone got a piece of it.

00:36:56.090 --> 00:36:57.200
So now what do you say about it?

00:36:57.300 --> 00:36:57.700
You know what I mean?

00:36:57.840 --> 00:36:57.980
Yeah,

00:36:58.140 --> 00:37:02.500
I think the idea with freezing and regions and all that

00:37:02.780 --> 00:37:08.000
is it would definitely be tracking the number of references

00:37:08.520 --> 00:37:11.320
that are held by objects that are outside of the region.

00:37:12.020 --> 00:37:16.300
And so if you would then try to freeze an object or freeze that region,

00:37:16.700 --> 00:37:20.200
it would know that it's being referenced by something outside of a region

00:37:20.220 --> 00:37:23.500
and it would raise an exception instead of allowing that to happen.

00:37:23.740 --> 00:37:25.420
Because right now it would just allow it to happen.

00:37:27.020 --> 00:37:35.720
Whereas, like, getting an exception that, hey, a race condition is possible in this situation, we're not going to let you freeze this object or freeze this region.

00:37:35.920 --> 00:37:42.640
Like, I think that's, like, a better user experience because if you're using regions, you probably want these properties.

00:37:43.760 --> 00:37:45.840
and that is a big benefit of that

00:37:46.540 --> 00:37:47.540
proposed idea that

00:37:48.440 --> 00:37:49.440
what would have been a

00:37:50.060 --> 00:37:51.540
run time either

00:37:52.160 --> 00:37:53.360
race condition or deadlock

00:37:53.820 --> 00:37:55.380
becomes an exception

00:37:55.900 --> 00:37:57.640
that tells you this would have been a problem

00:37:57.820 --> 00:37:58.880
which that's massive

00:37:59.640 --> 00:38:01.080
yeah so

00:38:02.940 --> 00:38:03.240
okay

00:38:03.840 --> 00:38:04.100
interesting

00:38:05.800 --> 00:38:07.840
my first impression is that it's too much

00:38:08.300 --> 00:38:09.940
it's too much for the Python people

00:38:10.700 --> 00:38:11.880
and I'm sort of

00:38:11.780 --> 00:38:12.320
I'm

00:38:12.320 --> 00:38:13.440
not like just throwing shade.

00:38:13.660 --> 00:38:16.000
I'm sort of counting myself in the same group to some degree,

00:38:16.110 --> 00:38:21.700
even though I've done a lot of like block event-based style threading still.

00:38:23.060 --> 00:38:24.120
No, it is interesting.

00:38:24.190 --> 00:38:27.780
I think that it is a really good idea for them to break their project down

00:38:27.870 --> 00:38:31.820
into multiple peps instead of trying to like land this huge jet plane

00:38:31.870 --> 00:38:32.800
at the very end of the project.

00:38:33.310 --> 00:38:35.060
Instead, just like try to incrementally.

00:38:35.540 --> 00:38:39.080
Because I think that it'll be interesting going into the future

00:38:39.290 --> 00:38:41.560
seeing how many of these peps land.

00:38:41.740 --> 00:38:46.200
right like will it be all of them or will it be one of them you know like i think there are some

00:38:46.380 --> 00:38:51.740
interesting things in this project even if we don't get the entire region-based ownership model

00:38:52.220 --> 00:39:04.320
yeah yeah yeah okay interesting jumping back one in time we've got number three of nine so i'm

00:39:04.350 --> 00:39:05.540
feeling like we're gonna have to go faster

00:39:05.540 --> 00:39:07.420
yes yes we might have

00:39:07.420 --> 00:39:09.740
to this one is really interesting

00:39:09.760 --> 00:39:12.260
And this was a long conversation, at least a long write-up.

00:39:12.660 --> 00:39:14.740
This is the state of free-threaded Python.

00:39:15.320 --> 00:39:22.540
And the question is, does it make sense to move to the next phase of PEP 703,

00:39:22.630 --> 00:39:27.180
which is, I believe that's the one that defined free-threaded Python by Sim.

00:39:29.060 --> 00:39:32.440
So this was done by, this presentation was done by Matt Page,

00:39:33.620 --> 00:39:36.660
saying free-threaded Python has come quite far.

00:39:37.220 --> 00:39:42.900
And I believe since actually this was done, this PEP has actually moved forward to say,

00:39:43.330 --> 00:39:43.440
yes,

00:39:43.580 --> 00:39:44.700
we are moving on, right?

00:39:44.750 --> 00:39:46.500
So this is a bit of the lag that you were

00:39:46.500 --> 00:39:47.020
talking about.

00:39:47.090 --> 00:39:47.200
Yes.

00:39:47.510 --> 00:39:49.700
So I just shared a link with you also.

00:39:50.920 --> 00:39:54.420
This just came through from the steering council how long ago?

00:39:55.620 --> 00:39:57.020
A day ago from this recording.

00:39:57.320 --> 00:39:57.600
Oh,

00:39:57.800 --> 00:39:57.940
yes.

00:39:58.200 --> 00:39:59.560
We bring you the fresh news, folks.

00:39:59.920 --> 00:40:00.220
Yes.

00:40:01.420 --> 00:40:06.100
where PEP779 basically removed the experimental tag

00:40:06.400 --> 00:40:07.240
from the free-threaded build.

00:40:08.800 --> 00:40:11.120
Yeah, I think that this presentation

00:40:11.720 --> 00:40:13.220
probably had a good chunk to do with that,

00:40:13.420 --> 00:40:15.740
where they showed off, here's the state of everything,

00:40:15.980 --> 00:40:18.080
here's our proof that the community is adopting it

00:40:18.180 --> 00:40:21.860
at the expected rate at this point in the project,

00:40:22.400 --> 00:40:25.040
especially the scientific computing community,

00:40:25.340 --> 00:40:27.760
where the benefits of free-threading are huge.

00:40:28.940 --> 00:40:30.240
We're seeing all this uptake.

00:40:30.520 --> 00:40:33.780
we're seeing within the bounds of the performance allowance

00:40:34.100 --> 00:40:35.280
for single-threaded performance,

00:40:36.300 --> 00:40:38.020
can we remove the experimental

00:40:38.340 --> 00:40:41.780
so that we can see this next wave of adoption?

00:40:42.140 --> 00:40:43.800
That was basically the whole point of math.

00:40:43.920 --> 00:40:45.260
So it seems like the answer is yes.

00:40:46.000 --> 00:40:47.240
It does seem like it's yes, yeah.

00:40:47.600 --> 00:40:48.020
That's very cool.

00:40:50.040 --> 00:40:51.440
It means yes for 3.14.

00:40:52.320 --> 00:40:53.900
So what was it, June?

00:40:54.860 --> 00:40:56.580
That means yes in like four or five months.

00:40:57.320 --> 00:40:57.460
Yep.

00:40:58.000 --> 00:41:00.080
Stay tuned in October where you get to your stable.

00:41:00.180 --> 00:41:01.160
but please test your betas.

00:41:02.260 --> 00:41:03.860
Which, yeah, we're already into beta,

00:41:03.920 --> 00:41:04.160
aren't we?

00:41:04.180 --> 00:41:05.380
Yep, we're already in the beta phase.

00:41:05.620 --> 00:41:07.500
So test your betas, folks.

00:41:08.920 --> 00:41:10.860
So I guess it's worth pointing out just a little bit

00:41:10.940 --> 00:41:12.960
for folks who haven't been tracking this super closely,

00:41:13.180 --> 00:41:14.080
like you and I,

00:41:15.120 --> 00:41:19.380
this free-threaded Python's PEP 703 deal,

00:41:20.180 --> 00:41:22.720
I haven't seen anything like it, but I haven't.

00:41:23.480 --> 00:41:24.920
There might have been other stuff like this

00:41:24.980 --> 00:41:25.640
and I just didn't notice.

00:41:26.820 --> 00:41:28.140
But I'm all about the threading,

00:41:28.140 --> 00:41:29.660
so I've been paying more careful attention.

00:41:29.760 --> 00:41:34.940
in that it was accepted, but conditionally marked as experimental

00:41:35.200 --> 00:41:38.320
and with the caveat that we may take it away from Python later

00:41:38.340 --> 00:41:39.280
if we don't like it anymore.

00:41:40.200 --> 00:41:40.300
Yeah.

00:41:40.480 --> 00:41:43.460
Which is an odd acceptance, I thought.

00:41:44.360 --> 00:41:49.400
Yeah, that mechanism of, I think it was just this knowledge

00:41:49.700 --> 00:41:52.440
that this project would last multiple steering councils

00:41:53.520 --> 00:41:53.640
and

00:41:53.640 --> 00:41:55.540
multiple years, and we

00:41:55.540 --> 00:41:57.620
were kind of going into the brave unknown

00:41:57.800 --> 00:41:58.280
a little bit.

00:42:00.680 --> 00:42:03.860
and acknowledging that, that, hey, if it doesn't work out,

00:42:03.900 --> 00:42:04.880
we're going to have to pull it all out.

00:42:04.980 --> 00:42:07.780
And that is unfortunate, but it's just reality.

00:42:07.880 --> 00:42:08.220
We don't

00:42:08.220 --> 00:42:08.820
know what we're going

00:42:08.820 --> 00:42:09.160
to experience,

00:42:09.400 --> 00:42:10.160
but we're going to find it.

00:42:10.680 --> 00:42:12.140
It's such a big change.

00:42:12.560 --> 00:42:17.460
And so one of those criteria was it can't slow non-threaded Python

00:42:17.740 --> 00:42:19.760
down too much, right?

00:42:20.420 --> 00:42:22.980
And it looks like that's within 10%.

00:42:23.000 --> 00:42:25.140
Unless you're on a Mac, then it doesn't seem to matter

00:42:25.160 --> 00:42:25.700
for some reason.

00:42:27.500 --> 00:42:28.080
Apple Silicon.

00:42:28.140 --> 00:42:30.360
yeah Apple Silicon is magic

00:42:31.880 --> 00:42:33.260
but also with memory

00:42:33.390 --> 00:42:33.540
right

00:42:34.720 --> 00:42:36.440
I think it adds a little bit of a memory overhead

00:42:36.570 --> 00:42:38.300
for extra data structures

00:42:38.600 --> 00:42:40.620
to track like safe reference

00:42:40.860 --> 00:42:41.360
counting and stuff

00:42:41.810 --> 00:42:43.080
yeah and actually the new

00:42:44.540 --> 00:42:46.700
acceptance criteria for the next stage

00:42:47.380 --> 00:42:48.480
actually explicitly mentions

00:42:48.630 --> 00:42:49.900
the memory allowance

00:42:50.640 --> 00:42:50.760
this

00:42:50.760 --> 00:42:50.980
is

00:42:50.980 --> 00:42:52.060
like in Dong Hee's

00:42:53.660 --> 00:42:54.700
new post

00:42:54.750 --> 00:42:56.519
about it is that there's actually an explicit

00:42:56.540 --> 00:43:00.520
number now. I don't think there was before. I think it was just tracking the CPU performance.

00:43:01.440 --> 00:43:04.640
Yeah, interesting. And I guess it's worth pointing out, there's a couple of resources

00:43:05.080 --> 00:43:08.840
that you highlighted here. There's

00:43:09.170 --> 00:43:12.540
a resource page by QuantSight, which is a big data science

00:43:12.820 --> 00:43:16.560
crew, that talks about what are the

00:43:16.660 --> 00:43:20.620
different projects that are relevant, I imagine, to the data science folks.

00:43:21.760 --> 00:43:23.859
And what is their status with supporting

00:43:24.860 --> 00:43:27.960
being tested, being released for free threads, right?

00:43:28.680 --> 00:43:28.780
Yeah.

00:43:29.460 --> 00:43:29.940
No, these

00:43:29.940 --> 00:43:30.920
sorts of statuses.

00:43:30.950 --> 00:43:32.100
And there's also one from Hugo,

00:43:32.390 --> 00:43:34.400
which tracks which wheels have

00:43:34.400 --> 00:43:35.240
the

00:43:35.240 --> 00:43:36.640
free threading available

00:43:37.820 --> 00:43:38.960
for just an easy pip install.

00:43:39.240 --> 00:43:41.760
And in theory, that kind of means that they've tested,

00:43:42.200 --> 00:43:43.900
these projects have tested it with free threading.

00:43:44.460 --> 00:43:46.260
Yeah, it looks like we're at 20%, I guess.

00:43:46.860 --> 00:43:46.940
Yeah,

00:43:47.200 --> 00:43:49.280
we're doing pretty good for this stage of,

00:43:49.490 --> 00:43:51.500
like, it's experimental and it might get ripped away.

00:43:51.900 --> 00:43:53.440
Like, that was what it was before.

00:43:54.719 --> 00:43:55.319
people

00:43:55.319 --> 00:43:56.880
are trying it out

00:43:57.890 --> 00:44:00.840
this is how you get proof of people willing to try it

00:44:00.970 --> 00:44:03.780
I know that inside of the actual language summit discussion

00:44:03.830 --> 00:44:07.100
they also talked about wanting to dig in deeper

00:44:07.450 --> 00:44:09.440
into this data where it's like

00:44:09.640 --> 00:44:13.420
the projects support it but how many users are

00:44:13.900 --> 00:44:17.340
installing those wheels to show how much is the community

00:44:17.980 --> 00:44:18.980
testing out free threading

00:44:19.710 --> 00:44:23.460
just because a project supports it doesn't mean the community is

00:44:23.480 --> 00:44:24.280
it out at the same level.

00:44:25.600 --> 00:44:26.160
So maybe that'll be

00:44:26.160 --> 00:44:27.060
relevant for the future.

00:44:27.360 --> 00:44:29.580
I suppose at least for the ones that offer true

00:44:30.330 --> 00:44:33.100
free-threaded wheels, you could use PyPI data.

00:44:33.720 --> 00:44:33.780
Yep.

00:44:34.500 --> 00:44:35.220
The line hall,

00:44:36.020 --> 00:44:37.400
Google Cloud, BigQuery, or yeah,

00:44:37.760 --> 00:44:37.860
BigQuery.

00:44:37.990 --> 00:44:38.760
The BigQuery thing.

00:44:39.460 --> 00:44:41.540
There are other ones that are, well, it's just pure Python,

00:44:41.780 --> 00:44:42.360
so it probably works.

00:44:43.380 --> 00:44:45.260
That's harder to quantify.

00:44:45.940 --> 00:44:46.380
Exactly.

00:44:48.120 --> 00:44:52.300
So yeah, basically that change came along here.

00:44:52.580 --> 00:44:56.860
It says we support moving to what they call phase two,

00:44:57.960 --> 00:44:58.340
something like

00:44:58.340 --> 00:44:58.620
that.

00:44:59.420 --> 00:45:00.860
So there's multiple phases still.

00:45:01.480 --> 00:45:03.380
But, yeah, excellent.

00:45:06.150 --> 00:45:07.720
We talked about this fearless one.

00:45:07.940 --> 00:45:08.920
We're no longer afraid of it.

00:45:11.940 --> 00:45:14.460
People are tired of hearing about threading for a minute.

00:45:15.120 --> 00:45:15.960
How about governance?

00:45:17.240 --> 00:45:17.600
Yeah.

00:45:18.060 --> 00:45:21.160
Yeah, so Eric Snow did a presentation entitled

00:45:21.400 --> 00:45:23.340
The Challenges of the Steering Council.

00:45:24.300 --> 00:45:25.700
That's pretty interesting here.

00:45:26.920 --> 00:45:27.980
Tell us about this one.

00:45:28.760 --> 00:45:31.660
Yeah, so this one was kind of talking about,

00:45:32.160 --> 00:45:33.000
as a core developer,

00:45:35.140 --> 00:45:37.780
how is the experience of having a steering council

00:45:38.400 --> 00:45:39.660
governing the development of Python?

00:45:40.120 --> 00:45:41.640
How is that working out right now?

00:45:41.660 --> 00:45:42.180
What are the challenges?

00:45:42.500 --> 00:45:42.860
What's the good?

00:45:42.940 --> 00:45:43.340
What's the bad?

00:45:45.120 --> 00:45:55.220
And I think the highlights are having a completely rotating governance set of people on a council.

00:45:55.900 --> 00:45:59.380
Even if that means that most people are still on the council year over year,

00:45:59.940 --> 00:46:05.080
you still have that whole complete stoppage of time because people are starting to wind down

00:46:05.220 --> 00:46:06.500
because they know an election is coming.

00:46:08.060 --> 00:46:11.400
So PEP development gets impacted by that, right?

00:46:11.560 --> 00:46:17.640
If you're not timing your PEP authorship right, then sometimes you just get these huge delays.

00:46:19.080 --> 00:46:26.760
Also talking about how much the need for consensus impacts people's ability to participate in the discussions.

00:46:28.080 --> 00:46:31.340
So before, you could just participate openly.

00:46:31.340 --> 00:46:38.080
You don't have to worry about, oh, am I speaking as the steering council or am I speaking as individual or core developer?

00:46:38.820 --> 00:46:50.380
But now there's such a need for consensus that it kind of puts steering council members in a weird spot where they can't participate in the discussion unless they've already talked with other people in the steering council or do that as easily.

00:46:51.920 --> 00:46:53.540
And I think there was one more.

00:46:54.280 --> 00:47:03.960
One of the threads was I had a conversation with somebody who is a core developer but also happens to be on the steering council.

00:47:04.740 --> 00:47:08.420
I felt like we were in agreement on this idea.

00:47:08.640 --> 00:47:12.340
But then when I spoke to them as steering council member,

00:47:12.900 --> 00:47:16.760
then the story changed a little bit because it was a committee response.

00:47:17.640 --> 00:47:22.900
And you're like, I think Eric Snow himself expressed frustration that like,

00:47:27.279 --> 00:47:28.400
I've worked

00:47:28.400 --> 00:47:28.920
on this project.

00:47:29.060 --> 00:47:30.100
I thought we had agreement.

00:47:30.260 --> 00:47:32.380
And then it turns out for some reason it wasn't, right?

00:47:32.820 --> 00:47:33.080
Yeah.

00:47:33.320 --> 00:47:41.640
I think, yeah, it's really hard to know if you have consensus when the response is delayed

00:47:41.870 --> 00:47:48.360
because you can't tell then if it's consensus because the discussion is slowed down and

00:47:48.480 --> 00:47:53.340
no one's bringing up any new points or if it's because people have thoughts but then

00:47:53.420 --> 00:47:59.240
they have to talk to their steering council fellow members and then it's difficult to

00:47:59.260 --> 00:48:04.000
judge and you don't really want to tip the hat one way or the other during the discussion because

00:48:04.720 --> 00:48:09.480
you don't want to get people with false hope you don't want to like tell people not to work on

00:48:09.640 --> 00:48:12.660
something when it's actually going to go through so it's it's challenging

00:48:12.660 --> 00:48:16.560
yeah two other issues

00:48:17.640 --> 00:48:22.300
i guess it's also worth pointing out before i say this that Eric said look things are working pretty

00:48:22.400 --> 00:48:27.380
well python hasn't stagnating peps are getting approved things are happening right so that's good

00:48:28.100 --> 00:48:35.300
but one challenge is just it's slower to get responses about peps and so on because

00:48:36.560 --> 00:48:43.160
it's volunteer committee work rather than one person who can just be the decider you know

00:48:45.340 --> 00:48:53.059
yeah it's it is really tough and especially and this kind of comes through with like here's all

00:48:52.860 --> 00:48:57.280
these things that are happening to Python all at once. And yeah, good luck, Steering Council,

00:48:57.640 --> 00:49:01.800
with trying to make all of those things work together. Because the thing is, is the Steering

00:49:01.940 --> 00:49:07.600
Council wants all of these good projects that are happening to Python to all land and to all have a

00:49:07.600 --> 00:49:13.760
good time, but they all interdepend on each other. I know that there was like a, like people were

00:49:13.860 --> 00:49:18.080
talking about delegation as like a potential solution for this. And I think the Steering

00:49:18.120 --> 00:49:23.240
council like loves delegation they want to delegate more but they sometimes have an issue with

00:49:23.500 --> 00:49:28.680
delegation when it comes to these topics that like overlap with other big projects that are happening

00:49:28.840 --> 00:49:34.180
concurrently in python where you can't delegate someone for three threading because free threading

00:49:34.280 --> 00:49:39.320
touches everything and so if you delegate something for free threading then that person

00:49:39.720 --> 00:49:44.260
is not looking at all the other projects that are happening in python and that's a problem

00:49:44.280 --> 00:49:48.960
yeah yeah i think another two other things i want to touch on real quick

00:49:48.960 --> 00:49:49.460
there's a

00:49:49.460 --> 00:49:49.600
lot of

00:49:49.720 --> 00:49:50.700
interesting stuff in this one

00:49:50.700 --> 00:49:52.980
one

00:49:52.980 --> 00:49:57.040
is visibility into what's happening in these student council

00:49:57.280 --> 00:50:01.680
discussions right and that talks it's a little bit addressing the surprise but also just knowing

00:50:02.020 --> 00:50:07.500
kind of like you did for the language summit you brought a lot of visibility and awareness of

00:50:07.580 --> 00:50:11.800
what's happening there a lot of this wouldn't be known especially what happened in the discussion

00:50:12.580 --> 00:50:15.200
if it weren't for something like that.

00:50:15.550 --> 00:50:18.240
So Guido pointed out that California, where he lives,

00:50:18.660 --> 00:50:21.420
has the Brown Act, which requires all meetings,

00:50:22.230 --> 00:50:23.220
like governmental meetings,

00:50:24.140 --> 00:50:26.420
to be open to the public for local governmental groups

00:50:26.490 --> 00:50:29.440
in charge of infrastructure without private deliberations

00:50:30.040 --> 00:50:32.520
barring personnel issues or something like that.

00:50:32.640 --> 00:50:37.760
So basically there's regulations or rules for saying,

00:50:37.830 --> 00:50:39.700
like, here's how this stuff is open.

00:50:40.660 --> 00:50:47.220
Maybe all the conversations are live, all the meetings are live streamed or who knows, something like that.

00:50:47.860 --> 00:50:48.160
Yeah.

00:50:48.780 --> 00:50:50.820
No, there was a lot of different

00:50:50.820 --> 00:50:58.360
options thrown out there for how to make these meetings or the deliberations or decision making of the steering council more open.

00:50:58.600 --> 00:51:02.820
One of them we don't put out there that like, oh, maybe they should just be open.

00:51:03.160 --> 00:51:05.280
everyone can see it like a live stream

00:51:05.520 --> 00:51:06.720
or like the meeting minutes are just

00:51:08.320 --> 00:51:09.120
transcribed instantly

00:51:09.340 --> 00:51:11.400
and then published the next day or whatever

00:51:11.640 --> 00:51:12.620
like something like that or

00:51:13.280 --> 00:51:15.340
because right now they publish meeting

00:51:15.580 --> 00:51:17.360
minutes and they're getting

00:51:17.600 --> 00:51:19.200
more regularly doing that

00:51:19.300 --> 00:51:21.180
like actually getting the meeting minutes out on time

00:51:21.260 --> 00:51:22.320
I know there was like some

00:51:23.740 --> 00:51:25.140
there was definitely some

00:51:25.540 --> 00:51:26.840
issue with that in the past where

00:51:27.320 --> 00:51:28.660
like the meeting minutes were really delayed

00:51:29.200 --> 00:51:31.260
and so it's really hard to keep

00:51:31.400 --> 00:51:33.120
up to date with what actually got discussed

00:51:33.140 --> 00:51:33.520
You

00:51:33.520 --> 00:51:38.680
want the 2025 version, not the live stream, but you put your AI assistant in all the

00:51:38.680 --> 00:51:38.840
meetings.

00:51:38.880 --> 00:51:39.380
Sure, yeah.

00:51:39.430 --> 00:51:41.400
And let it

00:51:41.400 --> 00:51:42.280
creep meeting notes.

00:51:42.660 --> 00:51:44.300
Honestly, it probably wouldn't be that bad.

00:51:44.960 --> 00:51:48.080
There might be a few things like, oh, you got that wrong.

00:51:48.380 --> 00:51:48.500
Sorry.

00:51:49.120 --> 00:51:51.400
But in general, I think it would be pretty good.

00:51:51.470 --> 00:51:58.780
And then the last thing here is there was some conversation of like, well, the sighted by committee is tough and how much of the community should we listen to?

00:51:58.980 --> 00:52:05.780
and somewhere it was proposed that maybe things like discuss.python.org,

00:52:06.320 --> 00:52:10.100
we've had polls and people said what they wanted and didn't want, right?

00:52:10.320 --> 00:52:12.900
And Barry wisely points out, like, polls are useful,

00:52:14.000 --> 00:52:16.300
but there's a whole bunch of people, millions of users,

00:52:16.900 --> 00:52:19.120
that are not participating in discourse.

00:52:20.060 --> 00:52:26.300
And I just want to take a moment to, like, restate,

00:52:26.340 --> 00:52:32.180
I think that Scott Hanselman has such an amazing topic or idea here where he calls,

00:52:32.760 --> 00:52:36.160
talks about the dark matter developers, the unseen 99%.

00:52:36.220 --> 00:52:36.920
I'll link to this.

00:52:37.100 --> 00:52:39.340
So obviously we know what dark matter is in astronomy.

00:52:39.530 --> 00:52:41.780
But like these are people who just go to their jobs.

00:52:42.580 --> 00:52:44.880
They don't spend their evenings on discussion boards.

00:52:45.600 --> 00:52:49.580
They don't go to conferences and participate in panel discussions.

00:52:50.460 --> 00:52:51.400
They're not on social media.

00:52:51.510 --> 00:52:55.480
They just use Python or whatever language and they do their thing.

00:52:55.560 --> 00:52:56.900
and it matters deeply to them,

00:52:57.120 --> 00:53:00.180
but you won't ever notice them in these polls

00:53:00.500 --> 00:53:02.020
or PSF surveys or whatever

00:53:02.180 --> 00:53:04.060
because they just don't do those things.

00:53:04.150 --> 00:53:05.600
It was probably a good chunk of them.

00:53:06.840 --> 00:53:09.380
Yeah, and the steering council has the

00:53:09.380 --> 00:53:10.040
difficult job

00:53:10.280 --> 00:53:11.340
of representing these folks too

00:53:11.560 --> 00:53:11.800
because they

00:53:11.800 --> 00:53:12.640
can't do what's

00:53:12.640 --> 00:53:13.780
best for Python

00:53:13.970 --> 00:53:14.600
and that's for everybody,

00:53:14.840 --> 00:53:16.600
not just people that vote in polls on this.

00:53:16.760 --> 00:53:17.120
Right, right.

00:53:17.220 --> 00:53:17.900
That's what Barry was saying.

00:53:18.080 --> 00:53:19.060
It's tricky though.

00:53:19.060 --> 00:53:19.960
It's like, how do you measure that?

00:53:20.080 --> 00:53:20.620
You know what I mean?

00:53:21.000 --> 00:53:22.760
Yeah, it is super, super tricky.

00:53:23.500 --> 00:53:23.740
All right.

00:53:25.780 --> 00:53:31.240
packaging. Yeah, so this one was really quite a quick talk where it was mostly just talking about,

00:53:31.420 --> 00:53:35.540
hey, this PEP is happening, the packaging governance process. I know that this got discussed

00:53:35.700 --> 00:53:41.640
a lot more in the packaging summit. Here, I think it was mostly just like, hey, this is happening.

00:53:41.900 --> 00:53:43.280
Here's what the steering council needs to know.

00:53:43.380 --> 00:53:43.480
Here's

00:53:43.480 --> 00:53:44.740
what core developers need to know.

00:53:46.260 --> 00:53:51.120
This whole thing came out of the wheel next directive, which is like wheel next.dev.

00:53:51.180 --> 00:53:59.260
they've got their own website and it's basically trying to adopt the steering council model but

00:53:59.320 --> 00:54:04.140
for packaging because right now packaging peps tend to be delegated to like one or two people

00:54:05.319 --> 00:54:12.820
and obviously if things 10x or 100x in complexity and concurrent projects it is just not possible

00:54:13.040 --> 00:54:19.020
for one person to just be doing that work and so trying to adopt a council model so what are the

00:54:18.880 --> 00:54:20.680
steering council. I think the biggest open

00:54:20.880 --> 00:54:22.200
questions right now are things like

00:54:22.740 --> 00:54:24.780
how is that initial council and

00:54:24.920 --> 00:54:26.700
how is the voting body going to be

00:54:26.980 --> 00:54:28.780
formed? Because the voting body for the

00:54:28.900 --> 00:54:29.900
steering council is core developers,

00:54:30.800 --> 00:54:32.900
but what is the voting body for

00:54:33.060 --> 00:54:33.600
Python packaging?

00:54:35.200 --> 00:54:36.820
Right, exactly. And again,

00:54:36.880 --> 00:54:38.560
it runs into some of the issues of

00:54:40.640 --> 00:54:41.120
delegating

00:54:41.360 --> 00:54:42.660
but packaging touches everything

00:54:43.340 --> 00:54:43.980
and so on.

00:54:46.280 --> 00:54:46.760
Tricky.

00:54:48.040 --> 00:54:48.920
Okay, excellent.

00:54:49.480 --> 00:54:51.760
And you referenced this one, Python Unmobile,

00:54:52.400 --> 00:54:53.060
by Russell,

00:54:53.300 --> 00:54:54.460
Keith McGee, and Malcolm Smith.

00:54:54.600 --> 00:54:57.140
I just had Russell on the show not too long ago

00:54:57.220 --> 00:54:59.020
to talk about some of this work as well.

00:55:00.460 --> 00:55:01.900
But he says, after many years,

00:55:02.220 --> 00:55:04.720
this year I can say that Python Unmobile is there.

00:55:06.660 --> 00:55:08.760
Met with a large round of applause from the room.

00:55:09.220 --> 00:55:09.500
Yeah,

00:55:10.020 --> 00:55:11.180
it was an awesome moment,

00:55:11.400 --> 00:55:15.440
especially because I covered kind of like one of the last status reports

00:55:15.660 --> 00:55:17.560
before the big hurrah, we did it.

00:55:18.120 --> 00:55:20.300
with Russell and Malcolm.

00:55:21.420 --> 00:55:24.020
Yeah, basically both of the peps for Android support

00:55:24.240 --> 00:55:25.600
and iOS support are finished,

00:55:26.170 --> 00:55:28.560
and they are tracking really, really close

00:55:29.370 --> 00:55:31.440
to basically adding tier two support

00:55:31.760 --> 00:55:33.540
for iOS and Android to Python,

00:55:33.980 --> 00:55:36.620
and tier two support basically means

00:55:36.800 --> 00:55:39.320
that if any feature change or bug fix or anything

00:55:40.020 --> 00:55:41.720
ends up breaking support for that platform,

00:55:41.850 --> 00:55:43.300
then a release can't proceed.

00:55:44.440 --> 00:55:47.039
So the platform basically needs to be supported

00:55:47.060 --> 00:55:47.940
for a release to happen,

00:55:48.220 --> 00:55:48.620
and that's

00:55:48.620 --> 00:55:49.060
a huge deal

00:55:49.190 --> 00:55:50.880
because it means that people can be confident

00:55:51.100 --> 00:55:53.080
that support isn't going to just be taken away

00:55:53.380 --> 00:55:57.760
or not surprised it doesn't work, which is great.

00:55:58.250 --> 00:56:00.440
So basically it just means there's a whole new,

00:56:01.200 --> 00:56:02.700
hopefully a whole new set of users

00:56:02.940 --> 00:56:05.080
that can use Python to build on these mobile platforms.

00:56:05.680 --> 00:56:06.420
Yeah, that'd be great.

00:56:06.680 --> 00:56:09.200
So specifically PEP 730 and 738,

00:56:10.680 --> 00:56:14.500
meaning that CPython builds and runs on iOS

00:56:14.900 --> 00:56:16.440
and builds and runs on Android.

00:56:17.780 --> 00:56:22.120
and that the core development team

00:56:23.120 --> 00:56:26.780
considers breaking that build

00:56:27.140 --> 00:56:28.980
part of breaking Python.

00:56:30.720 --> 00:56:32.420
There's still work to be done

00:56:32.630 --> 00:56:33.880
in terms of tooling.

00:56:35.260 --> 00:56:38.020
I'm not going to get a Python plugin for Xcode

00:56:38.030 --> 00:56:39.720
and drag a storyboard across

00:56:40.410 --> 00:56:41.240
and then publish it.

00:56:41.730 --> 00:56:43.719
Some of that stuff is coming from the Beware team

00:56:45.320 --> 00:56:47.260
backed by Anaconda, which is great.

00:56:47.640 --> 00:56:50.400
But I think this announcement is like

00:56:50.940 --> 00:56:54.860
the runtime CPython bits

00:56:54.860 --> 00:56:56.020
are in place, right?

00:56:56.040 --> 00:56:56.640
Yeah, definitely.

00:56:57.000 --> 00:56:58.680
So like, yeah, it's not like,

00:56:58.720 --> 00:57:00.260
oh, suddenly Xcode just works

00:57:00.580 --> 00:57:02.340
and you can just write an Xcode project in Python

00:57:03.020 --> 00:57:04.420
just as easily as you would write,

00:57:04.980 --> 00:57:06.240
you know, a web app in Python.

00:57:07.660 --> 00:57:08.480
But yeah, the fact that it

00:57:08.480 --> 00:57:08.720
works

00:57:08.720 --> 00:57:09.080
at all,

00:57:09.480 --> 00:57:10.100
like the fact that

00:57:10.100 --> 00:57:12.339
you can run it on an iPhone

00:57:12.360 --> 00:57:15.120
or on an Android phone, that's huge.

00:57:15.440 --> 00:57:16.820
And the core developer

00:57:16.820 --> 00:57:18.080
team is willing to say,

00:57:18.100 --> 00:57:19.100
yeah, this is going to keep working.

00:57:22.160 --> 00:57:22.600
They should.

00:57:22.980 --> 00:57:26.400
It's not a flash in the pan, these mobile phones.

00:57:26.760 --> 00:57:27.380
Some people use them.

00:57:29.160 --> 00:57:29.600
Allegedly.

00:57:30.640 --> 00:57:31.120
Allegedly.

00:57:31.600 --> 00:57:32.860
How many do I have around me?

00:57:33.280 --> 00:57:33.600
I know.

00:57:35.040 --> 00:57:36.040
As I have one

00:57:36.040 --> 00:57:36.360
in view.

00:57:36.840 --> 00:57:37.300
Yeah, exactly.

00:57:37.660 --> 00:57:39.680
Where's the iPads and all the other stuff?

00:57:41.380 --> 00:57:43.380
Yeah, if I never see Xcode again in my life,

00:57:43.400 --> 00:57:44.320
I would be too soon.

00:57:45.460 --> 00:57:48.380
It's just such a bad piece of software.

00:57:48.680 --> 00:57:48.860
It's

00:57:48.860 --> 00:57:50.220
such a bad tool for building software.

00:57:50.380 --> 00:57:51.860
I've had to work with a lot for our mobile apps.

00:57:52.780 --> 00:57:53.780
I'm thankfully not having

00:57:53.780 --> 00:57:56.880
to dealt with any app development yet in my career.

00:57:57.060 --> 00:57:57.980
It's been all web development.

00:58:00.400 --> 00:58:04.960
It's such, you don't appreciate the freedom that you have.

00:58:05.100 --> 00:58:07.140
I know open source means freedom in some ways,

00:58:07.600 --> 00:58:09.980
but just the ability to go, I made a change.

00:58:10.640 --> 00:58:11.800
I published it.

00:58:12.420 --> 00:58:13.320
The world has it.

00:58:13.680 --> 00:58:19.000
It's not like I've had a debate with random people who are in a hurry and don't care about what I've built.

00:58:19.240 --> 00:58:24.920
And then they tell me that it infringes on something somebody else built even when that's actually not true because they don't understand what it does.

00:58:26.540 --> 00:58:27.640
That's even outside.

00:58:28.340 --> 00:58:31.400
A lot more people involved in mobile publishing.

00:58:31.860 --> 00:58:35.980
And rules that don't align with your incentives.

00:58:36.220 --> 00:58:37.880
Like we want to extract money from you.

00:58:38.140 --> 00:58:40.640
Anyway, that's a long story in-app purchases.

00:58:42.600 --> 00:58:42.740
Okay.

00:58:45.080 --> 00:58:47.860
Another one, I hinted at this, like,

00:58:48.580 --> 00:58:51.060
are we going to need to change the name of CPython?

00:58:51.320 --> 00:58:55.220
Because CPython means literally the C language implementation of Python.

00:58:56.560 --> 00:58:58.420
What do Cordell Albers want from Rust?

00:58:59.040 --> 00:59:00.960
And do they want Rust in their CPython?

00:59:01.400 --> 00:59:03.240
You know, is this a Reese's Pieces,

00:59:05.380 --> 00:59:07.120
Reese's Peanut Butter Cup sort of thing?

00:59:07.680 --> 00:59:08.800
You got your Rust in

00:59:08.800 --> 00:59:09.840
my C or something, right?

00:59:09.840 --> 00:59:10.000
R&P.

00:59:10.960 --> 00:59:11.080
Yeah.

00:59:11.220 --> 00:59:11.880
Yeah, yeah, yeah.

00:59:13.360 --> 00:59:15.440
Yeah, this was a really interesting one

00:59:15.520 --> 00:59:20.680
because I think that the room was maybe a little bit surprised

00:59:20.900 --> 00:59:25.260
by how open core developers were

00:59:25.440 --> 00:59:28.760
about maybe the idea of something optional

00:59:29.400 --> 00:59:32.500
being in CPython that is written in Rust.

00:59:34.220 --> 00:59:36.360
Because CPython, there's the core runtime, right?

00:59:36.520 --> 00:59:38.080
There's the syntax, there's the interpreter,

00:59:38.380 --> 00:59:40.600
there's all that stuff that everyone uses

00:59:40.720 --> 00:59:41.840
on every single Python session.

00:59:42.000 --> 00:59:44.000
But then there's also all these standard library modules

00:59:45.320 --> 00:59:49.500
like OS and Sys and SSL

00:59:49.800 --> 00:59:51.020
and all of these other libraries, right?

00:59:52.880 --> 00:59:57.460
And those modules are kind of their own thing.

00:59:57.700 --> 00:59:58.940
They're their own little project

00:59:59.260 --> 01:00:01.260
that just happens to live inside of CPython.

01:00:01.860 --> 01:00:04.939
And I think the result of all of this conversation

01:00:04.940 --> 01:00:08.500
of what do core developers want from Rust

01:00:09.100 --> 01:00:12.580
was like, hey, let's try something.

01:00:14.260 --> 01:00:16.880
Maybe having a standard library extension module

01:00:17.340 --> 01:00:17.900
written in Rust.

01:00:18.160 --> 01:00:19.800
What would that take?

01:00:20.200 --> 01:00:21.340
What would that look like?

01:00:22.040 --> 01:00:23.660
Would we need to change the build system?

01:00:25.400 --> 01:00:26.620
What would actually need to happen

01:00:27.140 --> 01:00:28.360
for that to be a possibility?

01:00:29.760 --> 01:00:32.640
I think there's some huge benefits to having Rust.

01:00:32.780 --> 01:00:35.360
I mean, David talked about a whole bunch of them where it's like,

01:00:35.540 --> 01:00:36.500
it's this new language.

01:00:36.820 --> 01:00:38.880
There's lots of new programmers that are interested in it.

01:00:39.260 --> 01:00:40.500
It has all the memory safety stuff.

01:00:40.620 --> 01:00:41.880
It has all the performance stuff.

01:00:42.480 --> 01:00:43.000
The threading.

01:00:43.520 --> 01:00:43.680
Yeah.

01:00:44.160 --> 01:00:45.800
Free threading works really great with it.

01:00:46.400 --> 01:00:51.240
There's just like tons of benefits to having Rust be a part of like a Python,

01:00:51.840 --> 01:00:53.100
Python developers toolkit.

01:00:53.860 --> 01:00:56.900
And it's like, how can we, can we also have that in the core libraries?

01:00:59.100 --> 01:01:02.260
And I think the answer was like, try it out and see what happens.

01:01:02.460 --> 01:01:04.520
and maybe who knows, right?

01:01:05.440 --> 01:01:06.900
They definitely, like core developers,

01:01:07.220 --> 01:01:08.380
caveated it as like,

01:01:08.940 --> 01:01:10.580
it'll definitely have to be an optional part

01:01:10.580 --> 01:01:11.520
of the standard library

01:01:12.740 --> 01:01:16.780
because not everyone is going to be using Rust on CPython.

01:01:18.780 --> 01:01:21.120
And yeah, maybe not one of the core parts

01:01:21.320 --> 01:01:24.620
of the actual, of the interpreter in the runtime

01:01:24.940 --> 01:01:28.200
because they're quite well used,

01:01:28.800 --> 01:01:30.160
well maintained right now.

01:01:30.820 --> 01:01:31.640
So we'll see.

01:01:31.900 --> 01:01:39.080
I think it's going to be interesting to see if David and some other interested folks will put together something like a standard library module that uses Rust.

01:01:39.500 --> 01:01:41.820
Yeah, maybe in 2035 we'll still be doing this.

01:01:41.850 --> 01:01:52.280
We'll still be talking about how the C adaptive layer to integrate with Rust is working so we can still keep all these C extensions running instead of the other way around.

01:01:52.840 --> 01:01:53.540
Yeah, yeah.

01:01:54.560 --> 01:01:55.400
A couple of interesting takeaways.

01:01:56.440 --> 01:02:04.740
David points out, our best estimate is that somewhere between a quarter and a third of all native code being uploaded to PyPI for new projects is using Rust.

01:02:06.700 --> 01:02:19.960
Yeah, so this uses like, basically use this, it's py-code.org, where it can introspect into Python packages, the actual files that are uploaded, and then looks for Rust.

01:02:21.400 --> 01:02:25.580
And so any package that is using Rust

01:02:26.340 --> 01:02:27.800
and it's a new package or a new release,

01:02:28.200 --> 01:02:32.500
you can see what percentage of new projects are using Rust

01:02:32.720 --> 01:02:35.240
versus C or C++ or something else.

01:02:36.020 --> 01:02:39.580
So David was able to extract that data point.

01:02:39.600 --> 01:02:41.560
So yeah, there's a lot of Rust happening for new projects.

01:02:41.760 --> 01:02:45.660
Obviously, old projects are likely very C, C++ dominated,

01:02:45.900 --> 01:02:46.620
but what are

01:02:46.620 --> 01:02:47.520
new Python

01:02:47.520 --> 01:02:48.900
developers choosing to use?

01:02:49.640 --> 01:02:49.840
Yeah.

01:02:52.860 --> 01:02:53.760
they didn't choose C.

01:02:53.820 --> 01:02:55.940
They just chose not to rewrite it in Rust yet,

01:02:56.120 --> 01:02:59.180
which is a different barrier, I suppose.

01:02:59.500 --> 01:02:59.620
Yeah.

01:03:00.040 --> 01:03:01.580
Not saying they should, but, you know,

01:03:02.480 --> 01:03:05.840
I agree that choosing new projects is an interesting metric.

01:03:07.180 --> 01:03:09.320
So a couple other things from here is, like,

01:03:09.600 --> 01:03:11.660
should we rewrite CPython in Rust?

01:03:12.340 --> 01:03:15.000
There's a lot of people, like, or a lot of comments are, like,

01:03:15.060 --> 01:03:17.460
there's a lot of people who just don't want to learn Rust,

01:03:18.020 --> 01:03:18.760
they don't care about Rust.

01:03:19.520 --> 01:03:28.100
This is a challenge for CPython is that the core developers in particular

01:03:28.300 --> 01:03:32.220
have a special skill of writing C and writing CPython in particular.

01:03:33.260 --> 01:03:35.800
And this moved the cheese for a lot of folks.

01:03:35.840 --> 01:03:38.260
And they, like, how

01:03:38.260 --> 01:03:38.740
much do

01:03:38.740 --> 01:03:39.360
they care, right?

01:03:39.420 --> 01:03:46.140
Like, they took Rust on Linux, Rust and Linux Core as an example, right?

01:03:46.220 --> 01:03:48.420
People just, they don't want to change,

01:03:48.760 --> 01:03:50.180
which I'm not saying they should, but...

01:03:50.560 --> 01:03:51.040
Yeah,

01:03:51.080 --> 01:03:52.980
it's a really difficult question,

01:03:53.240 --> 01:03:56.900
especially when there's this really tight ownership

01:03:57.300 --> 01:03:59.160
of one or a few people

01:03:59.500 --> 01:04:01.240
with this very specific part of code.

01:04:02.780 --> 01:04:04.380
And they've been maintaining it

01:04:05.660 --> 01:04:07.180
for a really long time,

01:04:07.260 --> 01:04:10.100
and it's hard to try to force

01:04:10.280 --> 01:04:11.360
that sort of change onto people.

01:04:11.560 --> 01:04:13.180
But then things that are new

01:04:13.480 --> 01:04:14.380
or things that are optional,

01:04:15.360 --> 01:04:16.680
that's a really great place to start.

01:04:17.320 --> 01:04:21.520
I think learning from the Rust and Linux project

01:04:21.920 --> 01:04:23.780
is a really great idea for Python

01:04:24.610 --> 01:04:26.060
because it's, in a lot of ways,

01:04:26.310 --> 01:04:30.100
even though Linux maybe is an order of magnitude more complexity,

01:04:30.400 --> 01:04:31.840
I think that the situation

01:04:32.290 --> 01:04:34.720
or the structure of the code in the project

01:04:34.850 --> 01:04:37.020
is pretty similar where there's this really big core

01:04:37.050 --> 01:04:40.280
and then there's a ton of different smaller subprojects

01:04:40.360 --> 01:04:42.640
that all have their own little owners,

01:04:43.060 --> 01:04:45.400
governance, contributors happening in the background.

01:04:45.960 --> 01:04:47.280
Yeah, 100%.

01:04:47.420 --> 01:04:50.540
I mean, it is 2025.

01:04:51.070 --> 01:04:52.940
We could try again.

01:04:53.940 --> 01:04:55.260
Maybe we could just vibe code it like,

01:04:55.700 --> 01:04:59.460
hey, Cursor, rewrite CPython in Rust or you go to jail.

01:05:02.280 --> 01:05:02.440
Is

01:05:02.440 --> 01:05:03.160
that the meta we say?

01:05:05.660 --> 01:05:07.460
There's this really great video.

01:05:07.630 --> 01:05:08.980
A senior engineer tries vibe coding.

01:05:09.640 --> 01:05:12.720
It's always telling it like if it doesn't do it, it'll go to jail.

01:05:13.100 --> 01:05:15.340
But also says please, like, or you go to jail, please.

01:05:16.380 --> 01:05:16.860
It's amazing.

01:05:17.560 --> 01:05:26.760
I mean, as much as I joke, honestly, I do think AI code assistance could help in supporting the transition.

01:05:27.440 --> 01:05:29.420
I know that's good at C and it's good at REST.

01:05:30.180 --> 01:05:31.240
Not that you should have high-coded.

01:05:31.420 --> 01:05:32.120
That's not what I'm saying.

01:05:33.940 --> 01:05:37.160
But anyway, we live in weird times, Zach.

01:05:37.210 --> 01:05:37.460
We do.

01:05:37.980 --> 01:05:38.260
We

01:05:38.260 --> 01:05:38.800
really do.

01:05:40.240 --> 01:05:46.820
I think the other constraint here that maybe a lot of people don't track

01:05:47.440 --> 01:05:56.180
is that it's not just I need to somehow make CPython work on Linux, Windows, and Mac.

01:05:57.260 --> 01:05:59.300
And if we're building Rust, that's a different tool chain.

01:05:59.800 --> 01:06:06.060
There are a bunch of edge cases and platforms that are not very commonly used

01:06:06.080 --> 01:06:08.200
that maybe Rust itself doesn't even support

01:06:08.940 --> 01:06:11.800
that Python has promised to keep running on, right?

01:06:12.420 --> 01:06:15.400
Yeah, or, I mean, even if not promised, right?

01:06:15.520 --> 01:06:16.680
Like, there's people

01:06:16.680 --> 01:06:17.080
that are

01:06:17.080 --> 01:06:17.760
just running

01:06:17.760 --> 01:06:18.500
on

01:06:18.500 --> 01:06:19.020
these platforms,

01:06:19.500 --> 01:06:21.340
and then if something were to break,

01:06:21.920 --> 01:06:23.560
they would only show up when something breaks.

01:06:26.100 --> 01:06:27.660
And what do you do, right?

01:06:27.710 --> 01:06:28.980
Like, you've been supporting these people

01:06:29.240 --> 01:06:33.800
for a very, very long time, and what happens then?

01:06:34.220 --> 01:06:37.120
What stability guarantees do you give those people that, you know,

01:06:37.380 --> 01:06:41.640
maybe you're not like a tier one platform, but if

01:06:41.640 --> 01:06:42.100
you've been,

01:06:42.500 --> 01:06:42.620
you know,

01:06:42.680 --> 01:06:46.020
making them use, like they've been using Python totally normally for all this

01:06:46.160 --> 01:06:47.140
time, what does that mean?

01:06:47.840 --> 01:06:50.460
Yeah. Well, we just talked about tier three iOS and Android support.

01:06:50.740 --> 01:06:53.040
Like, does it work there? I have maybe, I don't know,

01:06:53.540 --> 01:06:58.040
but you've got like this little micro Python,

01:06:58.500 --> 01:07:00.740
circuit Python chip that I got. That's like, I don't know,

01:07:00.780 --> 01:07:03.840
the size of a thumb or something.

01:07:05.020 --> 01:07:06.280
Does the build system work for that?

01:07:06.380 --> 01:07:06.820
I don't know.

01:07:08.260 --> 01:07:09.420
But I'm running Python on it today.

01:07:09.880 --> 01:07:09.960
Yeah.

01:07:10.300 --> 01:07:12.580
I think that one of the things that got identified

01:07:12.920 --> 01:07:16.160
was the state of GCC support for Rust

01:07:16.820 --> 01:07:18.140
as something interesting.

01:07:18.240 --> 01:07:18.760
So that's something to

01:07:18.760 --> 01:07:19.060
track

01:07:19.200 --> 01:07:23.840
if you're interested in Rust and CPython working together.

01:07:24.040 --> 01:07:25.000
That's definitely a project

01:07:25.360 --> 01:07:28.580
that's outside of Python and Rust

01:07:28.600 --> 01:07:31.620
and Maturin and Pyo-3s

01:07:32.070 --> 01:07:33.960
if you want to watch that project.

01:07:35.060 --> 01:07:35.160
Yeah.

01:07:37.050 --> 01:07:38.200
I did say we need to go faster.

01:07:38.880 --> 01:07:39.320
Lightning around.

01:07:40.460 --> 01:07:41.120
Close things

01:07:41.120 --> 01:07:41.700
out here.

01:07:42.240 --> 01:07:42.940
I guess there's really,

01:07:43.300 --> 01:07:44.680
there's just the Pyo-dyed.

01:07:44.710 --> 01:07:46.100
We didn't talk about the docs

01:07:46.580 --> 01:07:47.220
or the lightning talks.

01:07:49.420 --> 01:07:50.480
What else should we say

01:07:50.620 --> 01:07:52.120
before we call it a wrap on this?

01:07:52.820 --> 01:07:54.180
Let's go into the lightning talks

01:07:54.460 --> 01:07:56.500
and look at Guido's.

01:07:57.600 --> 01:08:02.820
I think that one was the most well-received and interesting lightning talk,

01:08:03.020 --> 01:08:07.340
which is contrasting how Python is developed today

01:08:08.100 --> 01:08:10.460
versus how it was developed by Guido

01:08:10.800 --> 01:08:15.020
and what sorts of things are we kind of like leaving behind

01:08:15.520 --> 01:08:17.380
by developing Python in this way

01:08:17.500 --> 01:08:19.880
and is there anything that we can learn from

01:08:19.880 --> 01:08:20.740
how we use it?

01:08:20.819 --> 01:08:23.720
Does he mean more committee, more

01:08:23.720 --> 01:08:26.100
community agreement,

01:08:26.120 --> 01:08:27.200
or what was he getting at?

01:08:27.500 --> 01:08:32.440
I think it's the complexity side was the part that was really big for him,

01:08:32.620 --> 01:08:38.080
where it's like we're trying to, if you want to land a feature in CPython,

01:08:38.290 --> 01:08:43.180
you need to write a perfect pep, come with a pull request that is, you know,

01:08:43.759 --> 01:08:49.799
performant and secure and the API is perfect and it's been vetted and it's been used.

01:08:50.020 --> 01:08:56.020
And like there's this super, super high bar to clear to add a feature to CPython.

01:08:58.080 --> 01:09:00.440
and you're not allowed to get it wrong

01:09:01.160 --> 01:09:02.420
the first go around basically

01:09:02.940 --> 01:09:04.500
I think was what he's mentioning

01:09:05.760 --> 01:09:07.359
demanding perfection means

01:09:07.859 --> 01:09:09.660
it's like the code equivalent of

01:09:09.819 --> 01:09:13.220
don't let great be the enemy of the good

01:09:13.220 --> 01:09:13.940
or something like that right?

01:09:13.980 --> 01:09:14.100
Sure,

01:09:14.240 --> 01:09:14.600
yeah exactly

01:09:16.600 --> 01:09:17.960
yeah stuff like that where it's like

01:09:17.960 --> 01:09:22.180
hey if Python were developed in that way early on

01:09:22.339 --> 01:09:24.060
it wouldn't have worked out

01:09:25.220 --> 01:09:25.380
because

01:09:25.380 --> 01:09:25.740
that...

01:09:25.740 --> 01:09:27.600
It'd still be in the lab or an idea or something.

01:09:27.720 --> 01:09:27.900
Exactly.

01:09:28.480 --> 01:09:30.560
So I think that's a really interesting one to check out

01:09:30.630 --> 01:09:31.640
if you're looking at the lightning cost.

01:09:33.319 --> 01:09:33.859
Okay, cool.

01:09:34.190 --> 01:09:40.100
Now, I know some features have to be absolutely dead center

01:09:40.210 --> 01:09:41.680
in the core of the CPython runtime,

01:09:42.000 --> 01:09:45.299
like free threading or a no-gil initiative

01:09:46.400 --> 01:09:49.620
or some new memory model or whatever.

01:09:50.680 --> 01:09:54.740
But a lot of these things probably, certainly with a standard library,

01:09:55.340 --> 01:09:58.000
could maybe, you know, you talked about the immutable,

01:09:58.620 --> 01:10:01.400
the thread-safe concurrency data structures.

01:10:01.940 --> 01:10:05.740
Maybe there's a more formalized path of starting these things

01:10:05.840 --> 01:10:08.000
as third-party libraries on PyPI.

01:10:09.020 --> 01:10:13.120
And once they reach a certain bar maybe of adoption and maturity,

01:10:14.020 --> 01:10:16.140
then they make a step towards that.

01:10:16.140 --> 01:10:19.340
It would be interesting if, I know people can just go

01:10:19.300 --> 01:10:23.300
and create a project and do it, but here's the prescribed way

01:10:23.640 --> 01:10:28.560
of non-C runtime features being added to the language,

01:10:29.340 --> 01:10:32.560
and it starts out in public and it makes its way over.

01:10:33.060 --> 01:10:36.700
Yeah, I think that got discussed in the last language summit too.

01:10:36.800 --> 01:10:40.240
I'm not sure if there's been any progress on actually making a solid model

01:10:40.420 --> 01:10:43.940
for here's how you go from PyPI to PEP to standard library,

01:10:44.200 --> 01:10:49.260
but I think it's just going to keep coming up until that happens

01:10:49.280 --> 01:10:50.300
Because this is really common, right?

01:10:50.480 --> 01:10:50.960
Yeah.

01:10:51.640 --> 01:10:53.320
So many features get developed this way now.

01:10:54.140 --> 01:10:54.940
It's also interesting,

01:10:55.650 --> 01:10:58.860
some of the ideas of that direction have been rejected,

01:10:59.080 --> 01:11:01.520
like moving requests into

01:11:01.520 --> 01:11:02.840
CPython's

01:11:02.840 --> 01:11:03.300
standard library

01:11:03.440 --> 01:11:05.960
was rejected because it would harm the growth

01:11:06.140 --> 01:11:08.260
and status of requests, not CPython.

01:11:08.820 --> 01:11:09.180
Even

01:11:09.180 --> 01:11:10.320
though request is clearly better

01:11:10.460 --> 01:11:13.580
than what's built into CPython for your access.

01:11:14.960 --> 01:11:16.800
Throw no shade, that stuff's been around for a long time.

01:11:17.180 --> 01:11:17.320
Yeah.

01:11:18.100 --> 01:11:20.780
I mean, request is built on it, so it obviously

01:11:20.780 --> 01:11:21.900
does some job well.

01:11:22.500 --> 01:11:23.200
Yeah, yeah, exactly.

01:11:23.400 --> 01:11:27.420
It's just like a more user-friendly, higher-level API in front of it.

01:11:28.080 --> 01:11:33.260
And we have HTTPX for concurrent, basically, asyncio requests

01:11:33.260 --> 01:11:34.880
equivalent.

01:11:37.220 --> 01:11:41.220
So there's certainly history or examples of stuff starting out there,

01:11:41.420 --> 01:11:43.800
becoming very popular, but not wanting to go in,

01:11:44.340 --> 01:11:46.560
but specifically things that you might want to.

01:11:46.720 --> 01:11:51.700
Like, for example, would data classes be a thing

01:11:51.960 --> 01:11:56.200
if Pydantic was on a trajectory to sort of fill that role

01:11:56.380 --> 01:11:57.780
or adders for

01:11:57.780 --> 01:11:58.140
Manic

01:11:58.140 --> 01:11:59.180
or something like that, right?

01:11:59.840 --> 01:12:00.280
Maybe not.

01:12:00.400 --> 01:12:00.780
I don't know.

01:12:01.040 --> 01:12:01.380
Yeah.

01:12:01.700 --> 01:12:05.880
No, I think that that whole road of experimentation

01:12:06.480 --> 01:12:07.720
and then moving into the standard library,

01:12:08.020 --> 01:12:09.780
like, we're just going to keep seeing it

01:12:09.940 --> 01:12:11.980
because it's such a great way to get stuff

01:12:12.000 --> 01:12:13.440
in the hands of users really, really quickly.

01:12:14.020 --> 01:12:14.180
Yeah.

01:12:14.500 --> 01:12:17.360
And I don't think just, like, if I just went out and made a library,

01:12:17.780 --> 01:12:19.800
said, I'm doing a library, and I think it would be fun

01:12:19.880 --> 01:12:21.460
to have this as part of Python, like, people go,

01:12:21.650 --> 01:12:22.240
good for you, Michael.

01:12:22.820 --> 01:12:23.660
And they would ignore it, right?

01:12:24.040 --> 01:12:27.880
But if it was a little bit blessed by the steering kit,

01:12:27.920 --> 01:12:30.260
like, we're experimenting and considering this idea

01:12:30.450 --> 01:12:31.120
as core developers.

01:12:31.920 --> 01:12:34.880
It starts here, but if it gains traction, it becomes Python.

01:12:35.500 --> 01:12:38.480
I think that is a different positioning

01:12:39.350 --> 01:12:41.520
than just, like, a random project that looks interesting.

01:12:41.780 --> 01:12:42.420
Yeah, definitely.

01:12:42.760 --> 01:12:58.440
I think that last year, one of the things that got suggested was like, hey, maybe we allow people to have those sorts of projects once they reach some amount of maturity and direction to be housed under the Python GitHub org to try to give

01:12:58.440 --> 01:12:59.160
them some sort

01:12:59.160 --> 01:13:06.480
of legitimacy of like, yeah, this project is on the track to going here and here's us showing that it is.

01:13:06.800 --> 01:13:07.220
Yeah.

01:13:09.240 --> 01:13:11.380
I feel like I should just say one more thing, though.

01:13:11.540 --> 01:13:17.240
I do think there's a lot of value in having Python be smaller

01:13:17.460 --> 01:13:20.320
and having a bigger ecosystem outside of it.

01:13:20.920 --> 01:13:24.580
I'm not suggesting that everything should just be moved into Python.

01:13:24.710 --> 01:13:28.240
I do think that just go like, I don't care what CPython does.

01:13:28.410 --> 01:13:30.620
If I like this HTTP library, I'm going to use it.

01:13:31.740 --> 01:13:35.600
And if it wants to implement itself in Rust or OCaml or whatever,

01:13:35.710 --> 01:13:36.180
I don't care.

01:13:36.340 --> 01:13:37.940
If that's better, they can go do that.

01:13:38.640 --> 01:13:41.940
And then I'll use it and it'll be great, right?

01:13:42.140 --> 01:13:44.140
And that doesn't have to go through committees

01:13:44.500 --> 01:13:45.540
and all this kind of stuff.

01:13:45.700 --> 01:13:48.340
So I'm not necessarily saying like everything should try

01:13:48.340 --> 01:13:52.160
to like find a hub and spoke model into the core Python.

01:13:53.500 --> 01:13:55.700
But those things that do intend to be there,

01:13:55.740 --> 01:13:58.680
it would be cool to see like this sort of progressive path

01:13:58.840 --> 01:13:59.940
that people can get to it sooner.

01:14:00.240 --> 01:14:00.320
Anyway.

01:14:03.340 --> 01:14:05.560
Final thoughts on that before we call it a show?

01:14:05.700 --> 01:14:05.820
I

01:14:05.820 --> 01:14:06.980
think we nailed it, honestly.

01:14:08.440 --> 01:14:09.280
We definitely did.

01:14:10.360 --> 01:14:11.020
We definitely did.

01:14:12.120 --> 01:14:14.280
Yeah, no, let's wrap it up.

01:14:14.440 --> 01:14:17.180
Thank you for doing this write-up.

01:14:17.300 --> 01:14:17.920
It's really interesting.

01:14:18.040 --> 01:14:21.780
I always value this look into where's Python going.

01:14:22.880 --> 01:14:24.560
There's a lot to take from it.

01:14:25.160 --> 01:14:27.300
Final thoughts on this year's Language Summit?

01:14:27.960 --> 01:14:31.680
It is a really exciting year to be a Python developer.

01:14:31.820 --> 01:14:36.620
I think that 3.14, it's got so many really interesting things

01:14:36.640 --> 01:14:37.780
and changes to try.

01:14:39.120 --> 01:14:42.020
I am quite excited to get my hands on the beta,

01:14:42.180 --> 01:14:43.560
but then also the stable releases.

01:14:45.060 --> 01:14:48.000
I really am excited to see what people actually then go

01:14:48.160 --> 01:14:49.280
and do with the stuff, right?

01:14:49.380 --> 01:14:52.040
Like building web apps with Python,

01:14:52.340 --> 01:14:53.420
building mobile apps with Python,

01:14:53.800 --> 01:14:57.700
building these massively parallel applications with Python.

01:14:58.680 --> 01:14:58.800
It's

01:14:58.800 --> 01:15:00.720
a pretty good time to be a Python developer right now.

01:15:02.340 --> 01:15:03.040
It's only getting better.

01:15:03.400 --> 01:15:03.520
Absolutely.

01:15:05.240 --> 01:15:05.720
All right, Seth.

01:15:05.940 --> 01:15:08.220
Thanks for being back on the show and thanks for doing the write-up.

01:15:08.700 --> 01:15:09.320
Thanks for having me.

01:15:09.880 --> 01:15:09.960
Yep.

01:15:10.160 --> 01:15:10.400
See you later.

01:15:10.800 --> 01:15:11.060
Bye.

